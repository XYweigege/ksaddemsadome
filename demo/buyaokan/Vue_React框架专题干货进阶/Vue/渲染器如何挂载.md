
<font style="color:rgb(44, 62, 80);">本节主要讲解渲染器将各种类型的 </font><font style="color:rgb(199, 37, 78);">VNode</font><font style="color:rgb(44, 62, 80);"> 挂载为真实 DOM 的原理，阅读本章内容你将对 </font><font style="color:rgb(199, 37, 78);">Fragment</font><font style="color:rgb(44, 62, 80);"> 和 </font><font style="color:rgb(199, 37, 78);">Portal</font><font style="color:rgb(44, 62, 80);"> 有更加深入的理解，同时渲染器对有状态组件和函数式组件的挂载实际上也透露了有状态组件和函数式组件的实现原理，这都会包含在本章的内容之中。另外本章的代码将使用上一章所编写的 </font><font style="color:rgb(199, 37, 78);">h</font><font style="color:rgb(44, 62, 80);"> 函数，所以请确保你已经阅读了上一章的内容</font>

<br/>

## 渲染器
<font style="color:rgb(44, 62, 80);">所谓渲染器，简单的说就是将</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Virtual DOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">渲染成特定平台下真实</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的工具(就是一个函数，通常叫</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">render</font><font style="color:rgb(44, 62, 80);">)，渲染器的工作流程分为两个阶段：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mount</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">patch</font><font style="color:rgb(44, 62, 80);">，如果旧的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">存在，则会使用新的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">与旧的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">进行对比，试图以最小的资源开销完成</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的更新，这个过程就叫</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">patch</font><font style="color:rgb(44, 62, 80);">，或“打补丁”。如果旧的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">不存在，则直接将新的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">挂载成全新的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">，这个过程叫做</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mount</font><font style="color:rgb(44, 62, 80);">。</font>

<font style="color:rgb(44, 62, 80);">通常渲染器接收两个参数，第一个参数是将要被渲染的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> 对象，第二个参数是一个用来承载内容的容器(</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">container</font><font style="color:rgb(44, 62, 80);">)，通常也叫挂载点，如下代码所示：</font><font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
</font>

```javascript
function render(vnode, container) {
  const prevVNode = container.vnode
  if (prevVNode == null) {
    if (vnode) {
      // 没有旧的 VNode，只有新的 VNode。使用 `mount` 函数挂载全新的 VNode
      mount(vnode, container)
      // 将新的 VNode 添加到 container.vnode 属性下，这样下一次渲染时旧的 VNode 就存在了
      container.vnode = vnode
    }
  } else {
    if (vnode) {
      // 有旧的 VNode，也有新的 VNode。则调用 `patch` 函数打补丁
      patch(prevVNode, vnode, container)
      // 更新 container.vnode
      container.vnode = vnode
    } else {
      // 有旧的 VNode 但是没有新的 VNode，这说明应该移除 DOM，在浏览器中可以使用 removeChild 函数。
      container.removeChild(prevVNode.el)
      container.vnode = null
    }
  }
}
```

<font style="color:rgb(44, 62, 80);">整体思路非常简单，如果旧的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">不存在且新的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">存在，那就直接挂载(</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mount</font><font style="color:rgb(44, 62, 80);">)新的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">；如果旧的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">存在且新的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">不存在，那就直接将</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">移除；如果新旧</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">都存在，那就打补丁(</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">patch</font><font style="color:rgb(44, 62, 80);">)：</font>

| <font style="color:rgb(44, 62, 80);">旧 VNode</font> | <font style="color:rgb(44, 62, 80);">新 VNode</font> | <font style="color:rgb(44, 62, 80);">操作</font> |
| --- | --- | --- |
| <font style="color:rgb(44, 62, 80);">❌</font> | <font style="color:rgb(44, 62, 80);">✅</font> | <font style="color:rgb(44, 62, 80);">调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mount</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数</font> |
| <font style="color:rgb(44, 62, 80);">✅</font> | <font style="color:rgb(44, 62, 80);">❌</font> | <font style="color:rgb(44, 62, 80);">移除</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font> |
| <font style="color:rgb(44, 62, 80);">✅</font> | <font style="color:rgb(44, 62, 80);">✅</font> | <font style="color:rgb(44, 62, 80);">调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">patch</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数</font> |


<font style="color:rgb(44, 62, 80);">之所以说渲染器的责任非常之大，是因为它不仅仅是一个把</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">渲染成真实</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的工具，它还负责以下工作：</font>

+ <font style="color:rgb(44, 62, 80);">控制部分组件生命周期钩子的调用</font>

<font style="color:rgb(44, 62, 80);">在整个渲染周期中包含了大量的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">操作、组件的挂载、卸载，控制着组件的生命周期钩子调用的时机。</font>

+ <font style="color:rgb(44, 62, 80);">多端渲染的桥梁</font>

<font style="color:rgb(44, 62, 80);">渲染器也是多端渲染的桥梁，自定义渲染器的本质就是把特定平台操作“DOM”的方法从核心算法中抽离，并提供可配置的方案。</font>

+ <font style="color:rgb(44, 62, 80);">与异步渲染有直接关系</font>

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Vue3</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的异步渲染是基于调度器的实现，若要实现异步渲染，组件的挂载就不能同步进行，DOM的变更就要在合适的时机，一些需要在真实DOM存在之后才能执行的操作(如</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ref</font><font style="color:rgb(44, 62, 80);">)也应该在合适的时机进行。对于时机的控制是由调度器来完成的，但类似于组件的挂载与卸载以及操作</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">等行为的入队还是由渲染器来完成的，这也是为什么</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Vue2</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">无法轻易实现异步渲染的原因。</font>

+ <font style="color:rgb(44, 62, 80);">包含最核心的 Diff 算法</font>

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Diff</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">算法是渲染器的核心特性之一，可以说正是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Diff</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">算法的存在才使得</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Virtual DOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">如此成功。</font>

## [](https://www.123fe.net/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#%E6%8C%82%E8%BD%BD%E6%99%AE%E9%80%9A%E6%A0%87%E7%AD%BE%E5%85%83%E7%B4%A0)挂载普通标签元素
### [](https://www.123fe.net/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86)<font style="color:rgb(44, 62, 80);">基本原理</font>
<font style="color:rgb(44, 62, 80);">渲染器的责任重大，所以它做的事情也非常多，一口吃成胖子是不太现实的，我们需要一点点地消化。</font>

<font style="color:rgb(44, 62, 80);">在初次调用渲染器渲染某个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">时：</font>

```javascript
const vnode = {/*...*/}
render(vnode, container)
```

<font style="color:rgb(44, 62, 80);">由于没有旧的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">存在，所以会调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mount</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数挂载全新的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">，这个小节我们就探讨一下渲染器的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mount</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数是如何把</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">渲染成真实</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的，以及其中一些核心的关键点。</font>

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mount</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数的作用是把一个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">渲染成真实</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">，根据不同类型的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">需要采用不同的挂载方式，如下：</font>

```javascript
function mount(vnode, container) {
  const { flags } = vnode
  if (flags & VNodeFlags.ELEMENT) {
    // 挂载普通标签
    mountElement(vnode, container)
  } else if (flags & VNodeFlags.COMPONENT) {
    // 挂载组件
    mountComponent(vnode, container)
  } else if (flags & VNodeFlags.TEXT) {
    // 挂载纯文本
    mountText(vnode, container)
  } else if (flags & VNodeFlags.FRAGMENT) {
    // 挂载 Fragment
    mountFragment(vnode, container)
  } else if (flags & VNodeFlags.PORTAL) {
    // 挂载 Portal
    mountPortal(vnode, container)
  }
}
```

<font style="color:rgb(44, 62, 80);">我们根据</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">flags</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性值能够区分一个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">对象的类型，不同类型的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">采用不同的挂载函数：</font>

<font style="color:rgb(44, 62, 80);">我们首先来讨论一下</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountElement</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数，它用于挂载普通标签元素。我们在"组件的本质"一章中曾经编写过如下这段代码：</font>

```javascript
function mountElement(vnode, container) {
  const el = document.createElement(vnode.tag)
  container.appendChild(el)
}
```

<font style="color:rgb(44, 62, 80);">这是一个极简的用于挂载普通标签元素的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountElement</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数，它会调用浏览器提供的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">document.createElement</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数创建元素，接着调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">appendChild</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数将元素添加到</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">container</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中，但它具有以下缺陷：</font>

+ <font style="color:rgb(44, 62, 80);">1、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">被渲染为真实DOM之后，没有引用真实DOM元素</font>
+ <font style="color:rgb(44, 62, 80);">2、没有将</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">应用到真实DOM元素上</font>
+ <font style="color:rgb(44, 62, 80);">3、没有继续挂载子节点，即</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">children</font>
+ <font style="color:rgb(44, 62, 80);">4、不能严谨地处理</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">SVG</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">标签</font>

<font style="color:rgb(44, 62, 80);">针对这四个问题，我们逐个去解决。先来看第一个问题：</font>**<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font>****<font style="color:rgb(44, 62, 80);"> 被渲染为真实DOM之后，没有引用真实DOM元素</font>**<font style="color:rgb(44, 62, 80);">，这个问题很好解决，只需要添加一行代码即可：</font><font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
</font>

```javascript
function mountElement(vnode, container) {
  const el = document.createElement(vnode.tag)
  vnode.el = el
  container.appendChild(el)
}
```

<font style="color:rgb(44, 62, 80);">再来看第二个问题：</font>**<font style="color:rgb(44, 62, 80);">没有将</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(44, 62, 80);">应用到元素上</font>**<font style="color:rgb(44, 62, 80);">，我们知道</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">作为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的描述，对于标签元素来说它包含了元素的样式、事件等诸多信息，我们需要将这些信息应用到新创建的真实DOM元素上，假设我们有如下</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);">：</font>

**<font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);">TIP</font>**

<font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);">再次强调，本章使用上一章节中所编写的</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">h</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);"> </font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);">函数。</font>

```javascript
const elementVnode = h(
  'div',
  {
    style: {
      height: '100px',
      width: '100px',
      background: 'red'
    }
  }
)
```

<font style="color:rgb(44, 62, 80);">我们使用 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">h</font><font style="color:rgb(44, 62, 80);"> 函数创建了一个描述 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">div</font><font style="color:rgb(44, 62, 80);"> 标签的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> 对象，观察 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> 可以发现，它拥有一些内联样式，所以在 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountElement</font><font style="color:rgb(44, 62, 80);"> 函数内，我们需要将这些内联样式应用到元素上，我们给 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountElement</font><font style="color:rgb(44, 62, 80);"> 增加如下代码：</font><font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
</font>

```javascript
function mountElement(vnode, container) {
  const el = document.createElement(vnode.tag)

  // 拿到 VNodeData
  const data = vnode.data
  if (data) {
    // 如果 VNodeData 存在，则遍历之
    for(let key in data) {
      // key 可能是 class、style、on 等等
      switch(key) {
        case 'style':
          // 如果 key 的值是 style，说明是内联样式，逐个将样式规则应用到 el
          for(let k in data.style) {
            el.style[k] = data.style[k]
          }
          break
      }
    }
  }

  container.appendChild(el)
}
```

<font style="color:rgb(44, 62, 80);">如上代码所示，在创建真实DOM之后，我们需要检查</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是否存在，如果</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">存在则遍历之。由于</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中不仅仅包含内联样式的描述(即</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">style</font><font style="color:rgb(44, 62, 80);">)，还可能包含其他描述如</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">class</font><font style="color:rgb(44, 62, 80);">、事件等等，所以我们使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">switch...case</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">语句对不同的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">key</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">值做区分处理，以</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">style</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">为例，我们只需要将</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">data.style</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中的样式规则应用到真实DOM即可。使用渲染器渲染</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">elementVNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的效果如下：</font>

<font style="color:rgb(44, 62, 80);">对于 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">class</font><font style="color:rgb(44, 62, 80);"> 或事件或其他DOM属性都是类似的处理方式，为了不偏题我们放到后面统一讲解，接下来我们来看第三个问题：</font>**<font style="color:rgb(44, 62, 80);">没有继续挂载子节点，即 </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">children</font>**<font style="color:rgb(44, 62, 80);">，我们知道 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> 是有可能存在子节点的，现在的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountElement</font><font style="color:rgb(44, 62, 80);"> 函数仅仅将该 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> 本身所描述的DOM元素添加到了页面中，却没有理会其子节点，为了递归地挂载子节点，我们需要为 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountElement</font><font style="color:rgb(44, 62, 80);"> 函数增加如下代码：</font><font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
</font>

```javascript
function mountElement(vnode, container) {
  const el = document.createElement(vnode.tag)
  vnode.el = el
  // 省略处理 VNodeData 相关的代码

  // 递归挂载子节点
  if (vnode.children) {
    for (let i = 0; i < vnode.children.length; i++) {
      mountElement(vnode.children[i], el)
    }
  }

  container.appendChild(el)
}
```

<font style="color:rgb(44, 62, 80);">观察如上代码中用来递归挂载子节点的代码，我们默认把 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vnode.children</font><font style="color:rgb(44, 62, 80);"> 当作数组来处理，同时递归挂载的时候调用的仍然是 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountElement</font><font style="color:rgb(44, 62, 80);"> 函数。这存在两个瑕疵，第一个瑕疵是 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> 对象的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">children</font><font style="color:rgb(44, 62, 80);"> 属性不总是数组，因为当 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> 只有一个子节点时，该 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> 的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">children</font><font style="color:rgb(44, 62, 80);"> 属性直接指向该子节点，且 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> 的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">childFlags</font><font style="color:rgb(44, 62, 80);"> 的值为 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ChildrenFlags.SINGLE_VNODE</font><font style="color:rgb(44, 62, 80);">，所以我们不应该总是使用 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">for</font><font style="color:rgb(44, 62, 80);"> 循环遍历 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vnode.children</font><font style="color:rgb(44, 62, 80);">。第二个瑕疵是我们在 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">for</font><font style="color:rgb(44, 62, 80);"> 循环内部直接调用了 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountElement</font><font style="color:rgb(44, 62, 80);"> 属性去挂载每一个 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">children</font><font style="color:rgb(44, 62, 80);"> 中的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> 对象，但问题是 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">children</font><font style="color:rgb(44, 62, 80);"> 中的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> 对象可能是任意类型的，所以我们不应该直接调用 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountElement</font><font style="color:rgb(44, 62, 80);"> 函数，而是应该调用 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mount</font><font style="color:rgb(44, 62, 80);"> 函数。更加严谨的代码如下：</font><font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
</font>

```javascript
function mountElement(vnode, container) {
  const el = document.createElement(vnode.tag)
  vnode.el = el
  // 省略处理 VNodeData 的代码

  // 拿到 children 和 childFlags
  const childFlags = vnode.childFlags
  const children = vnode.children
  // 检测如果没有子节点则无需递归挂载
  if (childFlags !== ChildrenFlags.NO_CHILDREN) {
    if (childFlags & ChildrenFlags.SINGLE_VNODE) {
      // 如果是单个子节点则调用 mount 函数挂载
      mount(children, el)
    } else if (childFlags & ChildrenFlags.MULTIPLE_VNODES) {
      // 如果是单多个子节点则遍历并调用 mount 函数挂载
      for (let i = 0; i < children.length; i++) {
        mount(children[i], el)
      }
    }
  }

  container.appendChild(el)
}
```

<font style="color:rgb(44, 62, 80);">如上代码所示，我们通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vnode.childFlags</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">拿到该</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">子节点的类型，接着检测其是否含有子节点，如果存在子节点，会检测是单个子节点还是多个子节点，只有当存在多个子节点时其</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">children</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性才是可遍历的数组，最后调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mount</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数挂载之。</font>

<font style="color:rgb(44, 62, 80);">我们尝试修改之前的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">elementVNode</font><font style="color:rgb(44, 62, 80);">，为其添加子节点：</font><font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
  
</font>

```javascript
const elementVnode = h(
  'div',
  {
    style: {
      height: '100px',
      width: '100px',
      background: 'red'
    }
  },
  h('div', {
    style: {
      height: '50px',
      width: '50px',
      background: 'green'
    }
  })
)
```

<font style="color:rgb(44, 62, 80);">如上代码可知，我们为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">elementVnode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">添加了一个子节点，该子节点是一个边长为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">50px</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的绿色正方形，使用渲染器渲染修改后的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">elementVnode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的效果如下：</font>

<font style="color:rgb(44, 62, 80);">接着我们来看最后一个问题：</font>**<font style="color:rgb(44, 62, 80);">不能严谨地处理 </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">SVG</font>****<font style="color:rgb(44, 62, 80);"> 标签</font>**<font style="color:rgb(44, 62, 80);">，在之前的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountElement</font><font style="color:rgb(44, 62, 80);"> 函数中我们使用 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">document.createElement</font><font style="color:rgb(44, 62, 80);"> 函数创建DOM元素，但是对于 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">SVG</font><font style="color:rgb(44, 62, 80);"> 标签，更加严谨的方式是使用 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">document.createElementNS</font><font style="color:rgb(44, 62, 80);"> 函数，修改 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountElement</font><font style="color:rgb(44, 62, 80);"> 如下：</font><font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
</font>

```javascript
function mountElement(vnode, container) {
  const isSVG = vnode.flags & VNodeFlags.ELEMENT_SVG
  const el = isSVG
    ? document.createElementNS('http://www.w3.org/2000/svg', vnode.tag)
    : document.createElement(vnode.tag)
  vnode.el = el
  // 省略...
}
```

<font style="color:rgb(44, 62, 80);">我们通过 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vnode.flags</font><font style="color:rgb(44, 62, 80);"> 来判断一个标签是否是 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">SVG</font><font style="color:rgb(44, 62, 80);">，但是大家不要忘记 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vnode.flags</font><font style="color:rgb(44, 62, 80);"> 是如何被标记为 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeFlags.ELEMENT_SVG</font><font style="color:rgb(44, 62, 80);">的，我们在讲解 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">h</font><font style="color:rgb(44, 62, 80);"> 函数时说明过这个问题，如下代码所示：</font><font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
</font>

```javascript
function h(tag, data, children) {
  let flags = null
  if (typeof tag === 'string') {
    flags = tag === 'svg' ? VNodeFlags.ELEMENT_SVG : VNodeFlags.ELEMENT_HTML
  }
}
```

<font style="color:rgb(44, 62, 80);">我们注意到，只有当标签名字全等于字符串 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">'svg'</font><font style="color:rgb(44, 62, 80);"> 时，该 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> 的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">flags</font><font style="color:rgb(44, 62, 80);"> 才会被标记为 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeFlags.ELEMENT_SVG</font><font style="color:rgb(44, 62, 80);">，这意味着 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><circle/></font><font style="color:rgb(44, 62, 80);"> 标签不会被标记为 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeFlags.ELEMENT_SVG</font><font style="color:rgb(44, 62, 80);">，所以在创建 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><circle/></font><font style="color:rgb(44, 62, 80);"> 元素时并不会使用 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">document.createElementNS</font><font style="color:rgb(44, 62, 80);"> 函数，但 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><circle/></font><font style="color:rgb(44, 62, 80);"> 标签确实是 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">svg</font><font style="color:rgb(44, 62, 80);"> 标签，如何解决这个问题呢？其实很简单，因为 </font>**<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">svg</font>****<font style="color:rgb(44, 62, 80);"> 的书写总是以 </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><svg></font>****<font style="color:rgb(44, 62, 80);"> 标签开始的，所有其他 </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">svg</font>****<font style="color:rgb(44, 62, 80);"> 相关的标签都是 </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><svg></font>****<font style="color:rgb(44, 62, 80);"> 标签的子代元素</font>**<font style="color:rgb(44, 62, 80);">。所以解决方案就是：在 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountElement</font><font style="color:rgb(44, 62, 80);"> 函数中一旦 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">isSVG</font><font style="color:rgb(44, 62, 80);"> 为真，那么后续创建的所有子代元素都会被认为是 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">svg</font><font style="color:rgb(44, 62, 80);"> 标签，我们需要修改 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountElement</font><font style="color:rgb(44, 62, 80);"> 函数，为其添加第三个参数，如下：</font><font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
</font>

```javascript
function mountElement(vnode, container, isSVG) {
  isSVG = isSVG || vnode.flags & VNodeFlags.ELEMENT_SVG
  const el = isSVG
    ? document.createElementNS('http://www.w3.org/2000/svg', vnode.tag)
    : document.createElement(vnode.tag)
  // 省略处理 VNodeData 的代码

  const childFlags = vnode.childFlags
  if (childFlags !== ChildrenFlags.NO_CHILDREN) {
    if (childFlags & ChildrenFlags.SINGLE_VNODE) {
      // 这里需要把 isSVG 传递下去
      mount(children, el, isSVG)
    } else if (childFlags & ChildrenFlags.MULTIPLE_VNODES) {
      for (let i = 0; i < children.length; i++) {
        // 这里需要把 isSVG 传递下去
        mount(children[i], el, isSVG)
      }
    }
  }

  container.appendChild(el)
}
```

<font style="color:rgb(44, 62, 80);">如上代码所示，我们为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountElement</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">增加了第三个参数</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">isSVG</font><font style="color:rgb(44, 62, 80);">，接着在判断一个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是否是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">svg</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">元素时优先使用参数中的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">isSVG</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">作为判断条件，并且使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vnode.flags & VNodeFlags.ELEMENT_SVG</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">作为回退判断条件，最后在挂载子节点的时候将</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">isSVG</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">参数传递下去。这样我们就能达到一个目的：</font>**<font style="color:rgb(44, 62, 80);">即使</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><circle/></font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(44, 62, 80);">标签对应的</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vnode.flags</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(44, 62, 80);">不是</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeFlags.ELEMENT_SVG</font>****<font style="color:rgb(44, 62, 80);">，但在</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountElement</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(44, 62, 80);">函数看来它依然是</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">svg</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(44, 62, 80);">标签</font>**<font style="color:rgb(44, 62, 80);">。</font>


**<font style="color:rgb(44, 62, 80);">TIP</font>**

<font style="color:rgb(44, 62, 80);">实际上我们也应该对大部分挂载函数做一定的修改，即增加第三个参数，这里就省略了。完整可运行代码请查看：</font>[https://codesandbox.io/s/6v38x6k0nw(opens new window)](https://codesandbox.io/s/6v38x6k0nw)

<br/>

### [](https://www.123fe.net/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#class%E7%9A%84%E5%A4%84%E7%90%86)<font style="color:rgb(44, 62, 80);">class的处理</font>
<font style="color:rgb(44, 62, 80);">前面我们在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountElement</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数中实现了将内联样式应用到元素的功能，接着我们来想办法将</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">class</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">也应用到元素上，在开始实现功能之前我们第一步要做的是：</font>**<font style="color:rgb(44, 62, 80);">设计数据结构</font>**<font style="color:rgb(44, 62, 80);">，比如我们采用了</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">data.style</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">来存储内联样式的数据，并且其数据结构就是一个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">key-value</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的映射，对于</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">class</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">我们希望使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">data.class</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">来存储其数据，并且我们希望</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">data.class</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的值就是类名字符串，例如：</font>



```javascript
const elementVnode = h(
  'div',
  {
    class: 'cls-a cls-b'
  }
)
```

<font style="color:rgb(44, 62, 80);">这样我们就可以轻松将类名列表添加到DOM元素上，我们为 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountElement</font><font style="color:rgb(44, 62, 80);"> 添加如下代码：</font><font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
</font>

```javascript
function mountElement(vnode, container, isSVG) {
  // 省略...

  const data = vnode.data
  if (data) {
    for (let key in data) {
      switch (key) {
        case 'style':
          for (let k in data.style) {
            el.style[k] = data.style[k]
          }
          break
        case 'class':
          el.className = data[key]
          break
        default:
          break
      }
    }
  }

  // 省略...
}
```

<font style="color:rgb(44, 62, 80);">如上高亮代码所示，我们给</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">switch</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">添加了一个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">case</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">语句块，用来匹配</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">class</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">数据，由于我们将</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">data.class</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">设计成了可直接使用的类名列表字符串，所以只需要直接将</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">data.class</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">赋值给</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el.className</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">即可，如下是渲染</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">elementVNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的效果：</font>

<font style="color:rgb(44, 62, 80);">效果已经达到了，但是我们需要额外思考一些东西。在上面的讲解中我们直接把</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">data.class</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的数据结构设计成可直接使用的类名列表字符串，但这是很底层的设计，换句话说这是框架层面的设计，我们还需要考虑应用层的设计，什么意思呢？来看如下这段模板：</font>

```html
<template>
  <div class="cls-a" :class="dynamicClass"></div>
</template>
```

<font style="color:rgb(44, 62, 80);">在这段模板中我们同时使用了</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">class</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性和绑定的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">:class</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性，对于非绑定的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">class</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性来说它的值就是我们最终想要的类名列表字符串，但是对于绑定的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">:class</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性来说它的值是动态的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">javascript</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">值，所以我们需要设计一下哪些值是被允许的。</font>

<font style="color:rgb(44, 62, 80);">首先数组应该是被允许的：</font>

```javascript
dynamicClass = ['class-b', 'class-c']
```

<font style="color:rgb(44, 62, 80);">对象也应该是被允许的：</font>

```javascript
dynamicClass = {
  'class-b': true,
  'class-c': true
}
```

<font style="color:rgb(44, 62, 80);">在编译器对模板进行编译时，我们把非绑定和绑定的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">class</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性值合并，如下是我们期望编译器对上面模板的编译结果：</font>

```javascript
h('div', {
  class: ['class-a', dynamicClass]
})
```

<font style="color:rgb(44, 62, 80);">如果</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">dynamicClass</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是数组，那么如上代码等价于：</font>

```javascript
h('div', {
  class: ['class-a', ['class-b', 'class-c']]
})
```

<font style="color:rgb(44, 62, 80);">如果</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">dynamicClass</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是对象，那么编译的结果等价于：</font>

```javascript
h('div', {
  class: [
    'class-a',
    {
      'class-b': true,
      'class-c': true
    }
  ]
})
```

<font style="color:rgb(44, 62, 80);">可以看到在使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">h</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数创建</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">时，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">class</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">还不可能是我们最终想要的类名列表字符串，那怎么办呢？很简单，我们只需要在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">h</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数内部编写一个函数将如上数据结构序列化成我们想要的类名列表字符串就可以了，这就像一个小小的算法题目，相信大家都写的出来，这里就不展开讲解，下面的链接中拥有完整的可执行代码。</font>


**<font style="color:rgb(44, 62, 80);">TIP</font>**

<font style="color:rgb(44, 62, 80);">完整代码&在线体验地址：</font>[https://codesandbox.io/s/397w7kxy1(opens new window)](https://codesandbox.io/s/397w7kxy1)

<br/>

<font style="color:rgb(44, 62, 80);">实际上，通过对</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">class</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的讲解，我们涉及了在框架设计中比较重要的概念：</font>**<font style="color:rgb(44, 62, 80);">应用层的设计</font>**<font style="color:rgb(44, 62, 80);">，这是框架设计的核心，在设计一个功能的时候，你首先要考虑的应该是应用层的使用，然后再考虑如何与底层衔接。还是以</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">class</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">为例，为一个标签元素设置类名的方法是可定的(调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el.className</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">或</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setAttribute</font><font style="color:rgb(44, 62, 80);">)，关键就在于你想在应用层做出怎样的设计，很自然的你要思考如何转化应用层的数据结构与底层衔接。</font>

### [](https://www.123fe.net/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#attributes-%E5%92%8C-dom-properties)<font style="color:rgb(44, 62, 80);">Attributes 和 DOM Properties</font>
<font style="color:rgb(44, 62, 80);">接下来我们讲一讲DOM的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Attributes</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">以及</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Properties</font><font style="color:rgb(44, 62, 80);">，下面我们分别简称他们为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">attr</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM Prop</font><font style="color:rgb(44, 62, 80);">，那么他们两个之间有什么区别呢？这里我们简单解释一下，我们知道浏览器在加载页面之后会对页面中的标签进行解析，并生成与之相符的 DOM 对象，每个标签中都可能包含一些属性，如果这些属性是</font>**<font style="color:rgb(44, 62, 80);">标准属性</font>**<font style="color:rgb(44, 62, 80);">，那么解析生成的DOM对象中也会包含与之对应的属性，例如：</font>

```html
<body id="page"></body>
```

<font style="color:rgb(44, 62, 80);">由于</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">id</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是标准属性，所以我们可以通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">document.body.id</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">来访问它的值，实际上我们常说的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Attr</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">指的就是那些存在于标签上的属性，而</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM Prop</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">就是存在于DOM对象上的属性。但是当标签上存在非标准属性时，该属性不会被转化为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM Prop</font><font style="color:rgb(44, 62, 80);">，例如：</font>

```html
<body custom="val"></body>
```

<font style="color:rgb(44, 62, 80);">由于</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">custom</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是非标准属性，所以当你尝试通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">document.body.custom</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">访问其值时会得到</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">undefined</font><font style="color:rgb(44, 62, 80);">，这也是为什么</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setAttribute</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">方法存在的原因，因为该方法允许我们为 DOM 元素设置自定义属性（不会初始化同名的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">property</font><font style="color:rgb(44, 62, 80);">）。另外该方法也允许我们为 DOM 元素设置标准属性的值，所以我们可不可以总是使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setAttribute</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">设置全部的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性呢？答案是：不行。举个例子：</font>

```javascript
// checkbox 元素
const checkboxEl = document.querySelector('input')
// 使用 setAttribute 设置 checked 属性为 false
checkboxEl.setAttribute('checked', false)

console.log(checkboxEl.checked) // true
```

<font style="color:rgb(44, 62, 80);">可以看到虽然我们使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setAttribute</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数将复选框的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">checked</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性设置为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">false</font><font style="color:rgb(44, 62, 80);">，但是当我们访问</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">checkboxEl.checked</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">时得到的依然是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">true</font><font style="color:rgb(44, 62, 80);">，这是因为在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setAttribute</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数为元素设置属性时，无论你传递的值是什么类型，它都会将该值转为字符串再设置到元素上，所以如下两句代码是等价的：</font>

```javascript
checkboxEl.setAttribute('checked', false)
// 等价于
checkboxEl.setAttribute('checked', 'false')
```

**<font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);">TIP</font>**

<font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);">一些特殊的</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">attribute</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);">，比如</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">checked/disabled</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);"> </font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);">等，只要出现了，对应的</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">property</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);"> </font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);">就会被初始化为</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">true</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);">，无论设置的值是什么,只有调用</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">removeAttribute</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);"> </font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);">删除这个</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">attribute</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);">，对应的</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">property</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);"> </font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);">才会变成</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">false</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);">。</font>

<font style="color:rgb(44, 62, 80);">这就指引我们有些属性不能通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setAttribute</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">设置，而是应该直接通过 DOM 元素设置：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el.checked = true</font><font style="color:rgb(44, 62, 80);">。好在这样的属性不多，我们可以列举出来：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">value</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">checked</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">selected</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">muted</font><font style="color:rgb(44, 62, 80);">。除此之外还有一些属性也需要使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Property</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的方式设置到 DOM 元素上，例如</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">innerHTML</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">textContent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">等等。</font>

<font style="color:rgb(44, 62, 80);">刚才我们讲解了为什么同样是写在标签上的属性，却要区分对待的原因，接下来我们进入正题，开始完成将属性应用到 DOM 元素上的实现，到目前为止，我们已经为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">设计了三个属性，如下：</font>

```javascript
{
  style: ..., // 内联样式数据
  class: ..., // class 数据
    target: ... // Portal 的挂载目标
    }
```

<font style="color:rgb(44, 62, 80);">接下来我们还会为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">添加更多属性，用来存储标签的数据，如下</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">input</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">标签所示：</font>

```html
<input class="cls-a" type="checkbox" checked custom="1"/>
```

<font style="color:rgb(44, 62, 80);">它有四个属性，我们打算在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中存储其属性名以及数据：</font>

```javascript
h('input', {
  class: 'cls-a',
  type: 'checkbox',
  checked: true,
  custom: '1'
})
```

<font style="color:rgb(44, 62, 80);">如上代码所示，我们已经实现了关于</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">class</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">style</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的处理，所以接下来我们要处理的就是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中除</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">class</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">style</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">之外的全部数据，当然也要排除</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">target</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性，因为它只用于</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Portal</font><font style="color:rgb(44, 62, 80);">。处理方式很简单，我们为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountElement</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数添加如下高亮代码：</font>

<font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);"></font>

```javascript
const domPropsRE = /\[A-Z]|^(?:value|checked|selected|muted)$/
function mountElement(vnode, container, isSVG) {
  // 省略...

  const data = vnode.data
  if (data) {
    for (let key in data) {
      switch (key) {
        case 'style':
          for (let k in data.style) {
            el.style[k] = data.style[k]
          }
          break
        case 'class':
          el.className = data[key]
          break
        default:
          if (domPropsRE.test(key)) {
            // 当作 DOM Prop 处理
            el[key] = data[key]
          } else {
            // 当作 Attr 处理
            el.setAttribute(key, data[key])
          }
          break
      }
    }
  }

  // 省略...
}
```

<font style="color:rgb(44, 62, 80);">如上高亮代码所示，我们首先创建了一个正则表达式</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">domPropsRE</font><font style="color:rgb(44, 62, 80);">，用来检测那些应该以</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Property</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的方式添加到 DOM 元素上的属性，其他的属性使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setAttribute</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">方法设置。另外我们注意到正则</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">domPropsRE</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">除了用来匹配我们前面说过的固定的几个属性之外，它还能匹配那些拥有大写字母的属性，这是为了匹配诸如</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">innerHTML</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">textContent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">等属性设计的，同时这也顺便实现了一个特性，即拥有大写字母的属性我们都会采用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el[key] = xxx</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的方式将其添加到 DOM 元素上。</font>

<font style="color:rgb(44, 62, 80);">如下是渲染上面</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">input</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">标签的效果图：</font>


**<font style="color:rgb(44, 62, 80);">TIP</font>**

<font style="color:rgb(44, 62, 80);">完整代码&在线体验地址：</font>[https://codesandbox.io/s/821421zvp8(opens new window)](https://codesandbox.io/s/821421zvp8)

<br/>

### [](https://www.123fe.net/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%A4%84%E7%90%86)<font style="color:rgb(44, 62, 80);">事件的处理</font>
<font style="color:rgb(44, 62, 80);">现在我们只剩下为 DOM 元素添加事件了，实际上在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mount</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">阶段为 DOM 元素添加事件很容易，我们只需要在元素对象上调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">addEventListener</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">方法即可，关键在于我们的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">要如何设计。</font>

<font style="color:rgb(44, 62, 80);">通常我们给元素添加事件的规则是</font>**<font style="color:rgb(44, 62, 80);">使用</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-on</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(44, 62, 80);">或</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">@</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(44, 62, 80);">符号加上事件名字</font>**<font style="color:rgb(44, 62, 80);">，例如给元素添加点击事件：</font>

```html
<div @click="handler"></div>
```

<font style="color:rgb(44, 62, 80);">当然事件名字中不包含</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">'on'</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">前缀，即</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">click</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">而不是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">onclick</font><font style="color:rgb(44, 62, 80);">，我们可以用如下</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">对象来描述如上模板：</font>

```javascript
const elementVNode = h('div', {
  click: handler
})
```

<font style="color:rgb(44, 62, 80);">然而这么做是有问题的，如上代码所示</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">elementVNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">click</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性没办法与其他DOM属性区分，所以渲染器并不知道</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">click</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性代表的是事件，当然我们可以做出规定，例如我们规定</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">click</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性是个特殊的属性，它用来存储事件回调函数，但这是很笨的方法，因为 DOM 原生事件很多，这种方案需要我们一一列举所有 DOM 事件并且扩展性很差。所以我们需要考虑如何将事件与属性区分，其实我们就沿用原生 DOM 对象的设计即可，在原生 DOM 对象中所有事件函数的名字都是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">'on' + 事件名称</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的形式，所以我们可以在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">onclick</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">代替</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">click</font><font style="color:rgb(44, 62, 80);">：</font>

```javascript
const elementVNode = h('div', {
  onclick: handler
})
```

<font style="color:rgb(44, 62, 80);">当然从模板到</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的这个变化是由编译器来做的，这样设计之后我们就可以很容易地区分</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中的某个属性是 DOM 属性还是 DOM 事件：</font>**<font style="color:rgb(44, 62, 80);">只需要检测属性名的前两个字符是不是</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">'on'</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(44, 62, 80);">即可</font>**<font style="color:rgb(44, 62, 80);">。</font>

<font style="color:rgb(44, 62, 80);">在区分出事件之后，我们就可以着手将事件添加到 DOM 元素上了，只需调用 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el.addEventListener</font><font style="color:rgb(44, 62, 80);"> 方法即可，如下：</font>

```javascript
function mountElement(vnode, container, isSVG) {
  // 省略...

  const data = vnode.data
  if (data) {
    for (let key in data) {
      switch (key) {
        case 'style':
          for (let k in data.style) {
            el.style[k] = data.style[k]
          }
          break
        case 'class':
          if (isSVG) {
            el.setAttribute('class', data[key])
          } else {
            el.className = data[key]
          }
          break
        default:
          if (key[0] === 'o' && key[1] === 'n') {
            // 事件
            el.addEventListener(key.slice(2), data[key])
          } else if (domPropsRE.test(key)) {
            // 当作 DOM Prop 处理
            el[key] = data[key]
          } else {
            // 当作 Attr 处理
            el.setAttribute(key, data[key])
          }
          break
      }
    }
  }

  // 省略...
}
```

<font style="color:rgb(44, 62, 80);">如上高亮代码所示，我们通过检查</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeData</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">对象的键名(</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">key</font><font style="color:rgb(44, 62, 80);">)的前两个字符是否是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">'on'</font><font style="color:rgb(44, 62, 80);">，来区分其是否是事件，如果是事件则调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el.addEventListener</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">将事件回调函数添加到元素上。</font>

<font style="color:rgb(44, 62, 80);">我们可以测试一下我们的代码：</font>

```javascript
// 事件回调函数
function handler() {
  alert('click me')
}

// VNode
const elementVnode = h('div', {
  style: {
    width: '100px',
    height: '100px',
    backgroundColor: 'red'
  },
  // 点击事件
  onclick: handler
})

render(elementVnode, document.getElementById('app'))
```

<font style="color:rgb(44, 62, 80);">其效果如下，当点击红色方块时会触发点击事件执行回调函数：</font>


**<font style="color:rgb(44, 62, 80);">TIP</font>**

<font style="color:rgb(44, 62, 80);">完整代码&在线体验地址：</font>[https://codesandbox.io/s/jzvjwp7p75(opens new window)](https://codesandbox.io/s/jzvjwp7p75)

<font style="color:rgb(44, 62, 80);">需要强调的是，在 </font><font style="color:rgb(199, 37, 78);">mount</font><font style="color:rgb(44, 62, 80);"> 阶段我们没有考虑事件更新的情况，我们会在讲解 </font><font style="color:rgb(199, 37, 78);">patch</font><font style="color:rgb(44, 62, 80);"> 阶段的内容时说明。</font>

<br/>

## [](https://www.123fe.net/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#%E6%8C%82%E8%BD%BD%E7%BA%AF%E6%96%87%E6%9C%AC%E3%80%81fragment-%E5%92%8C-portal)挂载纯文本、Fragment 和 Portal
### [](https://www.123fe.net/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#%E6%8C%82%E8%BD%BD%E6%96%87%E6%9C%AC%E8%8A%82%E7%82%B9)<font style="color:rgb(44, 62, 80);">挂载文本节点</font>
<font style="color:rgb(44, 62, 80);">如果一个 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> 的类型是 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeFlags.TEXT</font><font style="color:rgb(44, 62, 80);">，那么 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mount</font><font style="color:rgb(44, 62, 80);"> 函数会调用 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountText</font><font style="color:rgb(44, 62, 80);"> 函数挂载该纯文本元素：</font><font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
</font>

```javascript
function mount(vnode, container, isSVG) {
  const { flags } = vnode
  if (flags & VNodeFlags.ELEMENT) {
    // 挂载普通标签
    mountElement(vnode, container, isSVG)
  } else if (flags & VNodeFlags.COMPONENT) {
    // 挂载组件
    mountComponent(vnode, container, isSVG)
  } else if (flags & VNodeFlags.TEXT) {
    // 挂载纯文本
    mountText(vnode, container)
  } else if (flags & VNodeFlags.FRAGMENT) {
    // 挂载 Fragment
    mountFragment(vnode, container, isSVG)
  } else if (flags & VNodeFlags.PORTAL) {
    // 挂载 Portal
    mountPortal(vnode, container)
  }
}
```

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountText</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数实现起来很简单，由于纯文本类型的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">其</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">children</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性存储着与之相符的文本字符串，所以只需要调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">document.createTextNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数创建一个文本节点即可，然后将其添加到</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">container</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中，如下：</font>

```plain
function mountText(vnode, container) {
  const el = document.createTextNode(vnode.children)
  vnode.el = el
  container.appendChild(el)
}
```

<font style="color:rgb(44, 62, 80);">我们修改一下之前的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">elementVNode</font><font style="color:rgb(44, 62, 80);">，为其添加一个文本子节点：</font>



```javascript
const elementVNode = h(
  'div',
  {
    style: {
      height: '100px',
      width: '100px',
      background: 'red'
    }
  },
  '我是文本'
)
```

<font style="color:rgb(44, 62, 80);">使用渲染器渲染如上</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">elementVnode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的结果如下图所示：</font>


**<font style="color:rgb(44, 62, 80);">TIP</font>**

<font style="color:rgb(44, 62, 80);">完整代码&在线体验地址：</font>[https://codesandbox.io/s/72zq40y0q6(opens new window)](https://codesandbox.io/s/72zq40y0q6)

<br/>

### [](https://www.123fe.net/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#%E6%8C%82%E8%BD%BD-fragment)<font style="color:rgb(44, 62, 80);">挂载 Fragment</font>
<font style="color:rgb(44, 62, 80);">其实挂载</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Fragment</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">和单纯地挂载一个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">children</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是没什么区别的，在没有</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Fragment</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">时我们要想挂载一个片段，这个片段必须使用包裹元素包裹，如下：</font>

```html
<!-- div 就是包裹元素 -->
<div>
  <h1></h1>
  <p></p>
</div>
```

<font style="color:rgb(44, 62, 80);">有了</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Fragment</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">则不需要包裹元素：</font>

```html
<Fragment>
  <h1></h1>
  <p></p>
</Fragment>
```

<font style="color:rgb(44, 62, 80);">这两段代码的区别是：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><Fragment></font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">标签不会被渲染为真实DOM，也就不会产生多余的DOM元素，再来观察一下这两个模板片段对应的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);">：</font>

+ <font style="color:rgb(44, 62, 80);">没有 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Fragment</font><font style="color:rgb(44, 62, 80);">：</font><font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
</font>

```javascript
const elementVNode = {
  flags: VNodeFlags.ELEMENT_HTML,
  tag: "div",
  data: null,
  childFlags: ChildrenFlags.MULTIPLE_VNODES,
  children: [
    {
      flags: VNodeFlags.ELEMENT_HTML,
      tag: 'h1',
      data: null,
      childFlags: ChildrenFlags.NO_CHILDREN,
      children: null,
      el: null
    },
    {
      flags: VNodeFlags.ELEMENT_HTML,
      tag: 'p',
      data: null
        childFlags: ChildrenFlags.NO_CHILDREN,
  children: null,
  el: null
}
],
  el: null
}
```

+ <font style="color:rgb(44, 62, 80);">有 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Fragment</font><font style="color:rgb(44, 62, 80);">：</font><font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
  
</font>

```javascript
const elementVNode = {
  flags: VNodeFlags.FRAGMENT,
  tag: null,
  data: null,
  childFlags: ChildrenFlags.MULTIPLE_VNODES,
  children: [
    {
      flags: VNodeFlags.ELEMENT_HTML,
      tag: 'h1',
      data: null,
      childFlags: ChildrenFlags.NO_CHILDREN,
      children: null,
      el: null
    },
    {
      flags: VNodeFlags.ELEMENT_HTML,
      tag: 'p',
      data: null
        childFlags: ChildrenFlags.NO_CHILDREN,
  children: null,
  el: null
}
],
  el: null
}
```

<font style="color:rgb(44, 62, 80);">通过对比可以很容易地发现，使用包裹元素的模板与</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Fragment</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">唯一的区别就是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">elementVNode.flags</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">elementVNode.tag</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的不同。在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mount</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数内部，如果一个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的类型是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Fragment</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">(即</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeFlags.FRAGMENT</font><font style="color:rgb(44, 62, 80);">)，则会使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountFragment</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数进行挂载，实际上对于</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Fragment</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">类型的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的挂载，就等价于只挂载一个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">children</font><font style="color:rgb(44, 62, 80);">，仅此而已，实现如下：</font>

```javascript
function mountFragment(vnode, container, isSVG) {
  // 拿到 children 和 childFlags
  const { children, childFlags } = vnode
  switch (childFlags) {
    case ChildrenFlags.SINGLE_VNODE:
      // 如果是单个子节点，则直接调用 mount
      mount(children, container, isSVG)
      break
    case ChildrenFlags.NO_CHILDREN:
      // 如果没有子节点，等价于挂载空片段，会创建一个空的文本节点占位
      const placeholder = createTextVNode('')
      mountText(placeholder, container)
      break
    default:
      // 多个子节点，遍历挂载之
      for (let i = 0; i < children.length; i++) {
        mount(children[i], container, isSVG)
      }
  }
}
```

<font style="color:rgb(44, 62, 80);">逻辑非常简单，既然只需要挂载</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">children</font><font style="color:rgb(44, 62, 80);">，那么就必须拿到</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">children</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">才行，顺便拿到</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">children</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的类型</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">childFlags</font><font style="color:rgb(44, 62, 80);">，然后根据不同的类型采用不同的挂载方式，其本质就是递归地调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mount</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数进行挂载。</font>

<font style="color:rgb(44, 62, 80);">我们可以修改 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">elementVnode</font><font style="color:rgb(44, 62, 80);">，让它的子节点是一个 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Fragment</font><font style="color:rgb(44, 62, 80);">。 如下：</font>

```javascript
const elementVNode = h(
  'div',
  {
    style: {
      height: '100px',
      width: '100px',
      background: 'red'
    }
  },
  h(Fragment, null, [
    h('span', null, '我是标题1......'),
    h('span', null, '我是标题2......')
  ])
)
```

<font style="color:rgb(44, 62, 80);">最终的渲染效果如下图所示：</font>

<font style="color:rgb(44, 62, 80);">另外对于 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Fragment</font><font style="color:rgb(44, 62, 80);"> 类型的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> 来说，当它被渲染为真实DOM之后，其 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el</font><font style="color:rgb(44, 62, 80);"> 属性的引用是谁呢？这需要根据片段中节点的数量来决定，如果只有一个节点，那么 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el</font><font style="color:rgb(44, 62, 80);"> 属性就指向该节点；如果有多个节点，则 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el</font><font style="color:rgb(44, 62, 80);"> 属性值是第一个节点的引用；如果片段中没有节点，即空片段，则 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el</font><font style="color:rgb(44, 62, 80);"> 属性引用的是占位的空文本节点元素，所以我们需要为 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountFragment</font><font style="color:rgb(44, 62, 80);"> 函数增加三句代码，如下：</font><font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
</font>

```javascript
function mountFragment(vnode, container, isSVG) {
  const { children, childFlags } = vnode
  switch (childFlags) {
    case ChildrenFlags.SINGLE_VNODE:
      mount(children, container, isSVG)
      // 单个子节点，就指向该节点
      vnode.el = children.el
      break
    case ChildrenFlags.NO_CHILDREN:
      const placeholder = createTextVNode('')
      mountText(placeholder, container)
      // 没有子节点指向占位的空文本节点
      vnode.el = placeholder.el
      break
    default:
      for (let i = 0; i < children.length; i++) {
        mount(children[i], container, isSVG)
      }
      // 多个子节点，指向第一个子节点
      vnode.el = children[0].el
  }
}
```

<font style="color:rgb(44, 62, 80);">那么这样设计有什么意义呢？这是因为在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">patch</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">阶段对DOM元素进行移动时，应该确保将其放到正确的位置，而不应该始终使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">appendChild</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数，有时需要使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">insertBefore</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数，这时候我们就需要拿到相应的节点引用，这时候</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vnode.el</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性是必不可少的，就像上面的代码中即使</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Fragment</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">没有子节点我们依然需要一个占位的空文本节点作为位置的引用。</font>


**<font style="color:rgb(44, 62, 80);">TIP</font>**

<font style="color:rgb(44, 62, 80);">完整代码&在线体验地址：</font>[https://codesandbox.io/s/109r8nlwk4(opens new window)](https://codesandbox.io/s/109r8nlwk4)

<br/>

### [](https://www.123fe.net/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#%E6%8C%82%E8%BD%BD-portal)<font style="color:rgb(44, 62, 80);">挂载 Portal</font>
<font style="color:rgb(44, 62, 80);">实际上 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Portal</font><font style="color:rgb(44, 62, 80);"> 可以不严谨地认为是</font>**<font style="color:rgb(44, 62, 80);">可以被到处挂载的 </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Fragment</font>**<font style="color:rgb(44, 62, 80);">。类型为 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Fragment</font><font style="color:rgb(44, 62, 80);"> 的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> 其 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">tag</font><font style="color:rgb(44, 62, 80);"> 属性值为 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">null</font><font style="color:rgb(44, 62, 80);">，而类型是 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Portal</font><font style="color:rgb(44, 62, 80);"> 的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> 其 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">tag</font><font style="color:rgb(44, 62, 80);"> 属性值为挂载点(选择器或真实DOM元素)。实现 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Portal</font><font style="color:rgb(44, 62, 80);"> 的关键是要将其 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> 的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">children</font><font style="color:rgb(44, 62, 80);"> 中所包含的子 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> 挂载到 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">tag</font><font style="color:rgb(44, 62, 80);"> 属性所指向的挂载点，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountPortal</font><font style="color:rgb(44, 62, 80);"> 函数的实现如下：</font>

```javascript
function mountPortal(vnode, container) {
  const { tag, children, childFlags } = vnode

  // 获取挂载点
  const target = typeof tag === 'string' ? document.querySelector(tag) : tag

  if (childFlags & ChildrenFlags.SINGLE_VNODE) {
    // 将 children 挂载到 target 上，而非 container
    mount(children, target)
  } else if (childFlags & ChildrenFlags.MULTIPLE_VNODES) {
    for (let i = 0; i < children.length; i++) {
      // 将 children 挂载到 target 上，而非 container
      mount(children[i], target)
    }
  }
}
```

<font style="color:rgb(44, 62, 80);">如上代码所示，挂载</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Portal</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的关键是我们需要通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vnode.tag</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">获取到真正的挂载点，也就是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">target</font><font style="color:rgb(44, 62, 80);">，真正挂载时使用此挂载点代替</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">container</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">即可。</font>

<font style="color:rgb(44, 62, 80);">那么对于 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Portal</font><font style="color:rgb(44, 62, 80);"> 类型的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> 其 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el</font><font style="color:rgb(44, 62, 80);"> 属性应该指向谁呢？应该指向挂载点元素吗？实际上虽然 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Portal</font><font style="color:rgb(44, 62, 80);"> 所描述的内容可以被挂载到任何位置，但仍然需要一个占位元素，并且 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Portal</font><font style="color:rgb(44, 62, 80);"> 类型的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> 其 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el</font><font style="color:rgb(44, 62, 80);"> 属性应该指向该占位元素，为什么这么设计呢？这是因为 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Portal</font><font style="color:rgb(44, 62, 80);"> 的另外一个特性：</font>**<font style="color:rgb(44, 62, 80);">虽然 </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Portal</font>****<font style="color:rgb(44, 62, 80);"> 的内容可以被渲染到任意位置，但它的行为仍然像普通的DOM元素一样，如事件的捕获/冒泡机制仍然按照代码所编写的DOM结构实施</font>**<font style="color:rgb(44, 62, 80);">。要实现这个功能就必须需要一个占位的DOM元素来承接事件。但目前来说，我们用一个空的文本节点占位即可，我们为 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountPortal</font><font style="color:rgb(44, 62, 80);"> 函数添加如下代码：</font><font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
</font>

```javascript
function mountPortal(vnode, container) {
  const { tag, children, childFlags } = vnode
  const target = typeof tag === 'string' ? document.querySelector(tag) : tag
  if (childFlags & ChildrenFlags.SINGLE_VNODE) {
    mount(children, target)
  } else if (childFlags & ChildrenFlags.MULTIPLE_VNODES) {
    for (let i = 0; i < children.length; i++) {
      mount(children[i], target)
    }
  }

  // 占位的空文本节点
  const placeholder = createTextVNode('')
  // 将该节点挂载到 container 中
  mountText(placeholder, container, null)
  // el 属性引用该节点
  vnode.el = placeholder.el
}
```

<font style="color:rgb(44, 62, 80);">如上高亮代码所示，我们创建了一个空文本节点，并将它挂载到</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">container</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">下(</font>**<font style="color:rgb(44, 62, 80);">注意不是挂载到</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">target</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(44, 62, 80);">下</font>**<font style="color:rgb(44, 62, 80);">)，最后让</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Portal</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">类型的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">节点的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性引用该空文本节点。</font>

<font style="color:rgb(44, 62, 80);">为了测试我们的代码，我们修改 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">elementVNode</font><font style="color:rgb(44, 62, 80);"> 如下：</font>

```javascript
const elementVNode = h(
  'div',
  {
    style: {
      height: '100px',
      width: '100px',
      background: 'red'
    }
  },
  h(Portal, { target: 'portal-box' }, [
    h('span', null, '我是标题1......'),
    h('span', null, '我是标题2......')
  ])
)
```

<font style="color:rgb(44, 62, 80);">使用渲染器渲染该</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">elementVNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的效果图如下：</font>

<font style="color:rgb(44, 62, 80);">可以发现</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Portal</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的挂载点是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">portal-box</font><font style="color:rgb(44, 62, 80);">，而非</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">app</font><font style="color:rgb(44, 62, 80);">。</font>


**<font style="color:rgb(44, 62, 80);">TIP</font>**

<font style="color:rgb(44, 62, 80);">完整代码&在线体验地址：</font>[https://codesandbox.io/s/nr16wzln8m(opens new window)](https://codesandbox.io/s/nr16wzln8m)

<br/>

## [](https://www.123fe.net/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8C%82%E8%BD%BD%E5%92%8C%E5%8E%9F%E7%90%86)有状态组件的挂载和原理
<font style="color:rgb(44, 62, 80);">我们在“组件的本质”一章中讲到过：</font>**<font style="color:rgb(44, 62, 80);">组件的产出是</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font>**<font style="color:rgb(44, 62, 80);">，当时我们也大致实现了有状态组件的挂载，其思路是</font>**<font style="color:rgb(44, 62, 80);">拿到组件产出的</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font>****<font style="color:rgb(44, 62, 80);">，并将之挂载到正确的</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">container</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(44, 62, 80);">中</font>**<font style="color:rgb(44, 62, 80);">，思路很简单，我们着手实现。</font>

<font style="color:rgb(44, 62, 80);">回顾一下我们的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mount</font><font style="color:rgb(44, 62, 80);"> 函数，如下高亮代码所示：</font>

```javascript
function mount(vnode, container, isSVG) {
  const { flags } = vnode
  if (flags & VNodeFlags.ELEMENT) {
    // 挂载普通标签
    mountElement(vnode, container, isSVG)
  } else if (flags & VNodeFlags.COMPONENT) {
    // 挂载组件
    mountComponent(vnode, container, isSVG)
  } else if (flags & VNodeFlags.TEXT) {
    // 挂载纯文本
    mountText(vnode, container)
  } else if (flags & VNodeFlags.FRAGMENT) {
    // 挂载 Fragment
    mountFragment(vnode, container, isSVG)
  } else if (flags & VNodeFlags.PORTAL) {
    // 挂载 Portal
    mountPortal(vnode, container, isSVG)
  }
}
```

<font style="color:rgb(44, 62, 80);">当</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">flags</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的值属于组件时(</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeFlags.COMPONENT</font><font style="color:rgb(44, 62, 80);">)，则会调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountComponent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数挂载该</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);">，但是组件还分为有状态组件和函数式组件，所以在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountComponent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数内部，我们需要再次对组件的类型进行区分，并使用不同的挂载方式，如下是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountComponent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数的实现：</font>

```javascript
function mountComponent(vnode, container, isSVG) {
  if (vnode.flags & VNodeFlags.COMPONENT_STATEFUL) {
    mountStatefulComponent(vnode, container, isSVG)
  } else {
    mountFunctionalComponent(vnode, container, isSVG)
  }
}
```

<font style="color:rgb(44, 62, 80);">道理很简单，我们通过检查</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vnode.flags</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">判断要挂载的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是否属于有状态组件(即</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNodeFlags.COMPONENT_STATEFUL</font><font style="color:rgb(44, 62, 80);">)，如果该</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">描述的是有状态组件则调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountStatefulComponent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数挂载，否则将该</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">当作函数式组件的描述，使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountFunctionalComponent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">挂载。</font>

<font style="color:rgb(44, 62, 80);">挂载一个有状态组件只需要四步，如下是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountStatefulComponent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数的实现：</font>

```javascript
function mountStatefulComponent(vnode, container, isSVG) {
  // 创建组件实例
  const instance = new vnode.tag()
  // 渲染VNode
  instance.$vnode = instance.render()
  // 挂载
  mount(instance.$vnode, container, isSVG)
  // el 属性值 和 组件实例的 $el 属性都引用组件的根DOM元素
  instance.$el = vnode.el = instance.$vnode.el
}
```

+ <font style="color:rgb(44, 62, 80);">第一步：创建组件实例</font>

<font style="color:rgb(44, 62, 80);">如果一个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">描述的是有状态组件，那么</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vnode.tag</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性值就是组件类的引用，所以通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">new</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">关键字创建组件实例。</font>

+ <font style="color:rgb(44, 62, 80);">第二步：获取组件产出的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font>

<font style="color:rgb(44, 62, 80);">一个组件的核心就是其</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">render</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数，通过调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">render</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数可以拿到该组件要渲染的内容。</font>

+ <font style="color:rgb(44, 62, 80);">第三步：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mount</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">挂载</font>

<font style="color:rgb(44, 62, 80);">既然已经拿到了</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);">，那么就将其挂载到</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">container</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">上就可以了。</font>

+ <font style="color:rgb(44, 62, 80);">第四步：让组件实例的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">$el</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vnode.el</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性的值引用组件的根DOM元素</font>

<font style="color:rgb(44, 62, 80);">组件的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">render</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数会返回该组件产出的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);">，当该</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">被挂载为真实DOM之后，就可以通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">instance.$vnode.el</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">元素拿到组件的根DOM元素，接着我们就可以让组件实例的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">$el</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vnode.el</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性的值都引用该DOM元素。如果组件的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">render</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">返回的是一个片段(</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Fragment</font><font style="color:rgb(44, 62, 80);">)，那么</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">instance.$el</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vnode.el</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">引用的就是该片段的第一个DOM元素。</font>

<font style="color:rgb(44, 62, 80);">我们来测试一下我们的代码，假设我们要渲染的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">如下：</font>

```javascript
// h 函数的第一个参数是组件类
const compVnode = h(MyComponent)
render(compVnode, document.getElementById('app'))
```

<font style="color:rgb(44, 62, 80);">如下是组件</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">MyComponent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">组件的实现：</font>

```javascript
class MyComponent {
  render() {
    return h(
      'div',
      {
        style: {
          background: 'green'
        }
      },
      [
        h('span', null, '我是组件的标题1......'),
        h('span', null, '我是组件的标题2......')
      ]
    )
  }
}
```

<font style="color:rgb(44, 62, 80);">该组件的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">render</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数返回了它要渲染的内容，如下是使用渲染器渲染后的效果：</font>


**<font style="color:rgb(44, 62, 80);">TIP</font>**

<font style="color:rgb(44, 62, 80);">完整代码&在线体验地址：</font>[https://codesandbox.io/s/2on8xyk01y(opens new window)](https://codesandbox.io/s/2on8xyk01y)

<br/>

<font style="color:rgb(44, 62, 80);">这里再次强调一下，这就是</font>**<font style="color:rgb(44, 62, 80);">有状态组件的挂载原理</font>**<font style="color:rgb(44, 62, 80);">，仅此而已。有的同学可能会产生疑惑，比如这里没有体现生命周期呀，也没有体现</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">data</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">props</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ref</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">或者</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">slots</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">等等，实际上我们早在“组件的本质”一章中就提到过</font>**<font style="color:rgb(44, 62, 80);">这些内容是在基本原理的基础上，再次设计的产物，它们为</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">render</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(44, 62, 80);">函数生成</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(44, 62, 80);">的过程中提供数据来源服务</font>**<font style="color:rgb(44, 62, 80);">，而</font>**<font style="color:rgb(44, 62, 80);">组件产出</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(44, 62, 80);">才是永恒的核心</font>**<font style="color:rgb(44, 62, 80);">，所以本节我们重在讲解原理，至于</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">data</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">props</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ref</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">等内容属于组件实例的设计，我们会在后续的章节中统一讲解。</font>

## [](https://www.123fe.net/principle-docs/vue/07-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8C%82%E8%BD%BD%E5%92%8C%E5%8E%9F%E7%90%86)函数式组件的挂载和原理
<font style="color:rgb(44, 62, 80);">函数式组件就更加简单了，它就是一个返回</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的函数：</font>

```javascript
function MyFunctionalComponent() {
  // 返回要渲染的内容描述，即 VNode
  return h(
    'div',
    {
      style: {
        background: 'green'
      }
    },
    [
      h('span', null, '我是组件的标题1......'),
      h('span', null, '我是组件的标题2......')
    ]
  )
}
```

<font style="color:rgb(44, 62, 80);">在挂载函数式组件的时候，比挂载有状态组件少了一个实例化的过程，如果一个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">描述的是函数式组件，那么其</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">tag</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性值就是该函数的引用，如下：</font>

<font style="color:rgb(44, 62, 80);">如下是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountFunctionalComponent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数的实现：</font>

```javascript
function mountFunctionalComponent(vnode, container, isSVG) {
  // 获取 VNode
  const $vnode = vnode.tag()
  // 挂载
  mount($vnode, container, isSVG)
  // el 元素引用该组件的根元素
  vnode.el = $vnode.el
}
```

<font style="color:rgb(44, 62, 80);">我们来测试一下我们的代码：</font>

```javascript
const compVnode = h(MyFunctionalComponent)
render(compVnode, document.getElementById('app'))
```

<font style="color:rgb(44, 62, 80);">最终的渲染效果如下：</font>


**<font style="color:rgb(44, 62, 80);">TIP</font>**

<font style="color:rgb(44, 62, 80);">完整代码&在线体验地址：</font>[https://codesandbox.io/s/02nrpqkvv(opens new window)](https://codesandbox.io/s/02nrpqkvv)

<br/>

<font style="color:rgb(44, 62, 80);">实际上如果对于 </font>**<font style="color:rgb(44, 62, 80);">有状态组件</font>**<font style="color:rgb(44, 62, 80);"> 和 </font>**<font style="color:rgb(44, 62, 80);">函数式组件</font>**<font style="color:rgb(44, 62, 80);"> 具体的区别不太了解的同学看到这里或许会产生疑问，觉得 </font>**<font style="color:rgb(44, 62, 80);">有状态组件</font>**<font style="color:rgb(44, 62, 80);"> 的实例化很多余，实际上实例化是必须的，因为 </font>**<font style="color:rgb(44, 62, 80);">有状态组件</font>**<font style="color:rgb(44, 62, 80);"> 在实例化的过程中会初始化一系列 </font>**<font style="color:rgb(44, 62, 80);">有状态组件</font>**<font style="color:rgb(44, 62, 80);"> 所特有的东西，诸如 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">data(或state)</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">computed</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">watch</font><font style="color:rgb(44, 62, 80);">、生命周期等等。而函数式组件只有 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">props</font><font style="color:rgb(44, 62, 80);"> 和 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">slots</font><font style="color:rgb(44, 62, 80);">，它要做的工作很少，所以性能上会更好。具体的关于本地数据、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">props</font><font style="color:rgb(44, 62, 80);"> 数据，计算属性，插槽等的设计和实现，我们在后面的章节中统一讲解，这里给大家展示的就是最根本的原理。</font>

