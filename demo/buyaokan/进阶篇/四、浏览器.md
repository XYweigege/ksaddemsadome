![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781723604-aa74fe11-d22d-4ad0-8f8e-cfa89bc2e0ca.png)

### <font style="color:rgb(44, 62, 80);">1 浏览器架构</font>
**<font style="color:rgb(44, 62, 80);">单进程浏览器时代</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。其实早在2007年之前，市面上浏览器都是单进程的</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781586131-3cd9cedb-ed82-4ba8-bf51-ebe9df32d135.png)

+ <font style="color:rgb(44, 62, 80);">缺点</font>
    - <font style="color:rgb(44, 62, 80);">不稳定：一个插件的意外崩溃会引起整个浏览器的崩溃</font>
    - <font style="color:rgb(44, 62, 80);">不流畅：所有页面的渲染模块、JavaScript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行</font>
    - <font style="color:rgb(44, 62, 80);">不安全：可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题</font>
+ <font style="color:rgb(44, 62, 80);">以上这些就是当时浏览器的特点，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">不稳定，不流畅，而且不安全</font>

**<font style="color:rgb(44, 62, 80);">多进程浏览器时代</font>**

+ <font style="color:rgb(44, 62, 80);">由于</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">进程是相互隔离的</font><font style="color:rgb(44, 62, 80);">，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题</font>
+ <font style="color:rgb(44, 62, 80);">JavaScript也是运行在渲染进程中的，所以即使JavaScript阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的</font>
+ <font style="color:rgb(44, 62, 80);">Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781584884-6c96d386-902e-437c-bc32-e11ad8a7dc8d.png)

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">最新的Chrome浏览器包括：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">1个浏览器（Browser）主进程</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">1个 GPU 进程</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">1个网络（NetWork）进程</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">多个渲染进程</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">多个插件进程</font>

+ **<font style="color:rgb(44, 62, 80);">浏览器进程</font>**<font style="color:rgb(44, 62, 80);">。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</font>
+ **<font style="color:rgb(44, 62, 80);">渲染进程</font>**<font style="color:rgb(44, 62, 80);">。核心任务是将</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML、CSS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">和 JavaScript 转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</font>
+ **<font style="color:rgb(44, 62, 80);">GPU进程</font>**<font style="color:rgb(44, 62, 80);">。其实，Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引入了GPU进程。</font>
+ **<font style="color:rgb(44, 62, 80);">网络进程</font>**<font style="color:rgb(44, 62, 80);">。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</font>
+ **<font style="color:rgb(44, 62, 80);">插件进程</font>**<font style="color:rgb(44, 62, 80);">。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响</font>

### [](https://www.123fe.net/docs/base/improve.html#_2-javascript%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B)<font style="color:rgb(44, 62, 80);">2 JavaScript单线程模型</font>
<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">JavaScript语言的一大特点就是单线程，也就是说，同一时间只能做一件事，前面的任务没做完，后面的任务只能等着。</font>

**<font style="color:rgb(44, 62, 80);">1. 为什么JavaScript是单线程的呢?</font>**

+ <font style="color:rgb(44, 62, 80);">这主要与JavaScript用途有关。它的主要用途是与用户互动，以及操作DOM。如果JavaScript是多线程的，会带来很多复杂的问题，假如 JavaScript有A和B两个线程，A线程在DOM节点上添加了内容，B线程删除了这个节点，应该是哪个为准呢? 所以，为了避免复杂性，所以设计成了单线程。</font>
+ <font style="color:rgb(44, 62, 80);">虽然 HTML5 提出了Web Worker标准。Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。但是子线程完全受主线程控制，且不得操作DOM。所以这个并没有改变JavaScript单线程的本质。一般使用 Web Worker 的场景是代码中有很多计算密集型或高延迟的任务，可以考虑分配给 Worker 线程。</font>
+ <font style="color:rgb(44, 62, 80);">但是使用的时候一定要注意，worker 线程是为了让你的程序跑的更快，但是如果 worker 线程和主线程之间通信的时间大于了你不使用worker线程的时间，结果就得不偿失了。</font>

**<font style="color:rgb(44, 62, 80);">2. 浏览器内核中线程之间的关系</font>**

+ <font style="color:rgb(44, 62, 80);">GUI渲染线程和JS引擎线程互斥</font>
    - <font style="color:rgb(44, 62, 80);">js是可以操作DOM的，如果在修改这些元素的同时渲染页面（js线程和ui线程同时运行），那么渲染线程前后获得的元素数据可能就不一致了。</font>
+ <font style="color:rgb(44, 62, 80);">JS阻塞页面加载</font>
    - <font style="color:rgb(44, 62, 80);">js如果执行时间过长就会阻塞页面</font>

**<font style="color:rgb(44, 62, 80);">3. 浏览器是多进程的优点</font>**

+ <font style="color:rgb(44, 62, 80);">默认新开 一个 tab 页面 新建 一个进程,所以单个 tab 页面崩溃不会影响到整个浏览器。</font>
+ <font style="color:rgb(44, 62, 80);">第三方插件崩溃也不会影响到整个浏览器。</font>
+ <font style="color:rgb(44, 62, 80);">多进程可以充分利用现代 CPU 多核的优势。</font>
+ <font style="color:rgb(44, 62, 80);">方便使用沙盒模型隔离插件等进程,提高浏览器的稳定性。</font>

**<font style="color:rgb(44, 62, 80);">4. 进程和线程又是什么呢</font>**

<font style="color:rgb(44, 62, 80);">进程（process）和线程（thread）是操作系统的基本概念。</font>

+ <font style="color:rgb(44, 62, 80);">进程是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）。</font>
+ <font style="color:rgb(44, 62, 80);">线程是 CPU 调度的最小单位（是建立在进程基础上的一次程序运行单位）。</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">由于每个进程至少要做一件事,所以一个进程至少有一个线程。系统会给每个进程分配独立的内存,因此进程有它独立的资源。同一进程内的各个线程之间共享该进程的内存空间（包括代码段,数据集,堆等）。</font>

<font style="color:rgb(44, 62, 80);">进程可以理解为一个工厂不不同车间，相互独立。线程是车间里的工人，可以自己做自己的事情,也可以相互配合做同一件事情。</font>

**<font style="color:rgb(44, 62, 80);">5. 任务队列</font>**

+ <font style="color:rgb(44, 62, 80);">单线程就意味着，所有任务都要排队执行，前一个任务结束，才会执行后一个任务。</font>
+ <font style="color:rgb(44, 62, 80);">如果一个任务需要执行，但此时JavaScript引擎正在执行其他任务，那么这个任务就需要放到一个队列中进行等待。等到线程空闲时，就可以从这个队列中取出最早加入的任务进行执行（类似于我们去银行排队办理业务，单线程相当于说这家银行只有一个服务窗口，一次只能为一个人服务，后面到的就需要排队，而任务队列就是排队区，先到的就优先服务）</font>

**<font style="color:rgb(44, 62, 80);">注意：</font>**<font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">如果当前线程空闲，并且队列为空，那每次加入队列的函数将立即执行。</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">为什么会有任务队列？ 由于 JS 是单线程的，同步执行任务会造成浏览器的阻塞，所以我们将 JS 分成一个又一个的任务，通过不停的循环来执行事件队列中的任务。</font>

### [](https://www.123fe.net/docs/base/improve.html#_3-chrome-%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E9%9C%80%E8%A6%81%E5%90%AF%E5%8A%A8%E5%A4%9A%E5%B0%91%E8%BF%9B%E7%A8%8B-%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%E8%BF%9B%E7%A8%8B)<font style="color:rgb(44, 62, 80);">3 Chrome 打开一个页面需要启动多少进程？分别有哪些进程？</font>
<font style="color:rgb(44, 62, 80);">打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。</font>

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">浏览器进程</font><font style="color:rgb(44, 62, 80);">：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">渲染进程</font><font style="color:rgb(44, 62, 80);">：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">GPU 进程</font><font style="color:rgb(44, 62, 80);">：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">网络进程</font><font style="color:rgb(44, 62, 80);">：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">插件进程</font><font style="color:rgb(44, 62, 80);">：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</font>

### [](https://www.123fe.net/docs/base/improve.html#_4-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6)<font style="color:rgb(44, 62, 80);">4 渲染机制</font>
**<font style="color:rgb(44, 62, 80);">1. 浏览器如何渲染网页</font>**

**<font style="color:rgb(44, 62, 80);">概述：浏览器渲染一共有五步</font>**

1. <font style="color:rgb(44, 62, 80);">处理</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">并构建</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">树。</font>
2. <font style="color:rgb(44, 62, 80);">处理</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSS</font><font style="color:rgb(44, 62, 80);">构建</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSSOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">树。</font>
3. <font style="color:rgb(44, 62, 80);">将</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">与</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSSOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">合并成一个渲染树。</font>
4. <font style="color:rgb(44, 62, 80);">根据渲染树来布局，计算每个节点的位置。</font>
5. <font style="color:rgb(44, 62, 80);">调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">GPU</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">绘制，合成图层，显示在屏幕上</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染</font>

<font style="color:rgb(44, 62, 80);">具体如下图过程如下图所示</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781584636-5e807875-9803-44c8-8602-a20ae3a371bc.png)

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781586623-94ed47ea-0f10-4ec5-a118-12249b895b34.png)

**<font style="color:rgb(44, 62, 80);">渲染</font>**

+ <font style="color:rgb(44, 62, 80);">网页生成的时候，至少会渲染一次</font>
+ <font style="color:rgb(44, 62, 80);">在用户访问的过程中，还会不断重新渲染</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">重新渲染需要重复之前的第四步(重新生成布局)+第五步(重新绘制)或者只有第五个步(重新绘制)</font>

+ <font style="color:rgb(44, 62, 80);">在构建</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSSOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">树时，会阻塞渲染，直至</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSSOM</font><font style="color:rgb(44, 62, 80);">树构建完成。并且构建</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSSOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">选择器，执行速度越慢</font>
+ <font style="color:rgb(44, 62, 80);">当</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">解析到</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">script</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">标签时，会暂停构建</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">文件。并且</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSS</font><font style="color:rgb(44, 62, 80);">也会影响</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的执行，只有当解析完样式表才会执行</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">，所以也可以认为这种情况下，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">也会暂停构建</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font>

**<font style="color:rgb(44, 62, 80);">2. 浏览器渲染五个阶段</font>**

**<font style="color:rgb(44, 62, 80);">2.1 第一步：解析HTML标签，构建DOM树</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">在这个阶段，引擎开始解析</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">html</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">，解析出来的结果会成为一棵</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">dom</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">树</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">dom</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的目的至少有</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">2</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">个</font>

+ <font style="color:rgb(44, 62, 80);">作为下个阶段渲染树状图的输入</font>
+ <font style="color:rgb(44, 62, 80);">成为网页和脚本的交互界面。(最常用的就是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">getElementById</font><font style="color:rgb(44, 62, 80);">等等)</font>

**<font style="color:rgb(44, 62, 80);">当解析器到达script标签的时候，发生下面四件事情</font>**

1. <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">html</font><font style="color:rgb(44, 62, 80);">解析器停止解析,</font>
2. <font style="color:rgb(44, 62, 80);">如果是外部脚本，就从外部网络获取脚本代码</font>
3. <font style="color:rgb(44, 62, 80);">将控制权交给</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">js</font><font style="color:rgb(44, 62, 80);">引擎，执行</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">js</font><font style="color:rgb(44, 62, 80);">代码</font>
4. <font style="color:rgb(44, 62, 80);">恢复</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">html</font><font style="color:rgb(44, 62, 80);">解析器的控制权</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">由此可以得到第一个结论1</font>

+ <font style="color:rgb(44, 62, 80);">由于</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><script></font><font style="color:rgb(44, 62, 80);">标签是阻塞解析的，将脚本放在网页尾部会加速代码渲染。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">defer</font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">async</font><font style="color:rgb(44, 62, 80);">属性也能有助于加载外部脚本。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">defer</font><font style="color:rgb(44, 62, 80);">使得脚本会在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">dom</font><font style="color:rgb(44, 62, 80);">完整构建之后执行；</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">async</font><font style="color:rgb(44, 62, 80);">标签使得脚本只有在完全</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">available</font><font style="color:rgb(44, 62, 80);">才执行，并且是以非阻塞的方式进行的</font>

**<font style="color:rgb(44, 62, 80);">2.2 第二步：解析CSS标签，构建CSSOM树</font>**

+ <font style="color:rgb(44, 62, 80);">我们已经看到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">html</font><font style="color:rgb(44, 62, 80);">解析器碰到脚本后会做的事情，接下来我们看下</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">html</font><font style="color:rgb(44, 62, 80);">解析器碰到样式表会发生的情况</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">js</font><font style="color:rgb(44, 62, 80);">会阻塞解析，因为它会修改文档(</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">document</font><font style="color:rgb(44, 62, 80);">)。</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">css</font><font style="color:rgb(44, 62, 80);">不会修改文档的结构，如果这样的话，似乎看起来</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">css</font><font style="color:rgb(44, 62, 80);">样式不会阻塞浏览器</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">html</font><font style="color:rgb(44, 62, 80);">解析。但是事实上</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">css</font><font style="color:rgb(44, 62, 80);">样式表是阻塞的。阻塞是指当</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">cssom</font><font style="color:rgb(44, 62, 80);">树建立好之后才会进行下一步的解析渲染</font>

**<font style="color:rgb(44, 62, 80);">通过以下手段可以减轻cssom带来的影响</font>**

+ <font style="color:rgb(44, 62, 80);">将</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">script</font><font style="color:rgb(44, 62, 80);">脚本放在页面底部</font>
+ <font style="color:rgb(44, 62, 80);">尽可能快的加载</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">css</font><font style="color:rgb(44, 62, 80);">样式表</font>
+ <font style="color:rgb(44, 62, 80);">将样式表按照</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">media type</font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">media query</font><font style="color:rgb(44, 62, 80);">区分，这样有助于我们将</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">css</font><font style="color:rgb(44, 62, 80);">资源标记成非阻塞渲染的资源。</font>
+ <font style="color:rgb(44, 62, 80);">非阻塞的资源还是会被浏览器下载，只是优先级较低</font>

**<font style="color:rgb(44, 62, 80);">2.3 第三步：把DOM和CSSOM组合成渲染树（render tree）</font>**

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781589729-94ec84c9-8757-493e-8628-2719fb70155a.png)

**<font style="color:rgb(44, 62, 80);">2.4 第四步：在渲染树的基础上进行布局，计算每个节点的几何结构</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">布局(</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">layout</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">)：定位坐标和大小，是否换行，各种</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">position</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">,</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">overflow</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">,</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">z-index</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">属性</font>

**<font style="color:rgb(44, 62, 80);">2.5 调用 GPU 绘制，合成图层，显示在屏幕上</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">将渲染树的各个节点绘制到屏幕上，这一步被称为绘制</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">painting</font>

**<font style="color:rgb(44, 62, 80);">3. 渲染优化相关</font>**

**<font style="color:rgb(44, 62, 80);">3.1 Load 和 DOMContentLoaded 区别</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Load</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">事件触发代表页面中的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSS</font><font style="color:rgb(44, 62, 80);">，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">，图片已经全部加载完毕。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOMContentLoaded</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">事件触发代表初始的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">被完全加载和解析，不需要等待</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSS</font><font style="color:rgb(44, 62, 80);">，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">，图片加载</font>

**<font style="color:rgb(44, 62, 80);">3.2 图层</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。</font>

**<font style="color:rgb(44, 62, 80);">通过以下几个常用属性可以生成新图层</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">3D</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">变换：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">translate3d</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">translateZ</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">will-change</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">video</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">标签</font>
+ <font style="color:rgb(44, 62, 80);">通过动画实现的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">opacity</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">动画转换</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">position: fixed</font>

**<font style="color:rgb(44, 62, 80);">3.3 重绘（Repaint）和回流（Reflow）</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大</font>

+ <font style="color:rgb(44, 62, 80);">重绘是当节点需要更改外观而不会影响布局的，比如改变</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">color</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">就叫称为重绘</font>
+ <font style="color:rgb(44, 62, 80);">回流是布局或者几何属性需要改变就称为回流。</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流</font>

**<font style="color:rgb(44, 62, 80);">以下几个动作可能会导致性能问题</font>**

+ <font style="color:rgb(44, 62, 80);">改变</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">window</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">大小</font>
+ <font style="color:rgb(44, 62, 80);">改变字体</font>
+ <font style="color:rgb(44, 62, 80);">添加或删除样式</font>
+ <font style="color:rgb(44, 62, 80);">文字改变</font>
+ <font style="color:rgb(44, 62, 80);">定位或者浮动</font>
+ <font style="color:rgb(44, 62, 80);">盒模型</font>

**<font style="color:rgb(44, 62, 80);">很多人不知道的是，重绘和回流其实和 Event loop 有关</font>**

+ <font style="color:rgb(44, 62, 80);">当</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Event loop</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">执行完</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Microtasks</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">后，会判断</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">document</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是否需要更新。因为浏览器是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">60Hz</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的刷新率，每</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">16ms</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">才会更新一次。</font>
+ <font style="color:rgb(44, 62, 80);">然后判断是否有</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">resize</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">或者</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">scroll</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">，有的话会去触发事件，所以</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">resize</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">scroll</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">事件也是至少</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">16ms</font><font style="color:rgb(44, 62, 80);">才会触发一次，并且自带节流功能。</font>
+ <font style="color:rgb(44, 62, 80);">判断是否触发了</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">media query</font>
+ <font style="color:rgb(44, 62, 80);">更新动画并且发送事件</font>
+ <font style="color:rgb(44, 62, 80);">判断是否有全屏操作事件</font>
+ <font style="color:rgb(44, 62, 80);">执行</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestAnimationFrame</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">回调</font>
+ <font style="color:rgb(44, 62, 80);">执行</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">IntersectionObserver</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</font>
+ <font style="color:rgb(44, 62, 80);">更新界面</font>
+ <font style="color:rgb(44, 62, 80);">以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestIdleCallback</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">回调</font>

**<font style="color:rgb(44, 62, 80);">常见的引起重绘的属性</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">color</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">border-style</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">visibility</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">background</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">text-decoration</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">background-image</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">background-position</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">background-repeat</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">outline-color</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">outline</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">outline-style</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">border-radius</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">outline-width</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">box-shadow</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">background-size</font>

**<font style="color:rgb(44, 62, 80);">3.4 常见引起回流属性和方法</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发重排，下面列一些栗子</font>

+ <font style="color:rgb(44, 62, 80);">添加或者删除可见的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">元素；</font>
+ <font style="color:rgb(44, 62, 80);">元素尺寸改变——边距、填充、边框、宽度和高度</font>
+ <font style="color:rgb(44, 62, 80);">内容变化，比如用户在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">input</font><font style="color:rgb(44, 62, 80);">框中输入文字</font>
+ <font style="color:rgb(44, 62, 80);">浏览器窗口尺寸改变——</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">resize</font><font style="color:rgb(44, 62, 80);">事件发生时</font>
+ <font style="color:rgb(44, 62, 80);">计算</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">offsetWidth</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">offsetHeight</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性</font>
+ <font style="color:rgb(44, 62, 80);">设置</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">style</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性的值</font>

**<font style="color:rgb(44, 62, 80);">回流影响的范围</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种</font>

+ <font style="color:rgb(44, 62, 80);">全局范围：从根节点</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">html</font><font style="color:rgb(44, 62, 80);">开始对整个渲染树进行重新布局。</font>
+ <font style="color:rgb(44, 62, 80);">局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</font>

**<font style="color:rgb(44, 62, 80);">全局范围回流</font>**

```html
<body>
  <div class="hello">
    <h4>hello</h4>
    <p><strong>Name:</strong>BDing</p>
    <h5>male</h5>
    <ol>
      <li>coding</li>
      <li>loving</li>
    </ol>
  </div>
</body>
```

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">当</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">p</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">节点上发生</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">reflow</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">时，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">hello</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">body</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">也会重新渲染，甚至</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">h5</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ol</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">都会收到影响</font>

**<font style="color:rgb(44, 62, 80);">局部范围回流</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">用局部布局来解释这种现象：把一个</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">dom</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的宽高之类的几何信息定死，然后在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">dom</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">内部触发重排，就只会重新渲染该</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">dom</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">内部的元素，而不会影响到外界</font>

**<font style="color:rgb(44, 62, 80);">3.5 减少重绘和回流</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">使用</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">translate</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">替代</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">top</font>

```html
<div class="test"></div>
<style>
  .test {
    position: absolute;
    top: 10px;
    width: 100px;
    height: 100px;
    background: red;
  }
</style>
<script>
  setTimeout(() => {
    // 引起回流
    document.querySelector('.test').style.top = '100px'
  }, 1000)
</script>
```

+ <font style="color:rgb(44, 62, 80);">使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">visibility</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">替换</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">display: none</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">，因为前者只会引起重绘，后者会引发回流（改变了布局）</font>
+ <font style="color:rgb(44, 62, 80);">把</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">离线后修改，比如：先把</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">给</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">display:none</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">(有一次</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Reflow)</font><font style="color:rgb(44, 62, 80);">，然后你修改</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">100</font><font style="color:rgb(44, 62, 80);">次，然后再把它显示出来</font>
+ <font style="color:rgb(44, 62, 80);">不要把</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">结点的属性值放在一个循环里当成循环里的变量</font>

```javascript
for(let i = 0; i < 1000; i++) {
  // 获取 offsetTop 会导致回流，因为需要去获取正确的值
  console.log(document.querySelector('.test').style.offsetTop)
}
```

+ <font style="color:rgb(44, 62, 80);">不要使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">table</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">布局，可能很小的一个小改动会造成整个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">table</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的重新布局</font>
+ <font style="color:rgb(44, 62, 80);">动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestAnimationFrame</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSS</font><font style="color:rgb(44, 62, 80);">选择符从右往左匹配查找，避免</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">深度过深</font>
+ <font style="color:rgb(44, 62, 80);">将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">video</font><font style="color:rgb(44, 62, 80);">标签，浏览器会自动将该节点变为图层。</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781594826-5847f99c-7469-4e04-8c16-cc0acc1df55c.png)

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781595136-c905b5c1-4960-438f-942f-761007f98561.png)

### [](https://www.123fe.net/docs/base/improve.html#_5-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6)<font style="color:rgb(44, 62, 80);">5 缓存机制</font>
**<font style="color:rgb(44, 62, 80);">1. 首先得明确 http 缓存的好处</font>**

+ <font style="color:rgb(44, 62, 80);">减少了冗余的数据传输，减少网费</font>
+ <font style="color:rgb(44, 62, 80);">减少服务器端的压力</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Web</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间</font>
+ <font style="color:rgb(44, 62, 80);">加快客户端加载网页的速度</font>

**<font style="color:rgb(44, 62, 80);">2. 常见 http 缓存的类型</font>**

+ <font style="color:rgb(44, 62, 80);">私有缓存（一般为本地浏览器缓存）</font>
+ <font style="color:rgb(44, 62, 80);">代理缓存</font>

**<font style="color:rgb(44, 62, 80);">3. 然后谈谈本地缓存</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">本地缓存是指浏览器请求资源时命中了浏览器本地的缓存资源，浏览器并不会发送真正的请求给服务器了。它的执行过程是</font>

+ <font style="color:rgb(44, 62, 80);">第一次浏览器发送请求给服务器时，此时浏览器还没有本地缓存副本，服务器返回资源给浏览器，响应码是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">200 OK</font><font style="color:rgb(44, 62, 80);">，浏览器收到资源后，把资源和对应的响应头一起缓存下来</font>
+ <font style="color:rgb(44, 62, 80);">第二次浏览器准备发送请求给服务器时候，浏览器会先检查上一次服务端返回的响应头信息中的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cache-Control</font><font style="color:rgb(44, 62, 80);">，它的值是一个相对值，单位为秒，表示资源在客户端缓存的最大有效期，过期时间为第一次请求的时间减去</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cache-Control</font><font style="color:rgb(44, 62, 80);">的值，过期时间跟当前的请求时间比较，如果本地缓存资源没过期，那么命中缓存，不再请求服务器</font>
+ <font style="color:rgb(44, 62, 80);">如果没有命中，浏览器就会把请求发送给服务器，进入缓存协商阶段。</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">与本地缓存相关的头有：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cache-Control</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Expires</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cache-Control</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">有多个可选值代表不同的意义，而</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Expires</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">就是一个日期格式的绝对值。</font>

**<font style="color:rgb(44, 62, 80);">3.1 Cache-Control</font>**

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cache-Control</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTPP</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">缓存策略中最重要的头，它是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP/1.1</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">中出现的，它由如下几个值</font>

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">no-cache</font><font style="color:rgb(44, 62, 80);">：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ETag</font><font style="color:rgb(44, 62, 80);">，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">no-store</font><font style="color:rgb(44, 62, 80);">：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">public</font><font style="color:rgb(44, 62, 80);">：可以被所有的用户缓存，包括终端用户和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CDN</font><font style="color:rgb(44, 62, 80);">等中间代理服务器。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">private</font><font style="color:rgb(44, 62, 80);">：只能被终端用户的浏览器缓存，不允许</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CDN</font><font style="color:rgb(44, 62, 80);">等中继缓存服务器对其缓存。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">max-age</font><font style="color:rgb(44, 62, 80);">：从当前请求开始，允许获取的响应被重用的最长时间（秒）。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">must-revalidate</font><font style="color:rgb(44, 62, 80);">，当缓存过期时，需要去服务端校验缓存的有效性。</font>

```bash
 例如：

Cache-Control: public, max-age=1000 
 表示资源可以被所有用户以及代理服务器缓存，最长时间为1000秒。
```

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">注意，虽然你可能在其他资料中看到可以使用 meta 标签来设置缓存，比如像下面的形式：</font>

```plain
<meta http-equiv="expires" content="Wed, 20 Jun 2021 22:33:00 GMT"
```

<font style="color:rgb(44, 62, 80);">但在 HTML5 规范中，并不支持这种方式，所以</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">尽量不要使用 meta 标签来设置缓存</font><font style="color:rgb(44, 62, 80);">。</font>

**<font style="color:rgb(44, 62, 80);">3.2 Expires</font>**

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Expires</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP/1.0</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">出现的头信息，同样是用于决定本地缓存策略的头，它是一个绝对时间，时间格式是如</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Mon, 10 Jun 2015 21:31:12 GMT</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">，只要发送请求时间是在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Expires</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">之前，那么本地缓存始终有效，否则就会去服务器发送请求获取新的资源。如果同时出现</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cache-Control：max-age</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Expires</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">，那么</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">max-age</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">优先级更高。他们可以这样组合使用</font>

```plain
Cache-Control: public
Expires: Wed, Jan 10 2018 00:27:04 GMT
```

**<font style="color:rgb(44, 62, 80);">3.3 所谓的缓存协商</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">当第一次请求时服务器返回的响应头中存在以下情况时</font>

+ <font style="color:rgb(44, 62, 80);">没有</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cache-Control</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Expires</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cache-Control</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Expires</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">过期了</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cache-Control</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的属性设置为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">no-cache</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">时</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">那么浏览器第二次请求时就会与服务器进行协商，询问浏览器中的缓存资源是不是旧版本，需不需要更新，此时，服务器就会做出判断，如果缓存和服务端资源的最新版本是一致的，那么就无需再次下载该资源，服务端直接返回</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">304 Not Modified</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">状态码，如果服务器发现浏览器中的缓存已经是旧版本了，那么服务器就会把最新资源的完整内容返回给浏览器，状态码就是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">200 Ok</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">，那么服务端是根据什么来判断浏览器的缓存是不是最新的呢？其实是根据</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的另外两组头信息，分别是：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Last-Modified/If-Modified-Since</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">与</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ETag/If-None-Match</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">。</font>

**<font style="color:rgb(44, 62, 80);">Last-Modified 与 If-Modified-Since</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">具体工作流程如下：</font>

+ <font style="color:rgb(44, 62, 80);">浏览器第一次请求资源时，服务器会把资源的最新修改时间</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Last-Modified:Thu, 29 Dec 2011 18:23:55 GMT</font><font style="color:rgb(44, 62, 80);">放在响应头中返回给浏览器</font>
+ <font style="color:rgb(44, 62, 80);">第二次请求时，浏览器就会把上一次服务器返回的修改时间放在请求头</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">If-Modified-Since:Thu, 29 Dec 2011 18:23:55</font><font style="color:rgb(44, 62, 80);">发送给服务器，服务器就会拿这个时间跟服务器上的资源的最新修改时间进行对比</font>
+ <font style="color:rgb(44, 62, 80);">服务端再次收到请求，根据请求头</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">If-Modified-Since</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的值，判断相关资源是否有变化，如果没有，则返回</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">304 Not Modified</font><font style="color:rgb(44, 62, 80);">，并且不返回资源内容，浏览器使用资源缓存值；否则正常返回资源内容，且更新</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Last-Modified</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">响应头内容。</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">如果两者相等或者大于服务器上的最新修改时间，那么表示浏览器的缓存是有效的，此时缓存会命中，服务器就不再返回内容给浏览器了，同时</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Last-Modified</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">头也不会返回，因为资源没被修改，返回了也没什么意义。如果没命中缓存则最新修改的资源连同</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Last-Modified</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">头一起返回</font>

**<font style="color:rgb(44, 62, 80);">这种方式虽然能判断缓存是否失效，但也存在两个问题：</font>**

+ **<font style="color:rgb(44, 62, 80);">精度问题</font>**<font style="color:rgb(44, 62, 80);">，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Last-Modified</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的时间精度为秒，如果在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">1</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">秒内发生修改，那么缓存判断可能会失效；</font>
+ **<font style="color:rgb(44, 62, 80);">准度问题</font>**<font style="color:rgb(44, 62, 80);">，考虑这样一种情况，如果一个文件被修改，然后又被还原，内容并没有发生变化，在这种情况下，浏览器的缓存还可以继续使用，但因为修改时间发生变化，也会重新返回重复的内容。</font>

```bash
 第一次请求返回的响应头
Cache-Control:max-age=3600
Expires: Fri, Jan 12 2018 00:27:04 GMT
Last-Modified: Wed, Jan 10 2018 00:27:04 GMT
```

```bash
 第二次请求的请求头信息
If-Modified-Since: Wed, Jan 10 2018 00:27:04 GMT
```

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">这组头信息是基于资源的修改时间来判断资源有没有更新，另一种方式就是根据资源的内容来判断，就是接下来要讨论的</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ETag</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">与</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">If-None-Match</font>

**<font style="color:rgb(44, 62, 80);">ETag与If-None-Match</font>**

<font style="color:rgb(44, 62, 80);">为了</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">解决精度问题和准度问题</font><font style="color:rgb(44, 62, 80);">，HTTP 提供了另一种不依赖于修改时间，而依赖于文件哈希值的精确判断缓存的方式，那就是响应头部字段 ETag 和请求头部字段 If-None-Match。</font>

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ETag/If-None-Match</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">与</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Last-Modified/If-Modified-Since</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的流程其实是类似的，唯一的区别是它基于资源的内容的摘要信息（比如</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">MD5 hash</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">）来判断</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">浏览器发送第二次请求时，会把第一次的响应头信息</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ETag</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的值放在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">If-None-Match</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的请求头中发送到服务器，与最新的资源的摘要信息对比，如果相等，取浏览器缓存，否则内容有更新，最新的资源连同最新的摘要信息返回。用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ETag</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的好处是如果因为某种原因到时资源的修改时间没改变，那么用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ETag</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">就能区分资源是不是有被更新。</font>

**<font style="color:rgb(44, 62, 80);">具体工作流程如下：</font>**

+ <font style="color:rgb(44, 62, 80);">浏览器第一次请求资源，服务端在返响应头中加入</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Etag</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">字段，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Etag</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">字段值为该资源的哈希值</font>
+ <font style="color:rgb(44, 62, 80);">当浏览器再次跟服务端请求这个资源时，在请求头上加上</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">If-None-Match</font><font style="color:rgb(44, 62, 80);">，值为之前响应头部字段</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ETag</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的值；</font>
+ <font style="color:rgb(44, 62, 80);">服务端再次收到请求，将请求头</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">If-None-Match</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">字段的值和响应资源的哈希值进行比对，如果两个值相同，则说明资源没有变化，返回</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">304 Not Modified</font><font style="color:rgb(44, 62, 80);">；否则就正常返回资源内容，无论是否发生变化，都会将计算出的哈希值放入响应头部的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ETag</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">字段中</font>

<font style="color:rgb(44, 62, 80);">这种缓存比较的方式也会存在一些问题，具体表现在以下两个方面。</font>

+ **<font style="color:rgb(44, 62, 80);">计算成本</font>**<font style="color:rgb(44, 62, 80);">。生成哈希值相对于读取文件修改时间而言是一个开销比较大的操作，尤其是对于大文件而言。如果要精确计算则需读取完整的文件内容，如果从性能方面考虑，只读取文件部分内容，又容易判断出错。</font>
+ **<font style="color:rgb(44, 62, 80);">计算误差</font>**<font style="color:rgb(44, 62, 80);">。HTTP 并没有规定哈希值的计算方法，所以不同服务端可能会采用不同的哈希值计算方式。这样带来的问题是，同一个资源，在两台服务端产生的 Etag 可能是不相同的，所以对于使用服务器集群来处理请求的网站来说，使用 Etag 的缓存命中率会有所降低。</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">需要注意的是，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">强制缓存的优先级高于协商缓存</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">，在协商缓存中，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Etag 优先级比 Last-Modified</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">高</font>

```bash
 第一次请求返回的响应头：

Cache-Control: public, max-age=31536000
ETag: "15f0fff99ed5aae4edffdd6496d7131f"
```

```bash
 第二次请求的请求头信息：

If-None-Match: "15f0fff99ed5aae4edffdd6496d7131f"
```

**<font style="color:rgb(44, 62, 80);">缓存位置</font>**

<font style="color:rgb(44, 62, 80);">浏览器缓存的位置的话，可以分为四种,优先级从高到低排列分别</font><font style="color:rgb(44, 62, 80);">👇</font>

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Service Worker</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Memory Cache</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Disk Cache</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Push Cache</font>

**<font style="color:rgb(44, 62, 80);">Service Worker</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">这个应用场景比如PWA，它借鉴了Web Worker思路，由于它脱离了浏览器的窗体，因此无法直接访问DOM。它能完成的功能比如：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">离线缓存</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">消息推送</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">网络代理</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">，其中</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">离线缓存</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">就是</font>**<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">Service Worker Cache</font>**<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">。</font>

**<font style="color:rgb(44, 62, 80);">Memory Cache</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">指的是内存缓存，从效率上讲它是最快的，从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。</font>

**<font style="color:rgb(44, 62, 80);">Disk Cache</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长。</font>

**<font style="color:rgb(44, 62, 80);">Disk Cache VS Memory Cache</font>**

<font style="color:rgb(44, 62, 80);">两者对比，主要的策略</font><font style="color:rgb(44, 62, 80);">👇</font>

+ <font style="color:rgb(44, 62, 80);">内容使用率高的话，文件优先进入磁盘</font>
+ <font style="color:rgb(44, 62, 80);">比较大的JS，CSS文件会直接放入磁盘，反之放入内存。</font>

**<font style="color:rgb(44, 62, 80);">Push Cache</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">推送缓存，这算是浏览器中最后一道防线吧，它是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP/2</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的内容</font>

**<font style="color:rgb(44, 62, 80);">浏览器缓存总结</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下</font>

+ <font style="color:rgb(44, 62, 80);">先根据这个资源的一些 http header 判断它是否命中强缓存，先检查</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cache-Control</font><font style="color:rgb(44, 62, 80);">，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；</font>
+ <font style="color:rgb(44, 62, 80);">当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是返回304告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；（服务器通过请求头中的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">If-Modified-Since</font><font style="color:rgb(44, 62, 80);">或者</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">If-None-Match</font><font style="color:rgb(44, 62, 80);">字段检查资源是否更新）</font>
+ <font style="color:rgb(44, 62, 80);">强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。</font>
+ <font style="color:rgb(44, 62, 80);">当协商缓存也没命中时，服务器就会将资源发送回客户端。</font>
+ <font style="color:rgb(44, 62, 80);">当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</font>
+ <font style="color:rgb(44, 62, 80);">当 f5刷新网页时，跳过强缓存，但是会检查协商缓存；</font>

**<font style="color:rgb(44, 62, 80);">强缓存</font>**

+ <font style="color:rgb(44, 62, 80);">Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）</font>
+ <font style="color:rgb(44, 62, 80);">Cache-Control:max-age（该字段是 http1.1的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒）</font>

**<font style="color:rgb(44, 62, 80);">协商缓</font>**

+ <font style="color:rgb(44, 62, 80);">Last-Modified（值为资源最后更新时间，随服务器response返回，即使文件改回去，日期也会变化）</font>
+ <font style="color:rgb(44, 62, 80);">If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）</font>
+ <font style="color:rgb(44, 62, 80);">ETag（表示资源内容的唯一标识，随服务器response返回，仅根据文件内容是否变化判断）</font>
+ <font style="color:rgb(44, 62, 80);">If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）</font>

### [](https://www.123fe.net/docs/base/improve.html#_6-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8)<font style="color:rgb(44, 62, 80);">6 浏览器存储</font>
<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">我们经常需要对业务中的一些数据进行存储，通常可以分为 短暂性存储 和 持久性储存。</font>

+ <font style="color:rgb(44, 62, 80);">短暂性的时候，我们只需要将数据存在内存中，只在运行时可用</font>
+ <font style="color:rgb(44, 62, 80);">持久性存储，可以分为 浏览器端 与 服务器端</font>
    - <font style="color:rgb(44, 62, 80);">浏览器:</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">cookie</font><font style="color:rgb(44, 62, 80);">: 通常用于存储用户身份，登录状态等</font>
            + <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">http</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中自动携带， 体积上限为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">4K</font><font style="color:rgb(44, 62, 80);">， 可自行设置过期时间</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">localStorage / sessionStorage</font><font style="color:rgb(44, 62, 80);">: 长久储存/窗口关闭删除， 体积限制为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">4~5M</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">indexDB</font>
    - <font style="color:rgb(44, 62, 80);">服务器:</font>
        * <font style="color:rgb(44, 62, 80);">分布式缓存</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">redis</font>
        * <font style="color:rgb(44, 62, 80);">数据库</font>

**<font style="color:rgb(44, 62, 80);">cookie和localSrorage、session、indexDB 的区别</font>**

| <font style="color:rgb(44, 62, 80);">特性</font> | <font style="color:rgb(44, 62, 80);">cookie</font> | <font style="color:rgb(44, 62, 80);">localStorage</font> | <font style="color:rgb(44, 62, 80);">sessionStorage</font> | <font style="color:rgb(44, 62, 80);">indexDB</font> |
| --- | --- | --- | --- | --- |
| <font style="color:rgb(44, 62, 80);">数据生命周期</font> | <font style="color:rgb(44, 62, 80);">一般由服务器生成，可以设置过期时间</font> | <font style="color:rgb(44, 62, 80);">除非被清理，否则一直存在</font> | <font style="color:rgb(44, 62, 80);">页面关闭就清理</font> | <font style="color:rgb(44, 62, 80);">除非被清理，否则一直存在</font> |
| <font style="color:rgb(44, 62, 80);">数据存储大小</font> | <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">4K</font> | <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">5M</font> | <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">5M</font> | <font style="color:rgb(44, 62, 80);">无限</font> |
| <font style="color:rgb(44, 62, 80);">与服务端通信</font> | <font style="color:rgb(44, 62, 80);">每次都会携带在 header 中，对于请求性能影响</font> | <font style="color:rgb(44, 62, 80);">不参与</font> | <font style="color:rgb(44, 62, 80);">不参与</font> | <font style="color:rgb(44, 62, 80);">不参与</font> |


<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">从上表可以看到，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">cookie</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">已经不建议用于存储。如果没有大量数据存储需求的话，可以使用</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">localStorage</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">和</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">sessionStorage</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">。对于不怎么改变的数据尽量使用</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">localStorage</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">存储，否则可以用</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">sessionStorage</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">存储。</font>

**<font style="color:rgb(44, 62, 80);">对于</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">cookie</font>****<font style="color:rgb(44, 62, 80);">，我们还需要注意安全性</font>**

| <font style="color:rgb(44, 62, 80);">属性</font> | <font style="color:rgb(44, 62, 80);">作用</font> |
| --- | --- |
| <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">value</font> | <font style="color:rgb(44, 62, 80);">如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</font> |
| <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">http-only</font> | <font style="color:rgb(44, 62, 80);">不能通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">访问</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);">，减少</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">XSS</font><font style="color:rgb(44, 62, 80);">攻击</font> |
| <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">secure</font> | <font style="color:rgb(44, 62, 80);">只能在协议为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTPS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的请求中携带</font> |
| <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">same-site</font> | <font style="color:rgb(44, 62, 80);">规定浏览器不能在跨域请求中携带</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);">，减少</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSRF</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">攻击</font> |


![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781594540-98578d36-627e-4591-ad77-9e40b0b07c1c.png)

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Name</font><font style="color:rgb(44, 62, 80);">，即该</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的名称。</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">一旦创建，名称便不可更改。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Value</font><font style="color:rgb(44, 62, 80);">，即该</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的值。如果值为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Unicode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">字符，需要为字符编码。如果值为二进制数据，则需要使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">BASE64</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">编码。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Max Age</font><font style="color:rgb(44, 62, 80);">，即该</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">失效的时间，单位秒，也常和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Expires</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">一起使用，通过它可以计算出其有效时间。</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Max Age</font><font style="color:rgb(44, 62, 80);">如果为正数，则该</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Max Age</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">秒之后失效。如果为负数，则关闭浏览器时</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">即失效，浏览器也不会以任何形式保存该</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);">。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Path</font><font style="color:rgb(44, 62, 80);">，即该</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的使用路径。如果设置为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">/path/</font><font style="color:rgb(44, 62, 80);">，则只有路径为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">/path/</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的页面可以访问该</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);">。如果设置为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">/</font><font style="color:rgb(44, 62, 80);">，则本域名下的所有页面都可以访问该</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);">。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Domain</font><font style="color:rgb(44, 62, 80);">，即可以访问该</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的域名。例如如果设置为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">.zhihu.com</font><font style="color:rgb(44, 62, 80);">，则所有以</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">zhihu.com</font><font style="color:rgb(44, 62, 80);">，结尾的域名都可以访问该</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);">。</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Size</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">字段，即此</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的大小。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Http</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">字段，即</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">httponly</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性。若此属性为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">true</font><font style="color:rgb(44, 62, 80);">，则只有在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP Headers</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中会带有此 Cookie 的信息，而不能通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">document.cookie</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">来访问此 Cookie。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Secure</font><font style="color:rgb(44, 62, 80);">，即该</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是否仅被使用安全协议传输。安全协议。安全协议有</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTPS、SSL</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">等，在网络上传输数据之前先将数据加密。默认为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">false</font><font style="color:rgb(44, 62, 80);">。</font>

### [](https://www.123fe.net/docs/base/improve.html#_7-%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88)<font style="color:rgb(44, 62, 80);">7 跨域方案</font>
<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">很多种方法，但万变不离其宗，都是为了搞定同源策略。重用的有</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">jsonp</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">cors</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">img</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML5 postMessage</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">等等。其中用到</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">html</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">标签进行跨域的原理就是</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">html</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">不受同源策略影响。但只是接受</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Get</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的请求方式，这个得清楚。</font>

**<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">延伸1：img iframe script 来发送跨域请求有什么优缺点？</font>**

**<font style="color:rgb(44, 62, 80);">1.</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font>**

+ <font style="color:rgb(44, 62, 80);">优点：跨域完毕之后</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">操作和互相之间的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JavaScript</font><font style="color:rgb(44, 62, 80);">调用都是没有问题的</font>
+ <font style="color:rgb(44, 62, 80);">缺点：1.若结果要以</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">URL</font><font style="color:rgb(44, 62, 80);">参数传递，这就意味着在结果数据量很大的时候需要分割传递，巨烦。2.还有一个是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font><font style="color:rgb(44, 62, 80);">本身带来的，母页面和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font><font style="color:rgb(44, 62, 80);">本身的交互本身就有安全性限制。</font>

**<font style="color:rgb(44, 62, 80);">2. script</font>**

+ <font style="color:rgb(44, 62, 80);">优点：可以直接返回</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">json</font><font style="color:rgb(44, 62, 80);">格式的数据，方便处理</font>
+ <font style="color:rgb(44, 62, 80);">缺点：只接受</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">GET</font><font style="color:rgb(44, 62, 80);">请求方式</font>

**<font style="color:rgb(44, 62, 80);">3. 图片ping</font>**

+ <font style="color:rgb(44, 62, 80);">优点：可以访问任何</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">url</font><font style="color:rgb(44, 62, 80);">，一般用来进行点击追踪，做页面分析常用的方法</font>
+ <font style="color:rgb(44, 62, 80);">缺点：不能访问响应文本，只能监听是否响应</font>

**<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">延伸2：配合 webpack 进行反向代理？</font>**

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">webpack</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">devServer</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">选项里面提供了一个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">proxy</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的参数供开发人员进行反向代理</font>

```plain
'/api': {
  target: 'http://www.example.com', // your target host
  changeOrigin: true, // needed for virtual hosted sites
  pathRewrite: {
    '^/api': ''  // rewrite path
  }
},
```

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">然后再配合</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">http-proxy-middleware</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">插件对</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">api</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">请求地址进行代理</font>

```plain
const express = require('express');
const proxy = require('http-proxy-middleware');
// proxy api requests
const exampleProxy = proxy(options); // 这里的 options 就是 webpack 里面的 proxy 选项对应的每个选项

// mount `exampleProxy` in web server
const app = express();
app.use('/api', exampleProxy);
app.listen(3000);
```

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">然后再用</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">nginx</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">把允许跨域的源地址添加到报头里面即可</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">说到</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">nginx</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">，可以再谈谈</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CORS</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">配置，大致如下</font>

```plain
location / {
  if ($request_method = 'OPTIONS') {
    add_header 'Access-Control-Allow-Origin' '*';  
    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; 
    add_header 'Access-Control-Allow-Credentials' 'true';
    add_header 'Access-Control-Allow-Headers' 'DNT, X-Mx-ReqToken, Keep-Alive, User-Agent, X-Requested-With, If-Modified-Since, Cache-Control, Content-Type';  
    add_header 'Access-Control-Max-Age' 86400;  
    add_header 'Content-Type' 'text/plain charset=UTF-8';  
    add_header 'Content-Length' 0;  
    return 200;  
  }
}
```

### [](https://www.123fe.net/docs/base/improve.html#_8-xss-%E5%92%8C-csrf)<font style="color:rgb(44, 62, 80);">8 XSS 和 CSRF</font>
![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781596047-5503b9a5-2edd-476e-9749-2659d3c9bef7.png)

**<font style="color:rgb(44, 62, 80);">1. XSS</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">涉及面试题：什么是</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">XSS</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">攻击？如何防范</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">XSS</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">攻击？什么是</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSP</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">？</font>

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">XSS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">简单点来说，就是攻击者想尽一切办法将可以执行的代码注入到网页中。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">XSS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">可以分为多种类型，但是总体上我认为分为两类：持久型和非持久型。</font>
+ <font style="color:rgb(44, 62, 80);">持久型也就是攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击。</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">举个例子，对于评论功能来说，就得防范持久型</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">XSS</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">攻击，因为我可以在评论中输入以下内容</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781601835-11e7a653-10f7-40b9-8954-59b2d46d9df5.png)

+ <font style="color:rgb(44, 62, 80);">这种情况如果前后端没有做好防御的话，这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到。</font>
+ <font style="color:rgb(44, 62, 80);">非持久型相比于前者危害就小的多了，一般通过修改</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">URL</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">举个例子，如果页面需要从</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">URL</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行</font>

```html
<!-- http://www.domain.com?name=<script>alert(1)</script> -->
<div>{{name}}</div>
```

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">但是对于这种攻击方式来说，如果用户使用</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Chrome</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">这类浏览器的话，浏览器就能自动帮助用户防御攻击。但是我们不能因此就不防御此类攻击了，因为我不能确保用户都使用了该类浏览器。</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781601420-9d1d48bc-7441-4a3f-b76a-d9d4709f9c9d.png)

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">对于</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">XSS</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">攻击来说，通常有两种方式可以用来防御。</font>

1. **<font style="color:rgb(44, 62, 80);">转义字符</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">首先，对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义</font>

```javascript
function escape(str) {
  str = str.replace(/&/g, '&amp;')
  str = str.replace(/</g, '&lt;')
  str = str.replace(/>/g, '&gt;')
  str = str.replace(/"/g, '&quto;')
  str = str.replace(/'/g, '&39;')
  str = str.replace(/`/g, '&96;')
  str = str.replace(/\//g, '&x2F;')
  return str
}
```

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">通过转义可以将攻击代码</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><script>alert(1)</script></font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">变成</font>

```javascript
// -> &lt;script&gt;alert(1)&lt;&x2F;script&gt;
escape('<script>alert(1)</script>')
```

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式</font>

```javascript
const xss = require('xss')
let html = xss('<h1 id="title">XSS Demo</h1><script>alert("xss");</script>')
// -> <h1>XSS Demo</h1>&lt;script&gt;alert("xss");&lt;/script&gt;
console.log(html)
```

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">以上示例使用了</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">js-xss</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">来实现，可以看到在输出中保留了</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">h1</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">标签且过滤了</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">script</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">标签</font>

1. **<font style="color:rgb(44, 62, 80);">CSP</font>**

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSP</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">XSS</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">攻击。</font>

**<font style="color:rgb(44, 62, 80);">通常可以通过两种方式来开启 CSP</font>**<font style="color:rgb(44, 62, 80);">：</font>

+ <font style="color:rgb(44, 62, 80);">设置</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP Header</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Content-Security-Policy</font>
+ <font style="color:rgb(44, 62, 80);">设置</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">meta</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">标签的方式</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><meta http-equiv="Content-Security-Policy"></font>

<font style="color:rgb(44, 62, 80);">这里以设置</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP Header</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">来举例</font>

**<font style="color:rgb(44, 62, 80);">只允许加载本站资源</font>**

```plain
Content-Security-Policy: default-src ‘self’
```

**<font style="color:rgb(44, 62, 80);">只允许加载 HTTPS 协议图片</font>**

```javascript
Content-Security-Policy: img-src https://*
```

**<font style="color:rgb(44, 62, 80);">允许加载任何来源框架</font>**

```json
Content-Security-Policy: child-src 'none'
```

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">当然可以设置的属性远不止这些，你可以通过查阅</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font>[文档(opens new window)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的方式来学习，这里就不过多赘述其他的属性了。</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSP</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的兼容性也不错。</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781602366-9a5268b2-3858-4062-8d40-e1e12b230840.png)

**<font style="color:rgb(44, 62, 80);">2 CSRF</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">跨站请求伪造（英语：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cross-site request forgery</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">），也被称为</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">one-click attack</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">或者</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">session riding</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">，通常缩写为</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSRF</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">或者</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">XSRF</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">， 是一种挟制用户在当前已登录的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Web</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">应用程序上执行非本意的操作的攻击方法</font>

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSRF</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">就是利用用户的登录态发起恶意请求</font>

**<font style="color:rgb(44, 62, 80);">如何攻击</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">假设网站中有一个通过 Get 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口</font>

```html
<img src="http://www.domain.com/xxx?comment='attack'"/>
```

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781603718-94663b28-ccad-4fa6-b801-88a0048cd303.png)

```plain
res.setHeader('Set-Cookie', `username=poetry2;sameSite = strict;path=/;httpOnly;expires=${getCookirExpires()}`)
```

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">在B网站，危险网站向A网站发起请求</font>

```html
<!DOCTYPE html>
<html>
  <body>
  <!-- 利用img自动发送请求 -->
    <img src="http://localhost:8000/api/user/login" />
  </body>
</html>
```

<font style="color:rgb(44, 62, 80);">会带上A网站的cookie</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781606972-477b73a5-062c-4f9b-93d0-02ce39b6dc34.png)

```javascript
// 在A网站下发cookie的时候，加上sameSite=strict，这样B网站在发送A网站请求，不会自动带上A网站的cookie，保证了安全


// NAME=VALUE    赋予Cookie的名称及对应值
// expires=DATE  Cookie 的有效期
// path=PATH     赋予Cookie的名称及对应值
// domain=域名   作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie 的服务器的域名） (一般不指定)
// Secure        仅在 HTTPS 安全通信时才会发送 Cookie
// HttpOnly      加以限制，使 Cookie 不能被 JavaScript 脚本访问
// SameSite      Lax|Strict|None  它允许您声明该Cookie是否仅限于第一方或者同一站点上下文

res.setHeader('Set-Cookie', `username=poetry;sameSite=strict;path=/;httpOnly;expires=${getCookirExpires()}`)
```

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781604159-10a60993-1bda-46b5-9ce8-511b093a1f40.png)

**<font style="color:rgb(44, 62, 80);">如何防御</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Get</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">请求不对数据进行修改</font>
+ <font style="color:rgb(44, 62, 80);">不让第三方网站访问到用户</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font>
+ <font style="color:rgb(44, 62, 80);">阻止第三方网站请求接口</font>
+ <font style="color:rgb(44, 62, 80);">请求时附带验证信息，比如验证码或者</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">token</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">SameSite Cookies</font><font style="color:rgb(44, 62, 80);">: 只能当前域名的网站发出的http请求，携带这个</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);">。当然，由于这是新的cookie属性，在兼容性上肯定会有问题</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">CSRF攻击，仅仅是利用了http携带cookie的特性进行攻击的，但是攻击站点还是无法得到被攻击站点的cookie。这个和XSS不同，XSS是直接通过拿到Cookie等信息进行攻击的</font>

**<font style="color:rgb(44, 62, 80);">在CSRF攻击中，就Cookie相关的特性：</font>**

+ <font style="color:rgb(44, 62, 80);">http请求，会自动携带Cookie。</font>
+ <font style="color:rgb(44, 62, 80);">携带的cookie，还是http请求所在域名的cookie。</font>

**<font style="color:rgb(44, 62, 80);">3 密码安全</font>**

**<font style="color:rgb(44, 62, 80);">加盐</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">对于密码存储来说，必然是不能明文存储在数据库中的，否则一旦数据库泄露，会对用户造成很大的损失。并且不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系</font>

+ <font style="color:rgb(44, 62, 80);">通常需要对密码加盐，然后进行几次不同加密算法的加密</font>

```javascript
// 加盐也就是给原密码添加字符串，增加原密码长度
sha256(sha1(md5(salt + password + salt)))
```

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">但是加盐并不能阻止别人盗取账号，只能确保即使数据库泄露，也不会暴露用户的真实密码。一旦攻击者得到了用户的账号，可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而应该提示账号或密码错误</font>

**<font style="color:rgb(44, 62, 80);">前端加密</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">虽然前端加密对于安全防护来说意义不大，但是在遇到中间人攻击的情况下，可以避免明文密码被第三方获取</font>

**<font style="color:rgb(44, 62, 80);">4. 总结</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">XSS</font><font style="color:rgb(44, 62, 80);">：跨站脚本攻击，是一种网站应用程序的安全漏洞攻击，是代码注入的一种。常见方式是将恶意代码注入合法代码里隐藏起来，再诱发恶意代码，从而进行各种各样的非法活动</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">防范：记住一点 “所有用户输入都是不可信的”，所以得做输入过滤和转义</font>

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSRF</font><font style="color:rgb(44, 62, 80);">：跨站请求伪造，也称</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">XSRF</font><font style="color:rgb(44, 62, 80);">，是一种挟制用户在当前已登录的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Web</font><font style="color:rgb(44, 62, 80);">应用程序上执行非本意的操作的攻击方法。与</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">XSS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">相比，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">XSS</font><font style="color:rgb(44, 62, 80);">利用的是用户对指定网站的信任，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSRF</font><font style="color:rgb(44, 62, 80);">利用的是网站对用户网页浏览器的信任。</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">防范：用户操作验证（验证码），额外验证机制（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">token</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">使用）等</font>

### [](https://www.123fe.net/docs/base/improve.html#_9-service-worker)<font style="color:rgb(44, 62, 80);">9 Service Worker</font>
<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Service workers</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API</font>

**<font style="color:rgb(44, 62, 80);">浏览器对 ServiceWorker 做了很多限制</font>**

+ <font style="color:rgb(44, 62, 80);">在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ServiceWorker</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中无法直接访问</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">，但可以通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">postMessage</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">接口发送的消息来与其控制的页面进行通信</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ServiceWorker</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">只能在本地环境下或</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTPS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">网站中使用</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ServiceWorker</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">有作用域的限制，一个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ServiceWorker</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">脚本只能作用于当前路径及其子路径；</font>

**<font style="color:rgb(44, 62, 80);">目前该技术通常用来做缓存文件，提高首屏速度</font>**

```javascript
// index.js
if (navigator.serviceWorker) {
  navigator.serviceWorker
    .register("sw.js")
    .then(function(registration) {
      console.log("service worker 注册成功");
    })
    .catch(function(err) {
      console.log("servcie worker 注册失败");
    });
}
// sw.js
// 监听 `install` 事件，回调中缓存所需文件
self.addEventListener("install", e => {
  e.waitUntil(
    caches.open("my-cache").then(function(cache) {
      return cache.addAll(["./index.html", "./index.js"]);
    })
  );
});

// 拦截所有请求事件
// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据
self.addEventListener("fetch", e => {
  e.respondWith(
    caches.match(e.request).then(function(response) {
      if (response) {
        return response;
      }
      console.log("fetch source");
    })
  );
});
```

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">打开页面，可以在开发者工具中的</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Application</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">看到</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Service Worker</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">已经启动了</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781610213-6582cf59-f00b-4759-984d-03ca651b313d.png)

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">在 Cache 中也可以发现我们所需的文件已被缓存</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781611690-932628d2-bef4-4f9d-8fa0-093b972831e2.png)

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">当我们重新刷新页面可以发现我们缓存的数据是从</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Service</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Worker</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">中读取的</font>

### [](https://www.123fe.net/docs/base/improve.html#_10-dom-%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C)<font style="color:rgb(44, 62, 80);">10 DOM 节点操作</font>
**<font style="color:rgb(44, 62, 80);">（1）创建新节点</font>**

```plain
createDocumentFragment()    //创建一个DOM片段
createElement()   //创建一个具体的元素
createTextNode()   //创建一个文本节点
```

**<font style="color:rgb(44, 62, 80);">（2）添加、移除、替换、插入</font>**

```javascript
appendChild(node)
removeChild(node)
replaceChild(new,old)
insertBefore(new,old)
```

**<font style="color:rgb(44, 62, 80);">（3）查找</font>**

```javascript
getElementById();
getElementsByName();
getElementsByTagName();
getElementsByClassName();
querySelector();
querySelectorAll();
```

**<font style="color:rgb(44, 62, 80);">（4）属性操作</font>**

```javascript
getAttribute(key);
setAttribute(key, value);
hasAttribute(key);
removeAttribute(key);
```

### [](https://www.123fe.net/docs/base/improve.html#_11-%E6%8E%8C%E6%8F%A1%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B)<font style="color:rgb(44, 62, 80);">11 掌握页面的加载过程</font>
**<font style="color:rgb(44, 62, 80);">网页加载流程</font>**

+ <font style="color:rgb(44, 62, 80);">当我们打开网址的时候，浏览器会从服务器中获取到 HTML 内容</font>
+ <font style="color:rgb(44, 62, 80);">浏览器获取到 HTML 内容后，就开始从上到下解析 HTML 的元素</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><head></font><font style="color:rgb(44, 62, 80);">元素内容会先被解析，此时</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">浏览器还没开始渲染页面</font>
    - <font style="color:rgb(44, 62, 80);">我们看到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><head></font><font style="color:rgb(44, 62, 80);">元素里有用于描述页面元数据的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><meta></font><font style="color:rgb(44, 62, 80);">元素，还有一些</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><link></font><font style="color:rgb(44, 62, 80);">元素涉及外部资源（如</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">图片、CSS 样式</font><font style="color:rgb(44, 62, 80);">等），此时浏览器会去获取这些外部资源。除此之外，我们还能看到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><head></font><font style="color:rgb(44, 62, 80);">元素中还包含着不少的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><script></font><font style="color:rgb(44, 62, 80);">元素，这些</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><script></font><font style="color:rgb(44, 62, 80);">元素通过</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">src</font><font style="color:rgb(44, 62, 80);">属性指向外部资源</font>
+ <font style="color:rgb(44, 62, 80);">当浏览器解析到这里时（步骤 3），会暂停解析并下载 JavaScript 脚本</font>
+ <font style="color:rgb(44, 62, 80);">当 JavaScript 脚本下载完成后，浏览器的控制权转交给 JavaScript 引擎。当脚本执行完成后，控制权会交回给渲染引擎，渲染引擎继续往下解析</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">页面</font>
+ <font style="color:rgb(44, 62, 80);">此时</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><body></font><font style="color:rgb(44, 62, 80);">元素内容开始被解析，浏览器开始渲染页面</font>
+ <font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">在这个过程中，我们看到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><head></font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">中放置的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><script></font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">元素会阻塞页面的渲染过程：把 JavaScript 放在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><head></font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">里，意味着必须把所有 JavaScript 代码都</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">下载、解析和解释完成后，才能开始渲染页面</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">。</font>
+ <font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">如果外部脚本加载时间很长（比如一直无法完成下载），就会造成网页长时间失去响应，浏览器就会呈现“假死”状态，用户体验会变得很糟糕</font>
+ <font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">因此，对于对性能要求较高、需要快速将内容呈现给用户的网页，常常会将 JavaScript 脚本放在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><body></font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的最后面。这样</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">可以避免资源阻塞，页面得以迅速展示</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">。我们还可以使用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">defer/async/preload</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">等属性来标记</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><script></font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">标签，来控制 JavaScript 的加载顺序</font>

**<font style="color:rgb(44, 62, 80);">延迟加载的方式有哪些</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</font>

**<font style="color:rgb(44, 62, 80);">几种方式是：</font>**

+ <font style="color:rgb(44, 62, 80);">将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行</font>
+ <font style="color:rgb(44, 62, 80);">给 js 脚本添加</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">defer</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">defer</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样</font>
+ <font style="color:rgb(44, 62, 80);">给 js 脚本添加</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">async</font><font style="color:rgb(44, 62, 80);">属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">async</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行</font>
+ <font style="color:rgb(44, 62, 80);">动态创建</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">script</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">标签来引入 js 脚本</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781612349-a713d7fc-b42e-4cfb-b4f1-09d6c148a1ca.png)

**<font style="color:rgb(44, 62, 80);">怎么判断页面是否加载完成</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Load</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">事件触发代表页面中的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSS</font><font style="color:rgb(44, 62, 80);">，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">，图片已经全部加载完毕。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOMContentLoaded</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">事件触发代表初始的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">被完全加载和解析，不需要等待</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSS</font><font style="color:rgb(44, 62, 80);">，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">，图片加载</font>

### [](https://www.123fe.net/docs/base/improve.html#_12-%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B)<font style="color:rgb(44, 62, 80);">12 从输入URL到页面展示过程</font>
![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781612232-06815bd3-a984-4021-bcff-06264cfadde5.png)

**<font style="color:rgb(44, 62, 80);">1. DNS域名解析</font>**

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781612665-1f9e32e6-47a9-4d95-804b-e7a14a66650e.png)

+ <font style="color:rgb(44, 62, 80);">根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址</font>
+ <font style="color:rgb(44, 62, 80);">顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址</font>
+ <font style="color:rgb(44, 62, 80);">权威 DNS 服务器 ：返回相应主机的 IP 地址</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">DNS的域名查找，在客户端和浏览器，本地DNS之间的查询方式是递归查询；在本地DNS服务器与根域及其子域之间的查询方式是迭代查询；</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781614465-4635c8b5-e5de-40ea-a87b-cc3f09072a13.png)

<font style="color:rgb(44, 62, 80);">在客户端输入 URL 后，会有一个递归查找的过程，从</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">浏览器缓存中查找->本地的hosts文件查找->找本地DNS解析器缓存查找->本地DNS服务器查找</font><font style="color:rgb(44, 62, 80);">，这个过程中任何一步找到了都会结束查找流程。</font>

<font style="color:rgb(44, 62, 80);">如果本地DNS服务器无法查询到，则根据本地DNS服务器设置的转发器进行查询。若未用转发模式，则迭代查找过程如下图：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781615006-a409b043-78a1-4296-950b-0e1a7b4ab86b.png)

<font style="color:rgb(44, 62, 80);">结合起来的过程，可以用一个图表示：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781615018-910ada94-cbb5-4870-a0b1-6b482f84681e.png)

**<font style="color:rgb(44, 62, 80);">在查找过程中，有以下优化点：</font>**

+ <font style="color:rgb(44, 62, 80);">DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种:</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存</font><font style="color:rgb(44, 62, 80);">。</font>
+ <font style="color:rgb(44, 62, 80);">在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。</font>

**<font style="color:rgb(44, 62, 80);">2. 建立TCP连接</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">首先，判断是不是https的，如果是，则HTTPS其实是HTTP + SSL / TLS 两部分组成，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据</font>

<font style="color:rgb(44, 62, 80);">进行三次握手，建立TCP连接。</font>

+ <font style="color:rgb(44, 62, 80);">第一次握手：建立连接。客户端发送连接请求报文段</font>
+ <font style="color:rgb(44, 62, 80);">第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认</font>
+ <font style="color:rgb(44, 62, 80);">第三次握手：客户端收到服务器的SYN+ACK报文段，向服务器发送ACK报文段</font>

**<font style="color:rgb(44, 62, 80);">SSL握手过程</font>**

+ <font style="color:rgb(44, 62, 80);">第一阶段 建立安全能力 包括协议版本 会话Id 密码构件 压缩方法和初始随机数</font>
+ <font style="color:rgb(44, 62, 80);">第二阶段 服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号</font>
+ <font style="color:rgb(44, 62, 80);">第三阶段 如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息</font>
+ <font style="color:rgb(44, 62, 80);">第四阶段 变更密码构件和结束握手协议</font>

<font style="color:rgb(44, 62, 80);">完成了之后，客户端和服务器端就可以开始传送数据</font>

**<font style="color:rgb(44, 62, 80);">发送HTTP请求，服务器处理请求，返回响应结果</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">TCP连接建立后，浏览器就可以利用</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP／HTTPS</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">协议向服务器发送请求了。服务器接受到请求，就解析请求头，如果头部有缓存相关信息如</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">if-none-match与if-modified-since</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">，则验证缓存是否有效，若有效则返回状态码为</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">304</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">，若无效则重新返回资源，状态码为</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">200</font>

<font style="color:rgb(44, 62, 80);">这里有发生的一个过程是HTTP缓存，是一个常考的考点，大致过程如图：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781615082-b22d0ae9-1d27-4f52-b9e9-277e766d0487.png)

**<font style="color:rgb(44, 62, 80);">3. 关闭TCP连接</font>**

**<font style="color:rgb(44, 62, 80);">4. 浏览器渲染</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示。如图：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781616556-fc12d1fd-74ba-4e67-a625-b822e03a6460.png)

+ <font style="color:rgb(44, 62, 80);">渲染进程将 HTML 内容转换为能够读懂DOM 树结构。</font>
+ <font style="color:rgb(44, 62, 80);">渲染引擎将 CSS 样式表转化为浏览器可以理解的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">styleSheets</font><font style="color:rgb(44, 62, 80);">，计算出</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">节点的样式。</font>
+ <font style="color:rgb(44, 62, 80);">创建布局树，并计算元素的布局信息。</font>
+ <font style="color:rgb(44, 62, 80);">对布局树进行分层，并生成分层树。</font>
+ <font style="color:rgb(44, 62, 80);">为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。</font>
+ <font style="color:rgb(44, 62, 80);">合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。</font>

**<font style="color:rgb(44, 62, 80);">构建 DOM 树</font>**

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781616949-b240c653-b883-4de3-979f-be47812725d5.png)

+ <font style="color:rgb(44, 62, 80);">转码（Bytes -> Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串</font>
+ <font style="color:rgb(44, 62, 80);">Tokens 化（Characters -> Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则</font>
+ <font style="color:rgb(44, 62, 80);">构建 Nodes（Tokens -> Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同）</font>
+ <font style="color:rgb(44, 62, 80);">构建 DOM 树（Nodes -> DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系</font>

**<font style="color:rgb(44, 62, 80);">样式计算</font>**

<font style="color:rgb(44, 62, 80);">渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">CSS 样式来源主要有 3 种，分别是通过 link 引用的外部 CSS 文件、style标签内的 CSS、元素的 style 属性内嵌的 CSS。</font>

**<font style="color:rgb(44, 62, 80);">页面布局</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">布局过程，即</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">排除 script、meta 等功能化、非视觉节点</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">，排除</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">display: none</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的节点，计算元素的位置信息，确定元素的位置，构建一棵只包含可见元素布局树。如图：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781618794-ba9ff3b8-71a5-4ec6-aabf-d2bd7b3a81b0.png)

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">其中，这个过程需要注意的是回流和重绘</font>

**<font style="color:rgb(44, 62, 80);">生成分层树</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）</font>

**<font style="color:rgb(44, 62, 80);">栅格化</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781618545-a50ad7da-39cf-4080-a40f-e3d7b71242c8.png)

<font style="color:rgb(44, 62, 80);">通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</font>

**<font style="color:rgb(44, 62, 80);">显示</font>**

<font style="color:rgb(44, 62, 80);">最后，合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上，渲染过程完成。</font>

### [](https://www.123fe.net/docs/base/improve.html#_13-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E6%89%8D%E4%BC%9A%E4%B8%BA%E7%89%B9%E5%AE%9A%E7%9A%84%E8%8A%82%E7%82%B9%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E5%9B%BE%E5%B1%82)<font style="color:rgb(44, 62, 80);">13 渲染引擎什么情况下才会为特定的节点创建新的图层</font>
<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">层叠上下文</font><font style="color:rgb(44, 62, 80);">是HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的z轴上延伸，HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。</font>

1. <font style="color:rgb(44, 62, 80);">拥有层叠上下文属性的元素会被提升为单独的一层。</font>

<font style="color:rgb(44, 62, 80);">拥有层叠上下文属性：</font>

+ <font style="color:rgb(44, 62, 80);">根元素 (HTML),</font>
+ <font style="color:rgb(44, 62, 80);">z-index 值不为 "auto"的 绝对/相对定位元素，</font>
+ <font style="color:rgb(44, 62, 80);">position,固定（fixed） / 沾滞（sticky）定位（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）</font>
+ <font style="color:rgb(44, 62, 80);">z-index值不为 "auto"的 flex 子项 (flex item)，即：父元素 display: flex|inline-flex，</font>
+ <font style="color:rgb(44, 62, 80);">z-index值不为"auto"的grid子项，即：父元素display：grid</font>
+ <font style="color:rgb(44, 62, 80);">opacity 属性值小于 1 的元素（参考 the specification for opacity），</font>
+ <font style="color:rgb(44, 62, 80);">transform 属性值不为 "none"的元素，</font>
+ <font style="color:rgb(44, 62, 80);">mix-blend-mode 属性值不为 "normal"的元素，</font>
+ <font style="color:rgb(44, 62, 80);">filter值不为"none"的元素，</font>
+ <font style="color:rgb(44, 62, 80);">perspective值不为"none"的元素，</font>
+ <font style="color:rgb(44, 62, 80);">clip-path值不为"none"的元素</font>
+ <font style="color:rgb(44, 62, 80);">mask / mask-image / mask-border不为"none"的元素</font>
+ <font style="color:rgb(44, 62, 80);">isolation 属性被设置为 "isolate"的元素</font>
+ <font style="color:rgb(44, 62, 80);">在 will-change 中指定了任意CSS属性（参考 这篇文章）</font>
+ <font style="color:rgb(44, 62, 80);">-webkit-overflow-scrolling 属性被设置 "touch"的元素</font>
+ <font style="color:rgb(44, 62, 80);">contain属性值为"layout"，"paint"，或者综合值比如"strict"，"content"</font>
1. <font style="color:rgb(44, 62, 80);">需要剪裁（clip）的地方也会被创建为图层。</font>

<font style="color:rgb(44, 62, 80);">这里的剪裁指的是，假如我们把 div 的大小限定为 200 * 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 * 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域。出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。</font>

### [](https://www.123fe.net/docs/base/improve.html#_14-%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8Erequestanimationframe%E3%80%81requestidlecallback)<font style="color:rgb(44, 62, 80);">14 定时器与requestAnimationFrame、requestIdleCallback</font>
**<font style="color:rgb(44, 62, 80);">1. setTimeout</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">setTimeout的运行机制：执行该语句时，是立即把当前定时器代码推入事件队列，当定时器在事件列表中满足设置的时间值时将传入的函数加入任务队列，之后的执行就交给任务队列负责。但是如果此时任务队列不为空，则需等待，所以执行定时器内代码的时间可能会大于设置的时间</font>

```javascript
setTimeout(() => {
  console.log(1);
}, 0)
console.log(2);
```

<font style="color:rgb(44, 62, 80);">输出 2， 1；</font>

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setTimeout</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的第二个参数表示在执行代码前等待的毫秒数。上面代码中，设置为0，表面意思为 执行代码前等待的毫秒数为0，即立即执行。但实际上的运行结果我们也看到了，并不是表面上看起来的样子，千万不要被欺骗了。</font>

<font style="color:rgb(44, 62, 80);">实际上，上面的代码并不是立即执行的，这是因为</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setTimeout</font><font style="color:rgb(44, 62, 80);">有一个最小执行时间，HTML5标准规定了</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setTimeout()</font><font style="color:rgb(44, 62, 80);">的第二个参数的最小值（最短间隔）</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">不得低于4毫秒</font><font style="color:rgb(44, 62, 80);">。 当指定的时间低于该时间时，浏览器会用最小允许的时间作为</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setTimeout</font><font style="color:rgb(44, 62, 80);">的时间间隔，也就是说即使我们把</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setTimeout</font><font style="color:rgb(44, 62, 80);">的延迟时间设置为0，实际上可能为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">4毫秒后才事件推入任务队列</font><font style="color:rgb(44, 62, 80);">。</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">定时器代码在被推送到任务队列前，会先被推入到事件列表中，当定时器在事件列表中满足设置的时间值时会被推到任务队列，但是如果此时任务队列不为空，则需等待，所以执行定时器内代码的时间可能会大于设置的时间</font>

```javascript
setTimeout(() => {
  console.log(111);
}, 100);
```

<font style="color:rgb(44, 62, 80);">上面代码表示</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">100ms</font><font style="color:rgb(44, 62, 80);">后执行</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">console.log(111)</font><font style="color:rgb(44, 62, 80);">，但实际上实行的时间肯定是大于100ms后的， 100ms 只是表示 100ms 后将任务加入到"任务队列"中，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setTimeout()</font><font style="color:rgb(44, 62, 80);">指定的时间执行。</font>

**<font style="color:rgb(44, 62, 80);">2. setTimeout 和 setInterval区别</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setTimeout</font><font style="color:rgb(44, 62, 80);">: 指定延期后调用函数，每次</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setTimeout</font><font style="color:rgb(44, 62, 80);">计时到后就会去执行，然后执行一段时间后才继续</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setTimeout</font><font style="color:rgb(44, 62, 80);">,中间就多了误差，（误差多少与代码的执行时间有关）。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setInterval</font><font style="color:rgb(44, 62, 80);">：以指定周期调用函数，而</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setInterval</font><font style="color:rgb(44, 62, 80);">则是每次都精确的隔一段时间推入一个事件（但是，事件的执行时间不一定就不准确，还有可能是这个事件还没执行完毕，下一个事件就来了）.</font>

```javascript
btn.onclick = function(){
  setTimeout(function(){
    console.log(1);
  },250);
}
```

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">击该按钮后，首先将</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">onclick</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">事件处理程序加入队列。该程序执行后才设置定时器，再有</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">250ms</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">后，指定的代码才被添加到队列中等待执行。 如果上面代码中的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">onclick</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">事件处理程序执行了</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">300ms</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">，那么定时器的代码至少要在定时器设置之后的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">300ms</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">后才会被执行。队列中所有的代码都要等到javascript进程空闲之后才能执行，而不管它们是如何添加到队列中的。</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781618875-7905c2d5-243f-4df2-aa42-303df6b4f49a.png)

<font style="color:rgb(44, 62, 80);">如图所示，尽管在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">255ms</font><font style="color:rgb(44, 62, 80);">处添加了定时器代码，但这时候还不能执行，因为</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">onclick</font><font style="color:rgb(44, 62, 80);">事件处理程序仍在运行。定时器代码最早能执行的时机是在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">300ms</font><font style="color:rgb(44, 62, 80);">处，即</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">onclick</font><font style="color:rgb(44, 62, 80);">事件处理程序结束之后。</font>

**<font style="color:rgb(44, 62, 80);">3. setInterval存在的一些问题：</font>**

<font style="color:rgb(44, 62, 80);">JavaScript中使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setInterval</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">开启轮询。定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。而javascript引擎对这个问题的解决是：当使用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setInterval()</font><font style="color:rgb(44, 62, 80);">时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。</font>

<font style="color:rgb(44, 62, 80);">但是，这样会导致两个问题：</font>

+ <font style="color:rgb(44, 62, 80);">某些间隔被跳过；</font>
+ <font style="color:rgb(44, 62, 80);">多个定时器的代码执行之间的间隔可能比预期的小</font>

<font style="color:rgb(44, 62, 80);">假设，某个</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">onclick</font><font style="color:rgb(44, 62, 80);">事件处理程序使用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setInterval()</font><font style="color:rgb(44, 62, 80);">设置了</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">200ms</font><font style="color:rgb(44, 62, 80);">间隔的定时器。如果事件处理程序花了</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">300ms</font><font style="color:rgb(44, 62, 80);">多一点时间完成，同时定时器代码也花了差不多的时间，就会同时出现跳过某间隔的情况</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781620361-68032630-249a-47cb-b16e-99f954c3c703.png)

<font style="color:rgb(44, 62, 80);">例子中的第一个定时器是在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">205ms</font><font style="color:rgb(44, 62, 80);">处添加到队列中的，但是直到过了</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">300ms</font><font style="color:rgb(44, 62, 80);">处才能执行。当执行这个定时器代码时，在405ms处又给队列添加了另一个副本。在下一个间隔，即605ms处，第一个定时器代码仍在运行，同时在队列中已经有了一个定时器代码的实例。结果是，在这个时间点上的定时器代码不会被添加到队列中</font>

<font style="color:rgb(44, 62, 80);">使用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setTimeout</font><font style="color:rgb(44, 62, 80);">构造轮询能保证每次轮询的间隔。</font>

```javascript
setTimeout(function () {
  console.log('我被调用了');
  setTimeout(arguments.callee, 100);
}, 100);
```

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">callee</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">是</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">arguments</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。在严格模式下，第5版 ECMAScript (ES5) 禁止使用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">arguments.callee()</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">。当一个函数必须调用自身的时候, 避免使用</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">arguments.callee()</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">, 通过要么给函数表达式一个名字,要么使用一个函数声明.</font>

```javascript
setTimeout(function fn(){
  console.log('我被调用了');
  setTimeout(fn, 100);
},100);
```

<font style="color:rgb(44, 62, 80);">这个模式链式调用了</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setTimeout()</font><font style="color:rgb(44, 62, 80);">，每次函数执行的时候都会创建一个新的定时器。第二个</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setTimeout()</font><font style="color:rgb(44, 62, 80);">调用当前执行的函数，并为其设置另外一个定时器。这样做的好处是，在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。而且，它可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行。</font>

**<font style="color:rgb(44, 62, 80);">4. requestAnimationFrame</font>**

**<font style="color:rgb(44, 62, 80);">4.1</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">60fps</font>****<font style="color:rgb(44, 62, 80);">与设备刷新率</font>**

<font style="color:rgb(44, 62, 80);">目前大多数设备的屏幕刷新率为</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">60次/秒</font><font style="color:rgb(44, 62, 80);">，如果在页面中有一个动画或者渐变效果，或者用户正在滚动页面，那么浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致。</font>

<font style="color:rgb(44, 62, 80);">卡顿：其中每个帧的预算时间仅比</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">16毫秒</font><font style="color:rgb(44, 62, 80);">多一点（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">1秒/ 60 = 16.6毫秒</font><font style="color:rgb(44, 62, 80);">）。但实际上，浏览器有整理工作要做，因此您的所有工作是需要在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">10毫秒</font><font style="color:rgb(44, 62, 80);">内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。此现象通常称为卡顿，会对用户体验产生负面影响。</font>

<font style="color:rgb(44, 62, 80);">跳帧: 假如动画切换在 16ms, 32ms, 48ms时分别切换，跳帧就是假如到了32ms，其他任务还未执行完成，没有去执行动画切帧，等到开始进行动画的切帧，已经到了该执行48ms的切帧。就好比你玩游戏的时候卡了，过了一会，你再看画面，它不会停留你卡的地方，或者这时你的角色已经挂掉了。必须在下一帧开始之前就已经绘制完毕;</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">Chrome devtool 查看实时 FPS, 打开 More tools => Rendering, 勾选 FPS meter</font>

**<font style="color:rgb(44, 62, 80);">4.2</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestAnimationFrame</font>****<font style="color:rgb(44, 62, 80);">实现动画</font>**

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestAnimationFrame</font><font style="color:rgb(44, 62, 80);">是浏览器用于定时循环操作的一个接口，类似于setTimeout，主要用途是按帧对网页进行重绘。</font>

<font style="color:rgb(44, 62, 80);">在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestAnimationFrame</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">之前，主要借助</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setTimeout/ setInterval</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">来编写 JS 动画，而动画的关键在于动画帧之间的时间间隔设置，这个时间间隔的设置有讲究，一方面要足够小，这样动画帧之间才有连贯性，动画效果才显得平滑流畅；另一方面要足够大，确保浏览器有足够的时间及时完成渲染。</font>

<font style="color:rgb(44, 62, 80);">显示器有固定的刷新频率（60Hz或75Hz），也就是说，每秒最多只能重绘60次或75次，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestAnimationFrame</font><font style="color:rgb(44, 62, 80);">的基本思想就是与这个刷新频率保持同步，利用这个刷新频率进行页面重绘。此外，使用这个API，一旦页面不处于浏览器的当前标签，就会自动停止刷新。这就节省了CPU、GPU和电力。</font>

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestAnimationFrame</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是在主线程上完成。这意味着，如果主线程非常繁忙，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestAnimationFrame</font><font style="color:rgb(44, 62, 80);">的动画效果会大打折扣。</font>

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestAnimationFrame</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">使用一个回调函数作为参数。这个回调函数会在浏览器重绘之前调用。</font>

```javascript
requestID = window.requestAnimationFrame(callback); 

window.requestAnimFrame = (function(){
  return  window.requestAnimationFrame       || 
    window.webkitRequestAnimationFrame || 
    window.mozRequestAnimationFrame    || 
    window.oRequestAnimationFrame      || 
    window.msRequestAnimationFrame     || 
    function( callback ){
      window.setTimeout(callback, 1000 / 60);
    };
})();
```

<font style="color:rgb(44, 62, 80);">上面的代码按照1秒钟60次（大约每16.7毫秒一次），来模拟</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestAnimationFrame</font><font style="color:rgb(44, 62, 80);">。</font>

**<font style="color:rgb(44, 62, 80);">5. requestIdleCallback()</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">MDN上的解释：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestIdleCallback()</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。</font>

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestAnimationFrame</font><font style="color:rgb(44, 62, 80);">会在每次屏幕刷新的时候被调用，而</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestIdleCallback</font><font style="color:rgb(44, 62, 80);">则会在每次屏幕刷新时，判断当前帧是否还有多余的时间，如果有，则会调用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestIdleCallback</font><font style="color:rgb(44, 62, 80);">的回调函数，</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718781620383-e0711696-cc3a-483f-a242-5ac26ccedfef.png)

<font style="color:rgb(44, 62, 80);">图片中是两个连续的执行帧，大致可以理解为两个帧的持续时间大概为16.67，图中黄色部分就是空闲时间。所以，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestIdleCallback</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中的回调函数仅会在每次屏幕刷新并且有空闲时间时才会被调用.</font>

<font style="color:rgb(44, 62, 80);">利用这个特性，我们可以在动画执行的期间，利用每帧的空闲时间来进行数据发送的操作，或者一些优先级比较低的操作，此时不会使影响到动画的性能，或者和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestAnimationFrame</font><font style="color:rgb(44, 62, 80);">搭配，可以实现一些页面性能方面的的优化，</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">react 的</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">fiber</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">架构也是基于</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestIdleCallback</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">实现的, 并且在不支持的浏览器中提供了</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">polyfill</font>

**<font style="color:rgb(44, 62, 80);">总结</font>**

+ <font style="color:rgb(44, 62, 80);">从</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">单线程模型和任务队列</font><font style="color:rgb(44, 62, 80);">出发理解</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setTimeout(fn, 0)</font><font style="color:rgb(44, 62, 80);">，并不是立即执行。</font>
+ <font style="color:rgb(44, 62, 80);">JS 动画, 用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestAnimationFrame</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">会比</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setInterval</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">效果更好</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestIdleCallback()</font><font style="color:rgb(44, 62, 80);">常用来切割长任务，利用空闲时间执行，避免主线程长时间阻塞</font>

