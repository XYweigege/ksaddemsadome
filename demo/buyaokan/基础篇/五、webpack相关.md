### <font style="color:rgb(44, 62, 80);">1 打包体积 优化思路</font>
+ <font style="color:rgb(44, 62, 80);">提取第三方库或通过引用外部文件的方式引入第三方库</font>
+ <font style="color:rgb(44, 62, 80);">代码压缩插件</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">UglifyJsPlugin</font>
+ <font style="color:rgb(44, 62, 80);">服务器启用gzip压缩</font>
+ <font style="color:rgb(44, 62, 80);">按需加载资源文件</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">require.ensure</font>
+ <font style="color:rgb(44, 62, 80);">优化</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">devtool</font><font style="color:rgb(44, 62, 80);">中的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">source-map</font>
+ <font style="color:rgb(44, 62, 80);">剥离</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">css</font><font style="color:rgb(44, 62, 80);">文件，单独打包</font>
+ <font style="color:rgb(44, 62, 80);">去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致</font>

### [](https://www.123fe.net/docs/base.html#_2-%E6%89%93%E5%8C%85%E6%95%88%E7%8E%87)<font style="color:rgb(44, 62, 80);">2 打包效率</font>
+ <font style="color:rgb(44, 62, 80);">开发环境采用增量构建，启用热更新</font>
+ <font style="color:rgb(44, 62, 80);">开发环境不做无意义的工作如提取</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">css</font><font style="color:rgb(44, 62, 80);">计算文件hash等</font>
+ <font style="color:rgb(44, 62, 80);">配置</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">devtool</font>
+ <font style="color:rgb(44, 62, 80);">选择合适的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">loader</font>
+ <font style="color:rgb(44, 62, 80);">个别</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">loader</font><font style="color:rgb(44, 62, 80);">开启</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">cache</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">如</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">babel-loader</font>
+ <font style="color:rgb(44, 62, 80);">第三方库采用引入方式</font>
+ <font style="color:rgb(44, 62, 80);">提取公共代码</font>
+ <font style="color:rgb(44, 62, 80);">优化构建时的搜索路径 指明需要构建目录及不需要构建目录</font>
+ <font style="color:rgb(44, 62, 80);">模块化引入需要的部分</font>

### [](https://www.123fe.net/docs/base.html#_3-loader)<font style="color:rgb(44, 62, 80);">3 Loader</font>
<font style="color:rgb(44, 62, 80);">编写一个loader</font>

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">loader</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">就是一个</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">node</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">模块，它输出了一个函数。当某种资源需要用这个</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">loader</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">转换时，这个函数会被调用。并且，这个函数可以通过提供给它的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">上下文访问</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Loader API</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">。</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">reverse-txt-loader</font>

```plain
// 定义
module.exports = function(src) {
  //src是原文件内容（abcde），下面对内容进行处理，这里是反转
  var result = src.split('').reverse().join('');
  //返回JavaScript源码，必须是String或者Buffer
  return `module.exports = '${result}'`;
}
//使用
{
	test: /\.txt$/,
	use: [
		{
			'./path/reverse-txt-loader'
		}
	]
},
```

### [](https://www.123fe.net/docs/base.html#_4-%E8%AF%B4%E4%B8%80%E4%B8%8Bwebpack%E7%9A%84%E4%B8%80%E4%BA%9Bplugin-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8webpack%E5%AF%B9%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96)<font style="color:rgb(44, 62, 80);">4 说一下webpack的一些plugin，怎么使用webpack对项目进行优化</font>
**<font style="color:rgb(44, 62, 80);">构建优化</font>**

+ <font style="color:rgb(44, 62, 80);">减少编译体积</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ContextReplacementPugin</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">IgnorePlugin</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">babel-plugin-import</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">babel-plugin-transform-runtime</font>
+ <font style="color:rgb(44, 62, 80);">并行编译</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">happypack</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">thread-loader</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">uglifyjsWebpackPlugin</font><font style="color:rgb(44, 62, 80);">开启并行</font>
+ <font style="color:rgb(44, 62, 80);">缓存</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">cache-loader</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">hard-source-webpack-plugin</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">uglifyjsWebpackPlugin</font><font style="color:rgb(44, 62, 80);">开启缓存、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">babel-loader</font><font style="color:rgb(44, 62, 80);">开启缓存</font>
+ <font style="color:rgb(44, 62, 80);">预编译</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">dllWebpackPlugin && DllReferencePlugin</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">auto-dll-webapck-plugin</font>

**<font style="color:rgb(44, 62, 80);">性能优化</font>**

+ <font style="color:rgb(44, 62, 80);">减少编译体积</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Tree-shaking</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Scope Hositing</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">hash</font><font style="color:rgb(44, 62, 80);">缓存</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">webpack-md5-plugin</font>
+ <font style="color:rgb(44, 62, 80);">拆包</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">splitChunksPlugin</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">import()</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">require.ensure</font>

### [](https://www.123fe.net/docs/base.html#_5-webpack-plugin-%E5%92%8C-loader-%E7%9A%84%E5%8C%BA%E5%88%AB)<font style="color:rgb(44, 62, 80);">5 webpack Plugin 和 Loader 的区别</font>
**<font style="color:rgb(44, 62, 80);">Loader：</font>**

<font style="color:rgb(44, 62, 80);">用于对模块源码的转换，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">loader</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">描述了</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">webpack</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">如何处理非</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">javascript</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">模块，并且在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">build</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中引入这些依赖。l</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">oader</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">可以将文件从不同的语言（如</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">TypeScript</font><font style="color:rgb(44, 62, 80);">）转换为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JavaScript</font><font style="color:rgb(44, 62, 80);">，或者将内联图像转换为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">data URL</font><font style="color:rgb(44, 62, 80);">。比如说：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSS-Loader</font><font style="color:rgb(44, 62, 80);">，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Style-Loader</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">等</font>

**<font style="color:rgb(44, 62, 80);">Plugin</font>**

<font style="color:rgb(44, 62, 80);">目的在于解决</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">loader</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">无法实现的其他事,它直接作用于</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">webpack</font><font style="color:rgb(44, 62, 80);">，扩展了它的功能。在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">webpack</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">运行的生命周期中会广播出许多事件，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">plugin</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">可以监听这些事件，在合适的时机通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">webpack</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">提供的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">API</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">改变输出结果。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务</font>

### [](https://www.123fe.net/docs/base.html#_6-tree-shaking-%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88)<font style="color:rgb(44, 62, 80);">6 tree shaking 的原理是什么</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ES6 Module</font><font style="color:rgb(44, 62, 80);">引入进行静态分析，故而编译的时候正确判断到底加载了那些模块</font>
+ <font style="color:rgb(44, 62, 80);">静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码</font>

### [](https://www.123fe.net/docs/base.html#_7-common-js-%E5%92%8C-es6-%E4%B8%AD%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5%E7%9A%84%E5%8C%BA%E5%88%AB)<font style="color:rgb(44, 62, 80);">7 common.js 和 es6 中模块引入的区别</font>
<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">CommonJS 是一种模块规范，最初被应用于 Nodejs，成为 Nodejs 的模块规范。运行在浏览器端的 JavaScript 由于也缺少类似的规范，在 ES6 出来之前，前端也实现了一套相同的模块规范 (例如:</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">AMD</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">)，用来对前端模块进行管理。自 ES6 起，引入了一套新的</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ES6 Module</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">规范，在语言标准的层面上实现了模块功能，而且实现得相当简单，有望成为浏览器和服务器通用的模块解决方案。但目前浏览器对</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ES6 Module</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">兼容还不太好，我们平时在</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Webpack</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">中使用的</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">export</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">和</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">import</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">，会经过</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Babel</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">转换为</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CommonJS</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">规范</font>

**<font style="color:rgb(44, 62, 80);">在使用上的差别主要有：</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CommonJS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CommonJS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">模块是运行时加载，ES6 模块是编译时输出接口（静态编译）。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CommonJs</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是单个值导出，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ES6 Module</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">可以导出多个</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CommonJs</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是动态语法可以写在判断里，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ES6 Module</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">静态语法只能写在顶层</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CommonJs</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是当前模块，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ES6 Module</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">undefined</font>

### [](https://www.123fe.net/docs/base.html#_8-babel%E5%8E%9F%E7%90%86)<font style="color:rgb(44, 62, 80);">8 babel原理</font>
<font style="color:rgb(44, 62, 80);">Babel 是一个 JavaScript 编译器。他把最新版的 javascript 编译成当下可以执行的版本，简言之，利用 babel 就可以让我们在当前的项目中随意的使用这些新最新的 es6，甚至 es7 的语法</font>

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ES6、7</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">代码输入 -></font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">babylon</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">进行解析 -> 得到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">AST</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">（抽象语法树）-></font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">plugin</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">用b</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">abel-traverse</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">对</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">AST</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">树进行遍历转译 ->得到新的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">AST</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">树->用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">babel-generator</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">通过</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">AST</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">树生成</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ES5</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">代码</font>

**<font style="color:rgb(44, 62, 80);">Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）</font>**

+ **<font style="color:rgb(44, 62, 80);">解析</font>**<font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">将代码解析成抽象语法树（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">AST</font><font style="color:rgb(44, 62, 80);">），每个 js 引擎（比如 Chrome 浏览器中的 V8 引擎）都有自己的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">AST</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">解析器，而</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Babel</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Babylon</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">实现的。在解析过程中有两个阶段：词法分析和语法分析，词法分析阶段把字符串形式的代码转换为令牌（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">tokens</font><font style="color:rgb(44, 62, 80);">）流，令牌类似于</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">AST</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中节点；而语法分析阶段则会把一个令牌流转换成 AST 的形式，同时这个阶段会把令牌中的信息转换成 AST 的表述结构</font>
+ **<font style="color:rgb(44, 62, 80);">转换</font>**<font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">在这个阶段，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Babel</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">接受得到</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">AST</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">并通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">babel-traverse</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">对其进行深度优先遍历，在此过程中对节点进行添加、更新及移除操作。这部分也是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Babel</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">插件介入工作的部分</font>
+ **<font style="color:rgb(44, 62, 80);">生成</font>**<font style="color:rgb(44, 62, 80);"> 将经过转换的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">AST</font><font style="color:rgb(44, 62, 80);"> 通过 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">babel-generator</font><font style="color:rgb(44, 62, 80);">再转换成 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">js</font><font style="color:rgb(44, 62, 80);"> 代码，过程就是深度优先遍历整个 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">AST</font><font style="color:rgb(44, 62, 80);">，然后构建可以表示转换后代码的字符串。</font>

