**一、框架设计概览**

1.1框架设计概览

 命令式与声明式，vue封装了命令式的过程，使用方式为声明式

 命令式性能>声明式性能

 声明式可维护性》命令式可维护性

 vue采用运行时+编译时集合结构

 1.先把template模板转化为rander函数

 2.再利用rander函数，把虚拟DOM转化为真实DOM

 编译时：分析用户提供的内容

 运行时：提供灵活性

1.2 框架设计核心要素

 1.2.1 控制代码体积-设置环境变量/TreeShaking优化代码

 1.2.2 输出不同构建产物 runtime、esm、global

 1.2.3 错误提示与处理-统一错误处理接口 calWithErrorHandling

 1.2.4 提升用户开发体验 - 便于调试、降低使用成本

 1.2.5 良好的可维护性 - 框架本身的可维护性：使用TS编写、对TS的友好支持：大量的类型判断与处理

1.3 vue3的设计思路

 1.3.1 描述UI的形式

 声明式的模板描述:<div :id="sss" @click="onClick">

 命令式的rander函数 基本没yon

 1.3.2 初始渲染器

 本质：函数creatRenderder返回的renderer对象

 randerer对象包含（render渲染函数，有两个参数vnode:虚拟dom实例，cantainer:挂载的容器，真实dom）,作用就是把虚拟dom挂在到真实dom上

 1.3.3 组件的本质

 组件其实也是一组dom元素的封装，以组件为介质来完成一组一组的dom渲染

 1.3.4 模板（template）的工作原理

**二、响应式系统**

2.1 响应系统的作用与实现

 2.1.1 副作用函数 与 响应式数据

 副作用函数：修改全局变量产生的副作用

 响应式数据：修改时会导致视图变化

 2.1.2 响应式数据的实现

 核心逻辑：都是通过劫持数据的getter 和 setter 行为来实现

 vue2中使用的是Object.defineProperty来监听实现的

 vue3中通过Proxy代理来实现的

 2.1.3 构建完善的响应式系统-暂不接触

 2.1.4 调度系统

 响应性的可调度性：当数据更新的动作，触发副作用函数重新执行时，由能力决定：副作用函数effect的实行时机、次数以及方式

 实现原理：使用到Promise与对队列Queue; 基于Set构建了队列JobQueue，利用Promise的异步特性，控制执行顺序

 2.1.5 计算属性

 本质：一个属性值，当依赖的响应式数据发生变化时，重新计算 

 实现原理：通过调度系统的原理来实现

 2.1.6 惰性执行

 boolean类型的值，可以被添加到effect函数中，用来控制副作用函数的执行

 2.1.7 watch的实现原理

 本质：监听一个响应式数据，当数据发生变化时，通知并执行响应的回调函数

 实现原理：通过惰性执行来控制实现

 2.2.8 过期的副作用 

 问题描述：watch监听时，同一时间触发了两次回调函数A、B，B结果先返回，A结果后返回。正常情况需要的是B的结果

 解决方式：watch回调函数的第三个参数onInvalidate：该函数会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求

2.2 非原始值（对象）的响应性方案

 Proxy: 代理一个对象的（被代理的对象）的getter和setter行为，得到一个proxy实例（代理对象）

 Reflect:在Proxy使用this时，保证this的指向是proxy，从而正确执行次数的副作用

2.3 原始值（非对象）的响应性方案

 为什么会有Ref：reactive方法基于proxy实现，只能完成 对象 的响应性。针对非对象的响应性，需要通过ref构建

 实现原理：通过get、set函数标记符，让函数以属性调用的形式触发（当调用red.vaue时，本质上是触发value()的执行）

**三、渲染器**

3.1 渲染器的设计

 3.1.1 渲染器的基本概念： 

 1.渲染器：renderer对象 createRenderer的返回值

 2.渲染函数：render函数 createRenderer中的render函数，参数（虚拟dom,需要挂载的节点）

 3.2 挂载与更新

 3.2.1 dom节点操作 

 1.挂载： dom的初次渲染，通过creatElement新建、通过parentEl.insertBefore 插入

 2.更新：当响应式数据发生变化时，可能会设计到dom更新，具体情况看属性节点操作

 3.卸载：当节点不在被需要了，通过parentEl.removeChild

 3.2.2 属性节点操作

 1.属性： 分为html的标签元素和标签dom对象。

 某些元素支持的属性设置方式不同 

 2.事件操作：el.addEventListener（添加） el.rmoveEventListener（删除） vei(vue event invokers)：为addEventListener回调函数设置了一个value的属性方法，在回调中触发这个方法。用过更新该属性方法的形式，达到更新事件的目的。

 3.3 Diff算法

 本质：新旧虚拟dom节点对比

**四、组件化**

4.1 组件的实现原理

 1.组件对象表示为一个组件内容

 2.在vnode中 当type为组件对象时 表示这是一个组件

 3.渲染：实际上通过rander函数返回的vnode来进行渲染

 4. setup函数： 返回函数时直接作为render函数渲染。返回对象时，直接在render中访问暴露出来的对象数据

 5.插槽：是以组件中innerHtml存在，在vnode中以children属性存在。渲染过程中针对children渲染即可

 4.2 异步组件与函数式组件

 4.2.1 异步组件：页面性能、拆包、服务端下发组件

 4.2.2 函数时组件：没有状态的组件。本质上是一个函数，通过静态属性的形式添加props属性

 4.3 内置组件和模块

 4.3.1 KeepAlive

 作用：缓存一个组件，避免不断的销毁和创建

 原理：组件被卸载时-保存到一个容器中。组件被挂载时-从容器中取出组件

 4.3.2 Teleport

 作用：将插槽的内容渲染到其他位置

 原理：在渲染时抽出Teleport的渲染逻辑，在指定位置进行独立渲染

 4.3.3 Transition 

 作用：实现动画逻辑

 原理：在dom元素挂载时，将动销附加到dom元素上。在dom元素被卸载时，等待dom元素动效执行完成后米脂县卸载dom元素操作

**五、编译器**

 5.1 编译器的核心技术概述

 5.1.1 模板DSL编译器

vue的编译流程：模板 >词发分析 >语法分析 > 模板AST > Transformer > JavaScript AST > 代码生成> 渲染函数

 5.1.2 vue编译流程三大步

 1.parse：通过parse函数，把模板编译成AST对象

 2.transform：通过transform函数，把AST转换为JavaScript AST

 3.generate：通过generate函数，把JavaScript AST 转化为渲染函数（rander）

 5.2 解析器

 5.3 编译优化

**六、服务端渲染**

 6.1 同构渲染

 6.1.1 CSR、SSR以及同构渲染

 CSR：客户端渲染-由浏览器解析返回的html与数据

 SSR：服务端渲染-由服务器解析好Html文件与数据，再返回给浏览器直接渲染

 同构渲染：CSR(非首次渲染)+SSR(首次渲染)

 6.2 vue渲染逻辑

 6.2.1 服务端渲染，将虚拟dom/组件渲染为HTML字符串（在组件中解析vnode，进行字符串拼接）

 6.2.2 客户端激活原理 randerer.hydrate()

 1.为页面中的dom元素与虚拟节点对象之间建立联系

 2.为页面中的dom元素添加事件绑定

