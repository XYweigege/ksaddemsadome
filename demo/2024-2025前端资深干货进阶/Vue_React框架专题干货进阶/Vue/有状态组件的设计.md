<font style="color:rgb(44, 62, 80);">假设我们有如下模板：</font>

```html
<MyComponent>
  <div></div>
</MyComponent>
```

<font style="color:rgb(44, 62, 80);">由这段模板可知，我们为 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">MyComponent</font><font style="color:rgb(44, 62, 80);"> 组件提供了一个空的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">div</font><font style="color:rgb(44, 62, 80);"> 标签作为默认插槽内容，从DOM结构上看 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><MyComponent></font><font style="color:rgb(44, 62, 80);"> 标签有一个 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">div</font><font style="color:rgb(44, 62, 80);"> 标签作为子节点，通常我们可以将其编译为如下 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);">：</font><font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
</font>

```javascript
const compVNode = {
  flags: VNodeFlags.COMPONENT_STATEFUL_NORMAL,
  tag: MyComponent,
  children: {
    flags: VNodeFlags.ELEMENT,
    tag: 'div'
  }
}
```

<font style="color:rgb(44, 62, 80);">这其实没什么问题，但是我们更倾向于新建一个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">slots</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性来存储这些子节点，这在语义上更加贴切，所以我们希望将模板编译为如下</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);">：</font>



```javascript
const compVNode = {
  flags: VNodeFlags.COMPONENT,
  tag: MyComponent,
  children: null,
  slots: {
    // 默认插槽
    default: {
      flags: VNodeFlags.ELEMENT,
      tag: 'div'
    }
  }
}
```

<font style="color:rgb(44, 62, 80);">可以看到，如上</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">children</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性值为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">null</font><font style="color:rgb(44, 62, 80);">。当我们使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountComponent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数挂载如上</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">时，我们可以在</font>**<font style="color:rgb(44, 62, 80);">组件实例化之后</font>**<font style="color:rgb(44, 62, 80);">并且在</font>**<font style="color:rgb(44, 62, 80);">组件的渲染函数执行之前</font>**<font style="color:rgb(44, 62, 80);">将</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">compVNode.slots</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">添加到组件实例对象上，这样当组件的渲染函数执行的时候，就可以访问插槽数据：</font>

<font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
</font>

```javascript
function mountComponent(vnode, container) {
  // 创建组件实例
  const instance = new vnode.tag()

  // 设置 slots
  instance.$slots = vnode.slots

  // 渲染
  instance.$vnode = instance.render()
  // 挂载
  mountElement(instance.$vnode, container)

  vnode.ref && vnode.ref(instance)
}
```

<font style="color:rgb(44, 62, 80);">在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">MyComponent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">组件的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">render</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数内，我们就可以通过组件实例访问</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">slots</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">数据：</font>

<font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
</font>

```javascript
class MyComponent {
  render() {
    return {
      flags: VNodeFlags.ELEMENT,
      tag: 'h1'
        children: this.$slots.default
  }
}
}
```

<font style="color:rgb(44, 62, 80);">实际上，这就是普通插槽的实现原理，至于作用域插槽(</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">scopedSlots</font><font style="color:rgb(44, 62, 80);">)，与普通插槽并没有什么本质的区别，我们知道作用域插槽可以访问子组件的数据，在实现上来看其实就是函数传参：</font>

<font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);"></font>

```javascript
class MyComponent {
  render() {
    return {
      flags: VNodeFlags.ELEMENT,
      tag: 'h1'
        // 插槽变成了函数，可以传递参数
        children: this.$slots.default(1)
  }
}
}
```

<font style="color:rgb(44, 62, 80);">如上代码所示，只要</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this.$slots.default</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是函数即可实现，所以在模板编译时，我们最终需要得到如下</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);">：</font>

<font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
</font>

```javascript
const compVNode = {
  flags: VNodeFlags.COMPONENT,
  tag: MyComponent,
  children: null,
  slots: {
    // 作用域插槽，可以接受组件传递过来的数据
    default: (arg) => {
      const tag = arg === 1 ? 'div' : 'h1'
      return {
        flags: VNodeFlags.ELEMENT,
        tag
      }
    }
  }
}
```

<font style="color:rgb(44, 62, 80);">现在你应该明白为什么普通插槽和作用域插槽本质上并没有区别了，因为普通插槽也可以是函数，只是不接收参数罢了。这么看的话其实普通插槽是作用域插槽的子集，那为什么不将它们合并呢？没错从</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Vue2.6</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">起已经将之合并，所有插槽在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中都是函数，一个返回</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的函数。</font>

**<font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);">TIP</font>**

<font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);">用过</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">React</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);"> </font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);">的朋友，这让你想起</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Render Prop</font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);"> </font><font style="color:rgb(44, 62, 80);background-color:rgb(243, 245, 247);">了吗！</font>

## [](https://www.123fe.net/principle-docs/vue/03-%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1.html#key-%E5%92%8C-ref)key 和 ref
<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">key</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">就像</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的唯一标识，用于</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">diff</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">算法的优化，它可以是数字也可以是字符串：</font>



```javascript
{
  flags: VNodeFlags.ELEMENT_HTML,
    tag: 'li',
    key: 'li_0'
}
```

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ref</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的设计是为了提供一种能够拿到真实DOM的方式，当然如果将</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ref</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">应用到组件上，那么拿到的就是组件实例，我们通常会把</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ref</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">设计成一个函数，假设我们有如下模板：</font>

```html
<div :ref="el => elRef = el"></div>
```

<font style="color:rgb(44, 62, 80);">我们可以把这段模板编译为如下</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);">：</font>



```javascript
const elementVNode = {
  flags: VNodeFlags.ELEMENT_HTML,
  tag: 'div',
  ref: el => elRef = el
}
```

<font style="color:rgb(44, 62, 80);">在使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountElement</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数挂载如上</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">时，可以轻松的实现</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ref</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">功能：</font>



```javascript
function mountElement(vnode, container) {
  const el = document.createElement(vnode.tag)
  container.appendChild(el)
  vnode.ref && vnode.ref(el)
}
```

<font style="color:rgb(44, 62, 80);">如果挂载的是组件而非普通标签，那么只需要将组件实例传递给</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vnode.ref</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数即可：</font>



```javascript
function mountComponent(vnode, container) {
  // 创建组件实例
  const instance = new vnode.tag()
  // 渲染
  instance.$vnode = instance.render()
  // 挂载
  mountElement(instance.$vnode, container)

  vnode.ref && vnode.ref(instance)
}
```

## [](https://www.123fe.net/principle-docs/vue/03-%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1.html#parentvnode-%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8)parentVNode 以及它的作用
<font style="color:rgb(44, 62, 80);">与</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">slots</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性相同，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">parentVNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性也是给组件的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">准备的，组件的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">为什么需要这两个属性呢？它俩的作用又是什么呢？想弄清楚这些，我们至少要先弄明白：</font>**<font style="color:rgb(44, 62, 80);">一个组件所涉及的</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(44, 62, 80);">都有哪些</font>**<font style="color:rgb(44, 62, 80);">。什么意思呢？看如下模板思考一个问题：</font>

```html
<template>
  <div>
    <MyComponent />
  </div>
</template>
```

<font style="color:rgb(44, 62, 80);">从这个模板来看</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">MyComponent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">组件至少涉及到两个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);">，第一个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是标签</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><MyComponent /></font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的描述，其次</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">MyComponent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">组件本身也有要渲染的内容，这就是第二个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);">。</font>

+ <font style="color:rgb(44, 62, 80);">第一个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">用来描述</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><MyComponent /></font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">标签：</font>

```plain
{
  // 省略...
  tag: MyComponent
}
```

+ <font style="color:rgb(44, 62, 80);">第二个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是组件渲染内容的描述，即组件的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">render</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数产出的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);">：</font>

```plain
class MyComponent {
  render () {
    return {/* .. */} // 产出的 VNode
  }
}
```

<font style="color:rgb(44, 62, 80);">组件实例的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">$vnode</font><font style="color:rgb(44, 62, 80);"> 属性值就是组件 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">render</font><font style="color:rgb(44, 62, 80);"> 函数产出的 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);">，这通过如下代码可以一目了然：</font><font style="color:rgb(44, 62, 80);background-color:rgb(40, 44, 52);">  
</font>

```javascript
function mountComponent(vnode, container) {
  // 创建组件实例
  const instance = new vnode.tag()
  // 渲染，$vnode 的值就是组件 render 函数产出的 VNode
  instance.$vnode = instance.render()
  // 挂载
  mountElement(instance.$vnode, container)

  vnode.ref && vnode.ref(instance)
}
```

<font style="color:rgb(44, 62, 80);">而</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">instance.$vnode.parentVNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的值就是用来描述组件(如：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><MyComponent /></font><font style="color:rgb(44, 62, 80);">)标签的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);">，我们只需在如上代码中添加一行代码即可实现：</font>

=

```javascript
function mountComponent(vnode, container) {
  // 创建组件实例
  const instance = new vnode.tag()
  // 渲染，$vnode 的值就是组件 render 函数产出的 VNode
  instance.$vnode = instance.render()
  // vnode 就是用来描述组件标签的 VNode
  instance.$vnode.parentVNode = vnode
  // 挂载
  mountElement(instance.$vnode, container)

  vnode.ref && vnode.ref(instance)
}
```

<font style="color:rgb(44, 62, 80);">同时我们也可以在组件实例上添加</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">$parentVNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性，让其同样引用组件的标签描述：</font>



```javascript
function mountComponent(vnode, container) {
  // 创建组件实例
  const instance = new vnode.tag()
  // 渲染，$vnode 的值就是组件 render 函数产出的 VNode
  instance.$vnode = instance.render()
  // vnode 就是用来描述组件标签的 VNode
  instance.$parentVNode = instance.$vnode.parentVNode = vnode
  // 挂载
  mountElement(instance.$vnode, container)

  vnode.ref && vnode.ref(instance)
}
```

<font style="color:rgb(44, 62, 80);">组件的实例为什么需要引用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">parentVNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">呢？这是因为组件的事件监听器都在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">parentVNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">上，如下模板所示：</font>

```html
<MyComponent @click="handleClick" />
```

<font style="color:rgb(44, 62, 80);">这段模板可以用如下</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">描述：</font>

```javascript
const parentVNode = {
  // 省略...
  tag: MyComponent,
  data: {
    onclick: () => handleClick()
  }
}
```

<font style="color:rgb(44, 62, 80);">当你在组件中发射(</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">emit</font><font style="color:rgb(44, 62, 80);">)事件时，就需要去</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">parentVNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中找到对应的事件监听器并执行：</font>

```javascript
// 组件实例的 $emit 实现
class MyComponent {
  $emit(eventName, ...payload) {
    // 通过 parentVNode 拿到其 VNodeData
    const parentData = this.$parentVNode.data
    // 执行 handler
    parentData[`on${eventName}`](payload)
  },

  handleClick() {
    // 这里就可以通过 this.$emit 发射事件
    this.$emit('click', 1)
  }
}
```

<font style="color:rgb(44, 62, 80);">实际上，这就是事件的实现思路。由于</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">$emit</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是框架层面的设计，所以我们在设计框架时可以提供一个最基本的组件，将框架层面的设计都归纳到该组件中：</font>

```javascript
class Component {
  $emit(eventName, ...payload) {
    // 通过 parentVNode 拿到其 VNodeData
    const parentData = this.$parentVNode.data
    // 执行 handler
    parentData[`on${eventName}`](payload)
  }
  // 其他......
}
```

<font style="color:rgb(44, 62, 80);">这样框架的使用者在开发组件时，只需要继承我们的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Component</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">即可：</font>

```javascript
// 用户的代码
import { Component } from 'vue'

class MyComponent extends Component {
  handleClick() {
    // 直接使用即可
    this.$emit('click', 1)
  }
}
```

## [](https://www.123fe.net/principle-docs/vue/03-%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1.html#contextvnode)contextVNode
<font style="color:rgb(44, 62, 80);">我们已经知道了与一个组件相关的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">有两个，一个是组件自身产出的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);">，可以通过组件实例的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">instance.$vnode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">访问，另一个是当使用组件时用来描述组件标签的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);">，我们可以通过组件实例的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">instance.$parentVNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">访问，并且：</font>

```javascript
instance.$vnode.parentVNode === instance.$parentVNode
```

<font style="color:rgb(44, 62, 80);">那么</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">contextVNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是什么呢？实际上</font>**<font style="color:rgb(44, 62, 80);">子组件标签描述的</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode.contextVNode</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(44, 62, 80);">是父组件的标签描述</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font>**<font style="color:rgb(44, 62, 80);">，或者说</font>**<font style="color:rgb(44, 62, 80);">子组件实例的</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">$parentVNode.contextVNode</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(44, 62, 80);">是父组件实例的</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">$parentVNode</font>**<font style="color:rgb(44, 62, 80);">，假设根组件渲染了</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Foo</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">组件，而</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Foo</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">组件又渲染</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Bar</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">组件，此时就形成了一条父子链：</font>**<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Bar</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(44, 62, 80);">组件的父组件是</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Foo</font>**<font style="color:rgb(44, 62, 80);">。</font>

<font style="color:rgb(44, 62, 80);">为什么子组件的标签描述</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">需要引用父组件的标签描述</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">呢？这是因为一个组件的标签描述</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中存储着该组件的实例对象，即</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode.children</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性。还记得之前我们讲到过，对于组件来说，它的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode.children</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性会存储组件实例对象吗。这样通过这一层引用关系，子组件就知道它的父组件是谁，同时父组件也知道它有哪些子组件。</font>

<font style="color:rgb(44, 62, 80);">语言描述会有些抽象，我们拿具体案例演示一下，假设我们的根组件有如下模板：</font>

```html
<!-- 根组件模板 -->
<template>
  <Foo/>
</template>
```

<font style="color:rgb(44, 62, 80);">它对应的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">如下：</font>

```javascript
const FooVNode = {
  flags: VNodeFlags.COMPONENT,
  tag: Foo, // Foo 指的是 class Foo {}
}
```

<font style="color:rgb(44, 62, 80);">接着</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Foo</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">组件的模板如下，它渲染了</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Bar</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">组件：</font>

```html
<!-- 组件 Foo 的模板 -->
<template>
  <Bar/>
</template>
```

<font style="color:rgb(44, 62, 80);">它对应的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">如下：</font>

```javascript
const BarVNode = {
  flags: VNodeFlags.COMPONENT,
  tag: Bar, // Foo 指的是 class Bar {}
}
```

<font style="color:rgb(44, 62, 80);">我们使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountComponent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数挂载</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">FooVNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">组件：</font>



```javascript
mountComponent(FooVNode, container)

function mountComponent(vnode, container) {
  // 创建 Foo 组件实例
  const instance = new vnode.tag()
  // 渲染，instance.$vnode 的值就是 BarVNode
  instance.$vnode = instance.render()
  // 使用 mountComponent 函数递归挂载 BarVNode
  mountComponent(instance.$vnode, container)

  vnode.ref && vnode.ref(instance)
}
```

<font style="color:rgb(44, 62, 80);">如上代码所示，首先我们调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountComponent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数挂载</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">FooVNode</font><font style="color:rgb(44, 62, 80);">，会创建</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Foo</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">组件实例，接着调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Foo</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">组件实例的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">render</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数得到</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Foo</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">组件产出的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);">，这其实就是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">BarVNode</font><font style="color:rgb(44, 62, 80);">，由于</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">BarVNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的类型也是组件，所以我们会递归调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountComponent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">挂载</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">BarVNode</font><font style="color:rgb(44, 62, 80);">，最终</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountComponent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数会执行两次。接下来我们为使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">contextVNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">完善上面的代码，看看如何来建立起父子链：</font>



```javascript
mountComponent(FooVNode, container)

function mountComponent(vnode, container, contextVNode = null) {
  // 创建组件实例
  const instance = new vnode.tag()

  if (contextVNode) {
    const parentComponent = contextVNode.children
    instance.$parent = parentComponent
    parentComponent.$children.push(instance)
    instance.$root = parentComponent.$root
  } else {
    instance.$root = instance
  }

  // 渲染
  instance.$vnode = instance.render()
  // 使用 mountComponent 函数递归挂载
  mountComponent(instance.$vnode, container, vnode)

  vnode.ref && vnode.ref(instance)
}
```

<font style="color:rgb(44, 62, 80);">如上高亮代码所示，我们为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountComponent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数添加了第三个参数</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">contextVNode</font><font style="color:rgb(44, 62, 80);">，我们可以一下这个过程发生了什么：</font>

+ <font style="color:rgb(44, 62, 80);">1、初次调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountComponent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">挂载</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">FooVNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">时，没有传递第三个参数，所以</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">contextVNode = null</font><font style="color:rgb(44, 62, 80);">，这时说明当前挂载的组件就是根组件，所以我们让当前组件实例的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">$root</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性值引用其自身。</font>
+ <font style="color:rgb(44, 62, 80);">2、当递归调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mountComponent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">挂载</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">BarVNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">时，我们传递了第三个参数，并且点三个参数是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">FooVNode</font><font style="color:rgb(44, 62, 80);">。此时</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">contextVNode = FooVNode</font><font style="color:rgb(44, 62, 80);">，我们通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">contextVNode.children</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">即可拿到</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Foo</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">组件的实例，并把它赋值给</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Bar</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">组件实例的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">$parent</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性，同时把</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Bar</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">组件实例添加到</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Foo</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">组件实例的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">$children</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">数组中，这样这条父子链就成功建立了。</font>

<font style="color:rgb(44, 62, 80);">实际上，除了组件实例间建立父子关系，组件的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">间也可以建立父子关系，只需要增加一行代码即可：</font>



```javascript
mountComponent(FooVNode, container)

function mountComponent(vnode, container, contextVNode = null) {
  vnode.contextVNode = contextVNode
  // 省略...
}
```

<font style="color:rgb(44, 62, 80);">为什么要在组件的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">上也建立这种父子联系呢？答案是在其他地方有用到，这么做就是为了在某些情况下少传递一些参数，直接通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">之间的联系找到我们想要的信息即可。另外在如上的演示中，我们省略了避开函数式组件的逻辑，因为函数式组件没有组件实例，所谓的父子关系只针对于有状态组件。实现逻辑很简单，就是通过一个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">while</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">循环</font>**<font style="color:rgb(44, 62, 80);">沿着父子链一直向上找到第一个非函数式组件，并把该组件的实例作为当前组件实例的</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">$parent</font>****<font style="color:rgb(44, 62, 80);"> </font>****<font style="color:rgb(44, 62, 80);">即可</font>**<font style="color:rgb(44, 62, 80);">。</font>

## [](https://www.123fe.net/principle-docs/vue/03-%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1.html#el)el
<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">既然是真实DOM的描述，那么理所应当的，当它被渲染完真实DOM之后，我们需要将真实DOM对象的引用添加到</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性上。由于</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">具有不同的类型，不同类型的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">其</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性所引用的真实DOM对象也不同，下图展示了所有</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">类型：</font>

+ <font style="color:rgb(44, 62, 80);">1、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">html/svg</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">标签</font>

<font style="color:rgb(44, 62, 80);">其</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性值为真实DOM元素的引用：</font>

```javascript
{
  tag: 'div',
    el: div 元素的引用 // 如 document.createElement('div')
}
```

+ <font style="color:rgb(44, 62, 80);">2、组件</font>

<font style="color:rgb(44, 62, 80);">其</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性值为组件本身所渲染真实DOM的根元素：</font>

```javascript
{
  tag: MyComponent,
    el: instance.$vnode.el
}
```

+ <font style="color:rgb(44, 62, 80);">3、纯文本</font>

<font style="color:rgb(44, 62, 80);">其</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性值为文本元素的引用：</font>

```javascript
{
  tag: null,
    children: 'txt',
    el: 文本元素的引用 // 如 document.createTextNode('txt')
}
```

+ <font style="color:rgb(44, 62, 80);">4、Fragment</font>

<font style="color:rgb(44, 62, 80);">其</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性值为片段中第一个DOM元素的引用：</font>

```javascript
{
  tag: null,
    children: [
    {
      tag: 'h1'
    },
    {
      tag: 'h2'
    }
  ],
    el: h1 元素的引用而非 h2
}
```

<font style="color:rgb(44, 62, 80);">当然片段本身可能是一个空数组，即</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">children</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性值为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">[]</font><font style="color:rgb(44, 62, 80);">，此时代表该片段不渲染任何东西，但在框架设计中，我们会渲染一个空的文本节点占位，所以此时</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性值为该占位的空文本元素的引用：</font>

```bash
{
  tag: null,
  children: [],
  el: 占位的空文本元素 // document.createTextNode('')
}
```

+ <font style="color:rgb(44, 62, 80);">5、Portal</font>

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Portal</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">比较特殊，根据</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Portal</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">寓意，其内容可以被渲染到任何地方，但其真正的挂载点会有一个空文本节点占位，所以</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Portal</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">VNode.el</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">属性值引用的始终是这个空文本节点。当然这是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vue3</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的设计，理论上将我们完全可以做到让</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">el</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">引用真正的挂载容器元素。</font>

```javascript
{
  tag: null,
    children: [...],
    el: 占位的空文本元素 // document.createTextNode('')
}
```

