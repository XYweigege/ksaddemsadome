### <font style="color:rgb(44, 62, 80);">研发的工作流程是怎么样的</font>
**<font style="color:rgb(44, 62, 80);">流程图</font>**

<font style="color:rgb(44, 62, 80);">下图是完整的大厂前端项目研发流程图</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786370245-957e12cd-10f0-4496-9858-b90b718f6613.png)

**<font style="color:rgb(44, 62, 80);">项目角色</font>**

+ <font style="color:rgb(44, 62, 80);">项目委员会：这是一个很虚的角色，即能确定项目是否要做的那帮人，有时候可能就是一个高级经理就能拍板确定。和我们实际开发没啥关系，不用去关心他。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">PM</font><font style="color:rgb(44, 62, 80);">：产品经理，也是一个项目的推动者，即兼职项目经理的角色。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">UE</font><font style="color:rgb(44, 62, 80);">：交互设计师，负责页面布局、交互的设计，不负责视图的细节。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">UI</font><font style="color:rgb(44, 62, 80);">：视觉设计师，交互确定之后，设计页面样式。注意，很多情况下，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">UE</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">UI</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">是一个人。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">RD</font><font style="color:rgb(44, 62, 80);">：后端开发人员。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CRD</font><font style="color:rgb(44, 62, 80);">：客户端开发人员，安卓和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ios</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">都是。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">FE</font><font style="color:rgb(44, 62, 80);">：前端开发人员。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">QA</font><font style="color:rgb(44, 62, 80);">：测试人员。</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">OP</font><font style="color:rgb(44, 62, 80);">：服务器运维人员，一般负责审批上线单</font>

**<font style="color:rgb(44, 62, 80);">主要流程</font>**

**<font style="color:rgb(44, 62, 80);">项目立项</font>**

+ <font style="color:rgb(44, 62, 80);">主要是各个部门的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">leader</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">确定项目要做了，就是“拍板儿”确定。此时不需要工程师参与，因为决定权在于他们。项目立项时没有任何详细的信息，如需求、设计图等，都要后面继续做。</font>
+ **<font style="color:rgb(44, 62, 80);">编写需求和需求评审</font>**
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">PM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">根据项目的背景和目标，编写需求文档，画原型图（不是</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">UI</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">设计图），然后叫各个角色开会评审。</font>
    - <font style="color:rgb(44, 62, 80);">你如果作为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">FE</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">角色去参与评审，要积极提出自己的问题和建议。需求评审不一定一次通过。</font>
    - <font style="color:rgb(44, 62, 80);">如果此时</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">PM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">跟你要工作排期，你不要立即回复。回去跟你的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">leader</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">商量之后，给一个谨慎的排期。</font>
+ **<font style="color:rgb(44, 62, 80);">编写技术方案</font>**
    - <font style="color:rgb(44, 62, 80);">需求指导设计，设计指导开发。先做技术方案设计，写文档，待评审之后再开发。</font>
+ **<font style="color:rgb(44, 62, 80);">技术方案评审</font>**
    - <font style="color:rgb(44, 62, 80);">技术方案写完之后，要叫</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">leader</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">，以及其他技术角色人员一起评审。</font>
        * <font style="color:rgb(44, 62, 80);">第一，和其他技术人员确定接口格式，是否都能认同</font>
        * <font style="color:rgb(44, 62, 80);">第二，让</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">leader</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">或者架构师确定这个设计有没有漏洞、安全问题等</font>
+ **<font style="color:rgb(44, 62, 80);">交互视觉设计和评审</font>**
    - <font style="color:rgb(44, 62, 80);">需求评审通过之后，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">UE</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">UI</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">就开始出设计稿。做完设计稿之后，会叫相关开发人员参与评审。和需求评审一样，你要提出自己的问题和建议。</font>
+ **<font style="color:rgb(44, 62, 80);">开发</font>**
    - <font style="color:rgb(44, 62, 80);">上述评审都结束之后，才可以进入开发阶段。开发时要注意开发规范，及时</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">code review</font><font style="color:rgb(44, 62, 80);">，写单元测试。</font>
+ **<font style="color:rgb(44, 62, 80);">视觉联调</font>**
    - <font style="color:rgb(44, 62, 80);">网页界面开发完成之后，要找</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">UI</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">人员来视觉联调，让他们确认是否可以。如果不可以，就直接修改，直到评审通过。</font>
    - <font style="color:rgb(44, 62, 80);">这一步要尽早执行，不要等待临上线了，再去调整</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">UI</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">界面。</font>
+ **<font style="color:rgb(44, 62, 80);">程序联调</font>**
    - <font style="color:rgb(44, 62, 80);">代码功能开发完之后，要和其他相关技术人员（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">RD</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CRD</font><font style="color:rgb(44, 62, 80);">）进行接口联调。就是在开发环境下，先把系统对接起来，看看会不会出错。</font>
    - <font style="color:rgb(44, 62, 80);">注意，接口联调不是测试，不用太过于项目，能把最基本的功能跑通即可。</font>
+ **<font style="color:rgb(44, 62, 80);">自测</font>**
    - <font style="color:rgb(44, 62, 80);">对于自己开发的功能，一定要自己按照需求测试一遍。不要求测试的很详细，至少也把基本功能跑通。</font>
    - <font style="color:rgb(44, 62, 80);">这一步是为了防止提测之后被</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">QA</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">发现基本功能不可用，就很尴尬。人家会觉得你不靠谱。</font>
+ **<font style="color:rgb(44, 62, 80);">提测</font>**
    - <font style="color:rgb(44, 62, 80);">自测完成之后，即可把代码提测给</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">QA</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">。这一步很关键，要发邮件，抄送给项目组的相关成员。</font>
+ **<font style="color:rgb(44, 62, 80);">测试</font>**
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">QA</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">进行详细的功能测试。测试期间会有</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">bug</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">反馈，要及时修复</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">bug</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">，并及时让</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">QA</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">回归测试。</font>
    - <font style="color:rgb(44, 62, 80);">测试期间要积极和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">QA</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">沟通，最好每天都开一个站会。</font>
+ **<font style="color:rgb(44, 62, 80);">上线 & 回归测试</font>**
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">QA</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">测试完成会发邮件全体通报测试通过，测试就可以准备上线。</font>
    - <font style="color:rgb(44, 62, 80);">上线之后要及时和</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">QA</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">组织回归测试，待回归测试完成之后才可以通知：上线完成</font>
+ **<font style="color:rgb(44, 62, 80);">项目总结（可选）</font>**
    - <font style="color:rgb(44, 62, 80);">回顾一下经过，总结一下得失，积累一点经验，这样才能慢慢成长</font>

### [](https://www.123fe.net/docs/base/high-frequency.html#%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E9%A1%B9%E7%9B%AE%E9%9A%BE%E7%82%B9-%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84)<font style="color:rgb(44, 62, 80);">工作中遇到过哪些项目难点，是如何解决的</font>
**<font style="color:rgb(44, 62, 80);">遇到问题要注意积累</font>**

+ <font style="color:rgb(44, 62, 80);">每个人都会遇到问题，总有几个问题让你头疼</font>
+ <font style="color:rgb(44, 62, 80);">日常要注意积累，解决了问题要自己写文章复盘</font>

**<font style="color:rgb(44, 62, 80);">如果之前没有积累</font>**

+ <font style="color:rgb(44, 62, 80);">回顾一下半年之内遇到的难题</font>
+ <font style="color:rgb(44, 62, 80);">思考当时解决方案，以及解决之后的效果</font>
+ <font style="color:rgb(44, 62, 80);">写一篇文章记录一下，答案就有了</font>

**<font style="color:rgb(44, 62, 80);">答案模板</font>**

+ <font style="color:rgb(44, 62, 80);">描述问题：背景 + 现象 + 造成的影响</font>
+ <font style="color:rgb(44, 62, 80);">问题如何被解决：分析 + 解决</font>
+ <font style="color:rgb(44, 62, 80);">自己的成长：学到了什么 + 以后如何避免</font>

**<font style="color:rgb(44, 62, 80);">一个示例</font>**

+ <font style="color:rgb(44, 62, 80);">问题：编辑器只能回显JSON格式的数据，而不支持老版本的HTML格式</font>
+ <font style="color:rgb(44, 62, 80);">解决：将老版本的HTML反解析成JSON格式即可解决</font>
+ <font style="color:rgb(44, 62, 80);">成长：要考虑完整的输入输出 + 考虑旧版本用户 + 参考其他产品</font>

### [](https://www.123fe.net/docs/base/high-frequency.html#%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96)<font style="color:rgb(44, 62, 80);">前端性能优化</font>
**<font style="color:rgb(44, 62, 80);">前言</font>**

+ <font style="color:rgb(44, 62, 80);">是一个综合性问题，没有标准答案，但要求尽量全面</font>
+ <font style="color:rgb(44, 62, 80);">某些细节可能会问：防抖、节流等</font>

**<font style="color:rgb(44, 62, 80);">性能优化原则</font>**

+ <font style="color:rgb(44, 62, 80);">多使用内存、缓存或其他方法</font>
+ <font style="color:rgb(44, 62, 80);">减少</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CPU</font><font style="color:rgb(44, 62, 80);">计算量，减少网络加载耗时</font>

**<font style="color:rgb(44, 62, 80);">从何入手</font>**

+ **<font style="color:rgb(44, 62, 80);">让加载更快</font>**
    - <font style="color:rgb(44, 62, 80);">减少资源体积：压缩代码</font>
    - <font style="color:rgb(44, 62, 80);">减少访问次数：合并代码，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">SSR</font><font style="color:rgb(44, 62, 80);">服务端渲染，缓存</font>
        * **<font style="color:rgb(44, 62, 80);">SSR</font>**
            + <font style="color:rgb(44, 62, 80);">服务端渲染：将网页和数据一起加载，一起渲染</font>
            + <font style="color:rgb(44, 62, 80);">非</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">SSR</font><font style="color:rgb(44, 62, 80);">模式（前后端分离）：先加载网页，在加载数据，在渲染数据</font>
        * **<font style="color:rgb(44, 62, 80);">缓存</font>**
            + <font style="color:rgb(44, 62, 80);">静态资源加</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">hash</font><font style="color:rgb(44, 62, 80);">后缀，根据文件内容计算</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">hash</font>
            + <font style="color:rgb(44, 62, 80);">文件内容不变，则</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">hash</font><font style="color:rgb(44, 62, 80);">不变，则</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">url</font><font style="color:rgb(44, 62, 80);">不变</font>
            + <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">url</font><font style="color:rgb(44, 62, 80);">和文件不变，则会自动触发</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">http</font><font style="color:rgb(44, 62, 80);">缓存机制，返回</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">304</font><font style="color:rgb(44, 62, 80);"> </font>![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786374968-67ea896a-e699-4a4c-997a-913472cf83ab.png)
    - <font style="color:rgb(44, 62, 80);">减少请求时间：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DNS</font><font style="color:rgb(44, 62, 80);">预解析，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CDN</font><font style="color:rgb(44, 62, 80);">，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP2</font>
        * **<font style="color:rgb(44, 62, 80);">DNS预解析</font>**
            + <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DNS</font><font style="color:rgb(44, 62, 80);">解析：将域名解析为</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">IP</font><font style="color:rgb(44, 62, 80);">地址</font>
            + <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DNS</font><font style="color:rgb(44, 62, 80);">预解析：提前解析域名，将域名解析为</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">IP</font><font style="color:rgb(44, 62, 80);">地址</font>
            + <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DNS</font><font style="color:rgb(44, 62, 80);">预解析的方式：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><link rel="dns-prefetch" href="//www.baidu.com"></font>
        * **<font style="color:rgb(44, 62, 80);">CDN</font>**
            + <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CDN</font><font style="color:rgb(44, 62, 80);">：内容分发网络，将资源分发到离用户最近的服务器上</font>
            + <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CDN</font><font style="color:rgb(44, 62, 80);">的优点：加快资源加载速度，减少服务器压力</font>
            + <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CDN</font><font style="color:rgb(44, 62, 80);">的缺点：增加了网络延迟，增加了服务器成本</font><font style="color:rgb(44, 62, 80);"> </font>![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786377825-375d404b-2d57-40a0-b158-59d5931695f7.png)
        * **<font style="color:rgb(44, 62, 80);">HTTP2</font>**
            + <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP2</font><font style="color:rgb(44, 62, 80);">：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP</font><font style="color:rgb(44, 62, 80);">协议的下一代版本</font>
            + <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP2</font><font style="color:rgb(44, 62, 80);">的优点：多路复用，二进制分帧，头部压缩，服务器推送</font>
+ **<font style="color:rgb(44, 62, 80);">让渲染更快</font>**
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CSS</font><font style="color:rgb(44, 62, 80);">放在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">head</font><font style="color:rgb(44, 62, 80);">，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">放在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">body</font><font style="color:rgb(44, 62, 80);">下面</font>
    - <font style="color:rgb(44, 62, 80);">尽早开始执行</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">，用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOMContentLoaded</font><font style="color:rgb(44, 62, 80);">触发</font>

```javascript
window.addEventListener('load',function() {
  // 页面的全部资源加载完才会执行，包括图片、视频等
})
window.addEventListener('DOMContentLoaded',function() {
  // DOM渲染完才执行，此时图片、视频等可能还没有加载完
})
```

    - <font style="color:rgb(44, 62, 80);">懒加载（图片懒加载，上滑加载更多）</font><font style="color:rgb(44, 62, 80);"> </font>![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786373698-68fbaeb3-99af-4ce1-a139-7e0ddf687bf7.png)
    - <font style="color:rgb(44, 62, 80);">对</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">查询进行缓存</font><font style="color:rgb(44, 62, 80);"> </font>![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786375070-9f9c6914-5617-41c0-98c6-aece32b76216.png)
    - <font style="color:rgb(44, 62, 80);">频繁</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">操作，合并到一起插入到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">结构</font><font style="color:rgb(44, 62, 80);"> </font>![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786373950-a7b7eac9-72d1-4d5a-acc1-086bad072cc4.png)
    - <font style="color:rgb(44, 62, 80);">节流、防抖，让渲染更流畅</font>
        * **<font style="color:rgb(44, 62, 80);">防抖</font>**
            + <font style="color:rgb(44, 62, 80);">防抖动是将多次执行变为</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">最后一次执行</font>
            + <font style="color:rgb(44, 62, 80);">适用于：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">input</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">click</font><font style="color:rgb(44, 62, 80);">等</font>

```javascript
const input = document.getElementById('input')
// 防抖
function debounce(fn, delay = 500) {
  // timer 是闭包中的
  let timer = null
  // 这里返回的函数是每次用户实际调用的防抖函数
  // 如果已经设定过定时器了就清空上一次的定时器
  // 开始一个新的定时器，延迟执行用户传入的方法
  return function () {
    if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      fn.apply(this, arguments)
      timer = null
    }, delay)
  }
}
input.addEventListener('keyup', debounce(function (e) {
  console.log(e.target)
  console.log(input.value)
}, 600))
```

        * **<font style="color:rgb(44, 62, 80);">节流</font>**
            + <font style="color:rgb(44, 62, 80);">节流是将多次执行变成</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">每隔一段时间执行</font>
            + <font style="color:rgb(44, 62, 80);">适用于：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">resize</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">scroll</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mousemove</font><font style="color:rgb(44, 62, 80);">等</font>

```plain
const div = document.getElementById('div')
// 节流
function throttle(fn, delay = 100) {
  let timer = null

  return function () {
    if (timer) { // 当前有任务了，直接返回
      return
    }
    timer = setTimeout(() => {
      fn.apply(this, arguments)
      timer = null
    }, delay)
  }
}
// 拖拽
div.addEventListener('drag', throttle(function (e) {
    console.log(e.offsetX, e.offsetY)
}))
```

### [](https://www.123fe.net/docs/base/high-frequency.html#%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF)<font style="color:rgb(44, 62, 80);">前端常用的设计模式和使用场景</font>
+ **<font style="color:rgb(44, 62, 80);">工厂模式</font>**
    - <font style="color:rgb(44, 62, 80);">用一个工厂函数来创建实例，使用的时候隐藏</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">new</font><font style="color:rgb(44, 62, 80);">，可在工厂函数中使用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">new</font><font style="color:rgb(44, 62, 80);">（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">function factory(a,b,c) {return new Foo()}</font><font style="color:rgb(44, 62, 80);">）</font>
    - <font style="color:rgb(44, 62, 80);">如</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">jQuery</font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">$</font><font style="color:rgb(44, 62, 80);">函数：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">$</font><font style="color:rgb(44, 62, 80);">等于是在内部使用了</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">new JQuery</font><font style="color:rgb(44, 62, 80);">实例（用工厂函数</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">$</font><font style="color:rgb(44, 62, 80);">包裹了一下），可以直接使用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">$(div)</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">react</font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">createElement</font>
+ **<font style="color:rgb(44, 62, 80);">单例模式</font>**
    - <font style="color:rgb(44, 62, 80);">全局唯一的实例（无法生成第二个）</font>
    - <font style="color:rgb(44, 62, 80);">如</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Vuex</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Redux</font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">store</font>
    - <font style="color:rgb(44, 62, 80);">如全局唯一的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">dialog</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">modal</font>
    - <font style="color:rgb(44, 62, 80);">演示</font>

```javascript
// 通过class实现单例构造器
class Singleton {
  private static instance
  private contructor() {}
  public static getInstance() {
    if(!this.instance) {
      this.instance = new Singleton()
    }
    return this.instance
  },
  fn1() {}
  fn2() {}
}

// 通过闭包实现单例构造器
const Singleton = (function () {
  // 隐藏Class的构造函数，避免多次实例化
  function FooService() {}

  // 未初始化的单例对象
  let fooService;

  return {
    // 创建/获取单例对象的函数
    // 通过暴露一个 getInstance() 方法来创建/获取唯一实例
    getInstance: function () {
      if (!fooService) {
        fooService = new FooService();
      }
      return fooService;
    }
  }
})();
// 使用
const s1 = Singleton.getInstance()
const s2 = Singleton.getInstance()
// s1 === s2 // 都是同一个实例
```

+ **<font style="color:rgb(44, 62, 80);">代理模式</font>**
    - <font style="color:rgb(44, 62, 80);">使用者不能直接访问对象，而是访问一个代理层</font>
    - <font style="color:rgb(44, 62, 80);">在代理层可以监听</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">get</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">set</font><font style="color:rgb(44, 62, 80);">做很多事</font>
    - <font style="color:rgb(44, 62, 80);">如</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ES6 Proxy</font><font style="color:rgb(44, 62, 80);">实现</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Vue3</font><font style="color:rgb(44, 62, 80);">响应式</font>

```javascript
var obj = new Proxy({},{
  get:function(target,key,receiver) {
    return Refect.get(target,key,receiver)
  },
  set:function(target,key,value,receiver) {
    return Refect.set(target,key,value,receiver)
  }
})
```

+ **<font style="color:rgb(44, 62, 80);">观察者模式</font>**
    - <font style="color:rgb(44, 62, 80);">观察者模式（基于发布订阅模式）有观察者，也有被观察者</font>
    - **<font style="color:rgb(44, 62, 80);">观察者需要放到被观察者中，被观察者的状态变化需要通知观察者</font>**<font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">我变化了，内部也是基于发布订阅模式，收集观察者，状态变化后要主动通知观察者</font>

```javascript
class Subject { // 被观察者 学生
  constructor(name) {
    this.state = 'happy'
    this.observers = []; // 存储所有的观察者
  }
  // 收集所有的观察者
  attach(o){ // Subject. prototype. attch
    this.observers.push(o)
  }
  // 更新被观察者 状态的方法
  setState(newState) {
    this.state = newState; // 更新状态
    // this 指被观察者 学生
    this.observers.forEach(o => o.update(this)) // 通知观察者 更新它们的状态
  }
}

class Observer{ // 观察者 父母和老师
  constructor(name) {
    this.name = name
  }
  update(student) {
    console.log('当前' + this.name + '被通知了', '当前学生的状态是' + student.state)
  }
}

let student = new Subject('学生'); 
let parent = new Observer('父母'); 
let teacher = new Observer('老师'); 

// 被观察者存储观察者的前提，需要先接纳观察者
student.attach(parent); 
student.attach(teacher); 
student.setState('被欺负了');
```

+ **<font style="color:rgb(44, 62, 80);">发布订阅模式</font>**
    - <font style="color:rgb(44, 62, 80);">发布订阅者模式，一种对象间一对多的依赖关系，但一个对象的状态发生改变时，所依赖它的对象都将得到状态改变的通知。</font>
    - **<font style="color:rgb(44, 62, 80);">主要的作用(优点)：</font>**
        * <font style="color:rgb(44, 62, 80);">广泛应用于异步编程中(替代了传递回调函数)</font>
        * <font style="color:rgb(44, 62, 80);">对象之间松散耦合的编写代码</font>
    - **<font style="color:rgb(44, 62, 80);">缺点：</font>**
        * <font style="color:rgb(44, 62, 80);">创建订阅者本身要消耗一定的时间和内存</font>
        * <font style="color:rgb(44, 62, 80);">多个发布者和订阅者嵌套一起的时候，程序难以跟踪维护</font>
    - **<font style="color:rgb(44, 62, 80);">发布订阅者模式和观察者模式的区别？</font>**
        * <font style="color:rgb(44, 62, 80);">发布/订阅模式是观察者模式的一种变形，两者区别在于，</font>**<font style="color:rgb(44, 62, 80);">发布/订阅模式在观察者模式的基础上，在目标和观察者之间增加一个调度中心。</font>**
        * **<font style="color:rgb(44, 62, 80);">观察者模式</font>**<font style="color:rgb(44, 62, 80);">是由具体目标调度，比如当事件触发，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Subject</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">就会去调用观察者的方法，所以观察者模式的订阅者与发布者之间是存在依赖的（互相认识的）。</font>
        * **<font style="color:rgb(44, 62, 80);">发布/订阅模式</font>**<font style="color:rgb(44, 62, 80);">由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">publisher</font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">subscriber</font><font style="color:rgb(44, 62, 80);">是不认识的，中间有个</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Event Channel</font><font style="color:rgb(44, 62, 80);">隔起来了）</font>
        * <font style="color:rgb(44, 62, 80);">总结一下：</font>
            + <font style="color:rgb(44, 62, 80);">观察者模式：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Subject</font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Observer</font><font style="color:rgb(44, 62, 80);">直接绑定，没有中间媒介。如</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">addEventListener</font><font style="color:rgb(44, 62, 80);">直接绑定事件</font>
            + <font style="color:rgb(44, 62, 80);">发布订阅模式：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">publisher</font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">subscriber</font><font style="color:rgb(44, 62, 80);">互相不认识，需要有中间媒介</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Event Channel</font><font style="color:rgb(44, 62, 80);">。如</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">EventBus</font><font style="color:rgb(44, 62, 80);">自定义事件</font><font style="color:rgb(44, 62, 80);"> </font>![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786400682-642a1f65-97c0-40c9-a5ef-509a6ae3d8c1.png)
    - **<font style="color:rgb(44, 62, 80);">实现的思路：</font>**
        * <font style="color:rgb(44, 62, 80);">创建一个对象(缓存列表)</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">on</font><font style="color:rgb(44, 62, 80);">方法用来把回调函数</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">fn</font><font style="color:rgb(44, 62, 80);">都加到缓存列表中</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">emit</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">根据</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">key</font><font style="color:rgb(44, 62, 80);">值去执行对应缓存列表中的函数</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">off</font><font style="color:rgb(44, 62, 80);">方法可以根据</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">key</font><font style="color:rgb(44, 62, 80);">值取消订阅</font>

```javascript
class EventEmiter {
  constructor() {
    // 事件对象，存放订阅的名字和事件
    this._events = {}
  }
  // 订阅事件的方法
  on(eventName,callback) {
    if(!this._events) {
      this._events = {}
    }
    // 合并之前订阅的cb
    this._events[eventName] = [...(this._events[eventName] || []),callback]
  }
  // 触发事件的方法
  emit(eventName, ...args) {
    if(!this._events[eventName]) {
      return
    }
    // 遍历执行所有订阅的事件
    this._events[eventName].forEach(fn=>fn(...args))
  }
  off(eventName,cb) {
    if(!this._events[eventName]) {
      return
    }
    // 删除订阅的事件
    this._events[eventName] = this._events[eventName].filter(fn=>fn != cb && fn.l != cb)
  }
  // 绑定一次 触发后将绑定的移除掉 再次触发掉
  once(eventName,callback) {
    const one = (...args)=>{
      // 等callback执行完毕在删除
      callback(args)
      this.off(eventName,one)
    }
    one.l = callback // 自定义属性
    this.on(eventName,one)
  }
}

// 测试用例
let event = new EventEmiter()

let login1 = function(...args) {
  console.log('login success1', args)
}
let login2 = function(...args) {
  console.log('login success2', args)
}
// event.on('login',login1)
event.once('login',login2)
event.off('login',login1) // 解除订阅
event.emit('login', 1,2,3,4,5)
event.emit('login', 6,7,8,9)
event.emit('login', 10,11,12)
```

+ **<font style="color:rgb(44, 62, 80);">装饰器模式</font>**
    - <font style="color:rgb(44, 62, 80);">原功能不变，增加一些新功能（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">AOP</font><font style="color:rgb(44, 62, 80);">面向切面编程）</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ES</font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">TS</font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Decorator</font><font style="color:rgb(44, 62, 80);">语法就是装饰器模式</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">经典设计模式有</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">23</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">个，这是基于后端写的，前端不是都常用</font>

### [](https://www.123fe.net/docs/base/high-frequency.html#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AAh5%E5%BE%88%E6%85%A2-%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98)<font style="color:rgb(44, 62, 80);">如果一个H5很慢，如何排查性能问题</font>
+ <font style="color:rgb(44, 62, 80);">通过前端性能指标分析</font>
+ <font style="color:rgb(44, 62, 80);">通过</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Performance</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">lighthouse</font><font style="color:rgb(44, 62, 80);">分析</font>
+ <font style="color:rgb(44, 62, 80);">持续跟进，持续优化</font>

**<font style="color:rgb(44, 62, 80);">前端性能指标</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">FP(First Paint)</font><font style="color:rgb(44, 62, 80);">：首次绘制，即首次绘制任何内容到屏幕上</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">FCP(First Content Paint)</font><font style="color:rgb(44, 62, 80);">：首次内容绘制，即首次绘制非空白内容到屏幕上</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">FMP(First Meaning Paint)</font><font style="color:rgb(44, 62, 80);">：首次有意义绘制，即首次绘制有意义的内容到屏幕上-已弃用，改用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">LCP</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">FMP</font><font style="color:rgb(44, 62, 80);">业务指标，没有统一标准</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">LCP(Largest Contentful Paint)</font><font style="color:rgb(44, 62, 80);">：最大内容绘制，即最大的内容绘制到屏幕上</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">TTI(Time to Interactive)</font><font style="color:rgb(44, 62, 80);">：可交互时间，即页面加载完成，可以进行交互的时间</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">TBT(Total Blocking Time)</font><font style="color:rgb(44, 62, 80);">：总阻塞时间，即页面加载过程中，主线程被占用的时间</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CLS(Cumulative Layout Shift)</font><font style="color:rgb(44, 62, 80);">：累计布局偏移，即页面加载过程中，元素位置发生变化的程度</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">FCP</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">LCP</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">TTI</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">TBT</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CLS</font><font style="color:rgb(44, 62, 80);">都是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">web-vitals</font><font style="color:rgb(44, 62, 80);">库提供的指标</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DCL(DOM Content Loaded)</font><font style="color:rgb(44, 62, 80);">：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">加载完成，即页面</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">结构加载完成的时间</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">L(Load)</font><font style="color:rgb(44, 62, 80);">：页面完全加载完成的时间</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786402460-e7d52e04-c713-414a-a796-b9a74c475061.png)

**<font style="color:rgb(44, 62, 80);">通过Chrome Performance分析</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">打开浏览器无痕模式，点击</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Performance > ScreenShot</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786402599-b60eec4d-ff4d-44bc-b193-bc7e5fe68e80.png)

<font style="color:rgb(44, 62, 80);">如果加载很快就会很快就到达</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">FP</font><font style="color:rgb(44, 62, 80);">，在分析</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">FCP、LCP、DCL、L</font><font style="color:rgb(44, 62, 80);">看渲染时间</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786405777-e1dc560d-dd20-4db3-9fa3-2c02af6a8075.png)

<font style="color:rgb(44, 62, 80);">国内访问GitHub可以看到加载到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">FP</font><font style="color:rgb(44, 62, 80);">非常慢，但是渲染很快</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786405473-f46d9a37-0cac-492b-86a8-a363548e8499.png)

<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">network > show overview</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">查看每个资源的加载时间，或者从</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">waterfall</font><font style="color:rgb(44, 62, 80);">查看</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786410965-5cad0793-6648-44a5-b16f-da9b3c8baf2b.png)

**<font style="color:rgb(44, 62, 80);">使用lighthouse分析</font>**

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786419226-c6cf64df-dab5-4d77-9d98-75db5d8fae04.png)

```bash
 通过node使用
npm i lighthouse -g

 需要稍等一会就分析完毕输出报告
lighthouse https://baidu.com --view --preset=desktop
```

**<font style="color:rgb(44, 62, 80);">通过工具就可以识别到问题</font>**

+ <font style="color:rgb(44, 62, 80);">加载慢？</font>
    - <font style="color:rgb(44, 62, 80);">优化服务器硬件配置，使用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CDN</font>
    - <font style="color:rgb(44, 62, 80);">路由懒加载，大组件异步加载--减少主包体积</font>
    - <font style="color:rgb(44, 62, 80);">优化</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTTP</font><font style="color:rgb(44, 62, 80);">缓存策略</font>
+ <font style="color:rgb(44, 62, 80);">渲染慢</font>
    - <font style="color:rgb(44, 62, 80);">优化服务端接口（如</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Ajax</font><font style="color:rgb(44, 62, 80);">获取数据慢）</font>
    - <font style="color:rgb(44, 62, 80);">继续分析，优化前端组件内部逻辑（参考</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vue</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">react</font><font style="color:rgb(44, 62, 80);">优化）</font>
    - <font style="color:rgb(44, 62, 80);">服务端渲染</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">SSR</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">性能优化是一个循序渐进的过程，不像bug一次解决。持续跟进统计结果，再逐步分析性能瓶颈，持续优化。可使用第三方统计服务，如百度统计</font>

### [](https://www.123fe.net/docs/base/high-frequency.html#%E5%90%8E%E7%AB%AF%E4%B8%80%E6%AC%A1%E6%80%A7%E8%BF%94%E5%9B%9E%E5%8D%81%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE-%E4%BD%A0%E8%AF%A5%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93)<font style="color:rgb(44, 62, 80);">后端一次性返回十万条数据，你该如何渲染</font>
+ **<font style="color:rgb(44, 62, 80);">设计不合理</font>**
    - <font style="color:rgb(44, 62, 80);">后端返回十万条数据，本身技术方案设计就不合理（一般情况都是分页返回，返回十万条浏览器渲染是一个问题，十万条数据加载也需要一个过程）</font>
    - <font style="color:rgb(44, 62, 80);">后端的问题，要用后端的思维去解决-中间层</font>
+ <font style="color:rgb(44, 62, 80);">浏览器能否处理十万条数据？</font>
    - <font style="color:rgb(44, 62, 80);">渲染到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">上会非常卡顿</font>
+ **<font style="color:rgb(44, 62, 80);">方案1：自定义中间层</font>**
    - <font style="color:rgb(44, 62, 80);">自定义</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">nodejs</font><font style="color:rgb(44, 62, 80);">中间层，获取并拆分这十万条数据</font>
    - <font style="color:rgb(44, 62, 80);">前端对接</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">nodejs</font><font style="color:rgb(44, 62, 80);">中间层，而不是服务端</font>
    - <font style="color:rgb(44, 62, 80);">成本比较高</font>
+ **<font style="color:rgb(44, 62, 80);">方案2：虚拟列表</font>**
    - <font style="color:rgb(44, 62, 80);">只创建可视区的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);">（比如前十条数据），其他区域不显示，根据数据条数计算每条数据的高度，用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">div</font><font style="color:rgb(44, 62, 80);">撑起高度</font>
    - <font style="color:rgb(44, 62, 80);">随着浏览器的滚动，创建和销毁</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font>
    - <font style="color:rgb(44, 62, 80);">虚拟列表实现起来非常复杂，工作中可使用第三方库（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">vue-virtual-scroll-list</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">react-virtualiszed</font><font style="color:rgb(44, 62, 80);">）</font>
    - <font style="color:rgb(44, 62, 80);">虚拟列表只是无奈的选择，实现复杂效果而效果不一定好（低配手机）</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786419944-39143a8c-3fb4-44b9-9ffc-4e0e9fe962cc.png)

### [](https://www.123fe.net/docs/base/high-frequency.html#h5%E9%A1%B5%E9%9D%A2%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96)<font style="color:rgb(44, 62, 80);">H5页面如何进行首屏优化</font>
+ **<font style="color:rgb(44, 62, 80);">路由懒加载</font>**
    - <font style="color:rgb(44, 62, 80);">适用于单页面应用</font>
    - <font style="color:rgb(44, 62, 80);">路由拆分，优先保证首页加载</font>
+ **<font style="color:rgb(44, 62, 80);">服务端渲染SSR</font>**
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">SSR</font><font style="color:rgb(44, 62, 80);">渲染页面过程简单，性能好</font>
    - <font style="color:rgb(44, 62, 80);">纯</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">H5</font><font style="color:rgb(44, 62, 80);">页面，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">SSR</font><font style="color:rgb(44, 62, 80);">是性能优化的终极方案，但对服务器成本也高</font>
+ **<font style="color:rgb(44, 62, 80);">分页</font>**
    - <font style="color:rgb(44, 62, 80);">针对列表页，默认只展示第一页内容</font>
    - <font style="color:rgb(44, 62, 80);">上划加载更多</font>
+ **<font style="color:rgb(44, 62, 80);">图片懒加载lazyLoad</font>**
    - <font style="color:rgb(44, 62, 80);">针对详情页，默认只展示文本内容，然后触发图片懒加载</font>
    - <font style="color:rgb(44, 62, 80);">注意：提前设置图片尺寸，尽量只重绘不重排</font>
+ **<font style="color:rgb(44, 62, 80);">Hybrid</font>**
    - <font style="color:rgb(44, 62, 80);">提前将</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">HTML JS CSS</font><font style="color:rgb(44, 62, 80);">下载到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">App</font><font style="color:rgb(44, 62, 80);">内部，省去我们从网上下载静态资源的时间</font>
    - <font style="color:rgb(44, 62, 80);">在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">App webview</font><font style="color:rgb(44, 62, 80);">中使用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">file://</font><font style="color:rgb(44, 62, 80);">协议加载页面文件</font>
    - <font style="color:rgb(44, 62, 80);">再用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Ajax</font><font style="color:rgb(44, 62, 80);">获取内容并展示</font>
+ <font style="color:rgb(44, 62, 80);">性能优化要配合分析、统计、评分等，做了事情要有结果有说服力</font>
+ <font style="color:rgb(44, 62, 80);">性能优化也要配合体验，如骨架屏、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">loading</font><font style="color:rgb(44, 62, 80);">动画等</font>

**<font style="color:rgb(44, 62, 80);">图片懒加载演示</font>**

```html
<head>
  <style>
    .item-container {
      border-top: 1px solid ccc;
      margin-bottom: 30px;
    }
    .item-container img {
      width: 100%;
      border: 1px solid eee;
      border-radius: 10px;
      overflow: hidden;
    }
  </style>
</head>
<body>
    <h1>img lazy load</h1>

    <div class="item-container">
        <p>新闻标题</p>
        <img src="./img/loading.gif" src="./img/animal1.jpeg"/>
    </div>

    <div class="item-container">
        <p>新闻标题</p>
        <img src="./img/loading.gif" src="./img/animal2.webp"/>
    </div>

    <div class="item-container">
        <p>新闻标题</p>
        <img src="./img/loading.gif" src="./img/animal3.jpeg"/>
    </div>

    <div class="item-container">
        <p>新闻标题</p>
        <img src="./img/loading.gif" src="./img/animal4.webp"/>
    </div>

    <div class="item-container">
        <p>新闻标题</p>
        <img src="./img/loading.gif" src="./img/animal5.webp"/>
    </div>

    <div class="item-container">
        <p>新闻标题</p>
        <img src="./img/loading.gif" src="./img/animal6.webp"/>
    </div>

    <script src="https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script>
      function mapImagesAndTryLoad() {
        const images = document.querySelectorAll('img[src]')
        if (images.length === 0) return

        images.forEach(img => {
            const rect = img.getBoundingClientRect()
            if (rect.top < window.innerHeight) {
              // 漏出来
              // console.info('loading img', img.dataset.src)
              img.src = img.dataset.src
              img.removeAttribute('src') // 移除 src 属性，为了下次执行时减少计算成本
            }
        })
      }

      window.addEventListener('scroll', _.throttle(() => {
        mapImagesAndTryLoad()
      }, 100))

      mapImagesAndTryLoad()
    </script>
</body>
```

### [](https://www.123fe.net/docs/base/high-frequency.html#%E8%AF%B7%E6%8F%8F%E8%BF%B0js-bridge%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86)<font style="color:rgb(44, 62, 80);">请描述js-bridge的实现原理</font>
**<font style="color:rgb(44, 62, 80);">什么是JS Bridge</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JS</font><font style="color:rgb(44, 62, 80);">无法直接调用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">native API</font>
+ <font style="color:rgb(44, 62, 80);">需要通过一些特定的格式来调用</font>
+ <font style="color:rgb(44, 62, 80);">这些格式就统称</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">js-bridge</font><font style="color:rgb(44, 62, 80);">，例如微信</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JSSKD</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786421766-679e179f-5c5c-431b-851a-93e7a6c6b4c8.png)<font style="color:rgb(44, 62, 80);"> </font>![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786423364-18c46e50-04f0-4936-b232-16ee574ec066.png)

**<font style="color:rgb(44, 62, 80);">JS Bridge的常见实现方式</font>**

+ <font style="color:rgb(44, 62, 80);">注册全局</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">API</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">URL Scheme</font><font style="color:rgb(44, 62, 80);">（推荐）</font>

```html
<!-- <iframe id="iframe1"></iframe> -->

<script>
  // const version = window.getVersion() // 异步

  // const iframe1 = document.getElementById('iframe1')
  // iframe1.onload = () => {
  //     const content = iframe1.contentWindow.document.body.innerHTML
  //     console.info('content', content)
  // }
  // iframe1.src = 'my-app-name://api/getVersion' // app识别协议my-app-name://，在app内处理返回给webview，而不是直接发送网络请求
  // URL scheme

  // 使用iframe 封装 JS-bridge
  const sdk = {
    invoke(url, data = {}, onSuccess, onError) {
      const iframe = document.createElement('iframe')
      iframe.style.visibility = 'hidden' // 隐藏iframe
      document.body.appendChild(iframe)
      iframe.onload = () => {
        const content = iframe1.contentWindow.document.body.innerHTML
        onSuccess(JSON.parse(content))
        iframe.remove()
      }
      iframe.onerror = () => {
        onError()
        iframe.remove()
      }
      iframe.src = `my-app-name://${url}?data=${JSON.stringify(data)}`
    },
    fn1(data, onSuccess, onError) {
      this.invoke('api/fn1', data, onSuccess, onError)
    },
    fn2(data, onSuccess, onError) {
      this.invoke('api/fn2', data, onSuccess, onError)
    },
    fn3(data, onSuccess, onError) {
      this.invoke('api/fn3', data, onSuccess, onError)
    },
  }
</script>
```

### [](https://www.123fe.net/docs/base/high-frequency.html#%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E4%BB%80%E4%B9%88)<font style="color:rgb(44, 62, 80);">从零搭建开发环境需要考虑什么</font>
+ <font style="color:rgb(44, 62, 80);">代码仓库，发布到哪个</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">npm</font><font style="color:rgb(44, 62, 80);">仓库（如有需要）</font>
+ <font style="color:rgb(44, 62, 80);">技术选型，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Vue</font><font style="color:rgb(44, 62, 80);">或</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">React</font>
+ <font style="color:rgb(44, 62, 80);">代码目录规范</font>
+ <font style="color:rgb(44, 62, 80);">打包构建</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">webpack</font><font style="color:rgb(44, 62, 80);">等，做打包优化</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">eslint</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">prettier</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">commit-lint</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">pre-commit</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">提交前检查（在调用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">git commit</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">命令时自动执行某些脚本检测代码,若检测出错,则阻止</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">commit</font><font style="color:rgb(44, 62, 80);">代码,也就无法</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">push</font><font style="color:rgb(44, 62, 80);">）</font>
+ <font style="color:rgb(44, 62, 80);">单元测试</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CI/CD</font><font style="color:rgb(44, 62, 80);">流程（如搭建</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">jenkins</font><font style="color:rgb(44, 62, 80);">部署项目）</font>
+ <font style="color:rgb(44, 62, 80);">开发环境、预发布环境</font>
+ <font style="color:rgb(44, 62, 80);">编写开发文档</font>

### [](https://www.123fe.net/docs/base/high-frequency.html#%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%98%AF%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E8%B4%9F%E8%B4%A3%E4%BA%BA-%E5%B0%86%E5%A6%82%E4%BD%95%E5%81%9A%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B)<font style="color:rgb(44, 62, 80);">如果你是项目前端技术负责人，将如何做技术选型</font>
+ **<font style="color:rgb(44, 62, 80);">技术选型，选什么？</font>**
    - <font style="color:rgb(44, 62, 80);">前端框架（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Vue React Nuxt.hs Next.js</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">或者</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">nodejs</font><font style="color:rgb(44, 62, 80);">框架）</font>
    - <font style="color:rgb(44, 62, 80);">语言（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">JavaScript</font><font style="color:rgb(44, 62, 80);">或</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Typescript</font><font style="color:rgb(44, 62, 80);">）</font>
    - <font style="color:rgb(44, 62, 80);">其他（构建工具、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CI/CD</font><font style="color:rgb(44, 62, 80);">等）</font>
+ **<font style="color:rgb(44, 62, 80);">技术选型的依据</font>**
    - <font style="color:rgb(44, 62, 80);">社区是否足够成熟</font>
    - <font style="color:rgb(44, 62, 80);">公司已经有了经验积累</font>
    - <font style="color:rgb(44, 62, 80);">团队成员的学习成本</font>
    - <font style="color:rgb(44, 62, 80);">要站在公司角度，而非个人角度</font>
+ **<font style="color:rgb(44, 62, 80);">要全面考虑各种成本</font>**
    - <font style="color:rgb(44, 62, 80);">学习成本</font>
    - <font style="color:rgb(44, 62, 80);">管理成本（如用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">TS</font><font style="color:rgb(44, 62, 80);">遍地都是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">any</font><font style="color:rgb(44, 62, 80);">怎么办）</font>
    - <font style="color:rgb(44, 62, 80);">运维成本（如用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ssr</font><font style="color:rgb(44, 62, 80);">技术）</font>

### [](https://www.123fe.net/docs/base/high-frequency.html#%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E5%A6%82%E4%BD%95%E5%81%9A)<font style="color:rgb(44, 62, 80);">高效的字符串前缀匹配如何做</font>
+ <font style="color:rgb(44, 62, 80);">有一个英文单词库（数组），里面有几十个英文单词</font>
+ <font style="color:rgb(44, 62, 80);">输入一个字符串，快速判断是不是某一个单词的前缀</font>
+ <font style="color:rgb(44, 62, 80);">说明思路，不用写代码</font>

**<font style="color:rgb(44, 62, 80);">思路分析</font>**

+ <font style="color:rgb(44, 62, 80);">常规思路</font>
    - <font style="color:rgb(44, 62, 80);">遍历单词库数组</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">indexOf</font><font style="color:rgb(44, 62, 80);">判断前缀</font>
    - <font style="color:rgb(44, 62, 80);">实际复杂度超过了</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">O(n)</font><font style="color:rgb(44, 62, 80);">，因为每一步遍历要考虑</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">indexOf</font><font style="color:rgb(44, 62, 80);">的计算量</font>
+ <font style="color:rgb(44, 62, 80);">优化</font>
    - <font style="color:rgb(44, 62, 80);">英文字母一共</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">26</font><font style="color:rgb(44, 62, 80);">个，可以提前把单词库数组拆分为</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">26</font><font style="color:rgb(44, 62, 80);">个</font>
    - <font style="color:rgb(44, 62, 80);">第一层拆分为</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">26</font><font style="color:rgb(44, 62, 80);">个，第二第三层也可以继续拆分</font>
    - <font style="color:rgb(44, 62, 80);">最后把单词库拆分为一颗树</font>
    - <font style="color:rgb(44, 62, 80);">如</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">array</font><font style="color:rgb(44, 62, 80);">拆分为</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">{a:{r:{r:{a:{y:{}}}}}}</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">查询的时候这样查</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">obj.a.r.r.a.y</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">时间复杂度就是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">O(1)</font>
    - <font style="color:rgb(44, 62, 80);">转为为树的过程我们不用管，单词库更新频率一般都是很低的，我们执行一次提前转换好，通过哈希表（对象）查询</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">key</font><font style="color:rgb(44, 62, 80);">非常快</font>
+ <font style="color:rgb(44, 62, 80);">性能分析</font>
    - <font style="color:rgb(44, 62, 80);">如遍历数组，时间复杂度至少</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">O(n)</font><font style="color:rgb(44, 62, 80);">起步（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">n</font><font style="color:rgb(44, 62, 80);">是数组长度）</font>
    - <font style="color:rgb(44, 62, 80);">改为树，时间复杂度从大于</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">O(n)</font><font style="color:rgb(44, 62, 80);">降低到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">O(m)</font><font style="color:rgb(44, 62, 80);">（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">m</font><font style="color:rgb(44, 62, 80);">是单词的长度）</font>
    - <font style="color:rgb(44, 62, 80);">哈希表（对象）通过</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">key</font><font style="color:rgb(44, 62, 80);">查询，时间复杂度是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">O(1)</font>

### [](https://www.123fe.net/docs/base/high-frequency.html#%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86)<font style="color:rgb(44, 62, 80);">前端路由原理</font>
**<font style="color:rgb(44, 62, 80);">hash的特点</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">hash</font><font style="color:rgb(44, 62, 80);">变化会触发网页跳转，即浏览器的前进和后退</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">hash</font><font style="color:rgb(44, 62, 80);">变化不会刷新页面，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">SPA</font><font style="color:rgb(44, 62, 80);">必须的特点</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">hash</font><font style="color:rgb(44, 62, 80);">永远不会提交到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">server</font><font style="color:rgb(44, 62, 80);">端</font>
+ <font style="color:rgb(44, 62, 80);">通过</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">onhashchange</font><font style="color:rgb(44, 62, 80);">监听</font>

**<font style="color:rgb(44, 62, 80);">H5 History</font>**

+ <font style="color:rgb(44, 62, 80);">用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">url</font><font style="color:rgb(44, 62, 80);">规范的路由，但跳转时不刷新页面</font>
+ <font style="color:rgb(44, 62, 80);">通过</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">history.pushState</font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">history.onpopstate</font><font style="color:rgb(44, 62, 80);">监听</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">H5 History</font><font style="color:rgb(44, 62, 80);">需要后端支持</font>
    - <font style="color:rgb(44, 62, 80);">当我们进入到子路由时刷新页面，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">web</font><font style="color:rgb(44, 62, 80);">容器没有相对应的页面此时会出现</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">404</font>
    - <font style="color:rgb(44, 62, 80);">所以我们只需要配置将任意页面都重定向到</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">index.html</font><font style="color:rgb(44, 62, 80);">，把路由交由前端处理</font>
    - <font style="color:rgb(44, 62, 80);">对</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">nginx</font><font style="color:rgb(44, 62, 80);">配置文件</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">.conf</font><font style="color:rgb(44, 62, 80);">修改，添加</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">try_files $uri $uri/ /index.html;</font>

```nginx
server {
  listen  80;
  server_name  www.xxx.com;

  location / {
    index  /data/dist/index.html;
    try_files $uri $uri/ /index.html;
  }
}
```

**<font style="color:rgb(44, 62, 80);">两者选择</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">to B</font><font style="color:rgb(44, 62, 80);">系统推荐使用hash，简单易用，对</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">url</font><font style="color:rgb(44, 62, 80);">规范不敏感</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">to C</font><font style="color:rgb(44, 62, 80);">系统，可以考虑使用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">H5 History</font><font style="color:rgb(44, 62, 80);">，但需要服务端支持</font>
+ <font style="color:rgb(44, 62, 80);">能选择简单的，就别用复杂的，要考虑成本和收益</font>

```javascript
// hash 变化，包括：
// a. JS 修改 url
// b. 手动修改 url 的 hash
// c. 浏览器前进、后退
window.onhashchange = (event) => {
  console.log('old url', event.oldURL)
  console.log('new url', event.newURL)

  console.log('hash:', location.hash)
}

// 页面初次加载，获取 hash
document.addEventListener('DOMContentLoaded', () => {
  console.log('hash:', location.hash)
})

// JS 修改 url
document.getElementById('btn1').addEventListener('click', () => {
  location.href = '/user'
})
```

```javascript
// history API

// 页面初次加载，获取 path
document.addEventListener('DOMContentLoaded', () => {
  console.log('load', location.pathname)
})

// 打开一个新的路由
// 【注意】用 pushState 方式，浏览器不会刷新页面
document.getElementById('btn1').addEventListener('click', () => {
  const state = { name: 'page1' }
  console.log('切换路由到', 'page1')
  history.pushState(state, '', 'page1') // 重要！！
})

// 监听浏览器前进、后退
window.onpopstate = (event) => { // 重要！！
  console.log('onpopstate', event.state, location.pathname)
}

// 需要 server 端配合，可参考
// https://router.vuejs.org/zh/guide/essentials/history-mode.html%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90
```

