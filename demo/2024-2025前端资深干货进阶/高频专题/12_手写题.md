### <font style="color:rgb(44, 62, 80);">防抖</font>
<br/>color1
<font style="color:rgb(85, 85, 85);">防抖函数原理：</font>**<font style="color:rgb(85, 85, 85);">把触发非常频繁的事件合并成一次去执行</font>**<font style="color:rgb(85, 85, 85);"> 在指定时间内只执行一次回调函数，如果在指定的时间内又触发了该事件，则回调函数的执行时间会基于此刻重新开始计算</font>

<br/>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786735268-5b02e9eb-fdcf-468a-a1a4-fdc1c7031d61.png)<font style="color:rgb(44, 62, 80);"> </font>![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786735309-3fa4734f-6d7c-4e8f-a63c-8436460ef5cb.png)

<font style="color:rgb(44, 62, 80);">防抖动和节流本质是不一样的。</font>**<font style="color:rgb(44, 62, 80);">防抖动是将多次执行变为</font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">最后一次执行</font>****<font style="color:rgb(44, 62, 80);">，节流是将多次执行变成</font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">每隔一段时间执行</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">eg. 像百度搜索，就应该用防抖，当我连续不断输入时，不会发送请求；当我一段时间内不输入了，才会发送一次请求；如果小于这段时间继续输入的话，时间会重新计算，也不会发送请求。</font>

**<font style="color:rgb(44, 62, 80);">手写简化版:</font>**

```javascript
// func是用户传入需要防抖的函数
// wait是等待时间
const debounce = (func, wait = 50) => {
  // 缓存一个定时器id
  let timer = 0
  // 这里返回的函数是每次用户实际调用的防抖函数
  // 如果已经设定过定时器了就清空上一次的定时器
  // 开始一个新的定时器，延迟执行用户传入的方法
  return function(...args) {
    if (timer) clearTimeout(timer)
    timer = setTimeout(() => {
      func.apply(this, args)
    }, wait)
  }
}
```

**<font style="color:rgb(44, 62, 80);">适用场景：</font>**

+ <font style="color:rgb(44, 62, 80);">文本输入的验证，连续输入文字后发送 AJAX 请求进行验证，验证一次就好</font>
+ <font style="color:rgb(44, 62, 80);">按钮提交场景：防止多次提交按钮，只执行最后提交的一次</font>
+ <font style="color:rgb(44, 62, 80);">服务端验证场景：表单验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有搜索联想词功能类似</font>

### [](https://www.123fe.net/docs/base/high-frequency.html#%E8%8A%82%E6%B5%81)<font style="color:rgb(44, 62, 80);">节流</font>
<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">节流函数原理:指频繁触发事件时，只会在指定的时间段内执行事件回调，即触发事件间隔大于等于指定的时间才会执行回调函数。总结起来就是：</font>**<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">事件，按照一段时间的间隔来进行触发</font>**<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">。</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786735322-e31a2d5b-33b0-40d1-91e8-3d82d3585fe8.png)<font style="color:rgb(44, 62, 80);"> </font>![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786735342-4e92ff5f-610b-49cc-baa2-e177d9a037d0.png)

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">像dom的拖拽，如果用消抖的话，就会出现卡顿的感觉，因为只在停止的时候执行了一次，这个时候就应该用节流，在一定时间内多次执行，会流畅很多</font>

**<font style="color:rgb(44, 62, 80);">手写简版</font>**

<font style="color:rgb(44, 62, 80);">使用时间戳的节流函数会在第一次触发事件时立即执行，以后每过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">wait</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">秒之后才执行一次，并且最后一次触发事件不会被执行</font>

**<font style="color:rgb(44, 62, 80);">时间戳方式：</font>**

```javascript
// func是用户传入需要防抖的函数
// wait是等待时间
const throttle = (func, wait = 50) => {
  // 上一次执行该函数的时间
  let lastTime = 0
  return function(...args) {
    // 当前时间
    let now = +new Date()
    // 将当前时间和上一次执行函数时间对比
    // 如果差值大于设置的等待时间就执行函数
    if (now - lastTime > wait) {
      lastTime = now
      func.apply(this, args)
    }
  }
}

setInterval(
  throttle(() => {
    console.log(1)
  }, 500),
  1
)
```

**<font style="color:rgb(44, 62, 80);">定时器方式：</font>**

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">使用定时器的节流函数在第一次触发时不会执行，而是在 delay 秒之后才执行，当最后一次停止触发后，还会再执行一次函数</font>

```javascript
function throttle(func, delay){
  var timer = 0;
  return function(){
    var context = this;
    var args = arguments;
    if(timer) return // 当前有任务了，直接返回
    timer = setTimeout(function(){
      func.apply(context, args);
      timer = 0;
    },delay);
  }
}
```

**<font style="color:rgb(44, 62, 80);">适用场景：</font>**

+ <font style="color:rgb(44, 62, 80);">拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动。</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DOM</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">元素的拖拽功能实现（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mousemove</font><font style="color:rgb(44, 62, 80);">）</font>
+ <font style="color:rgb(44, 62, 80);">缩放场景：监控浏览器</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">resize</font>
+ <font style="color:rgb(44, 62, 80);">滚动场景：监听滚动</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">scroll</font><font style="color:rgb(44, 62, 80);">事件判断是否到页面底部自动加载更多</font>
+ <font style="color:rgb(44, 62, 80);">动画场景：避免短时间内多次触发动画引起性能问题</font>

**<font style="color:rgb(44, 62, 80);">总结</font>**

+ **<font style="color:rgb(44, 62, 80);">函数防抖</font>**<font style="color:rgb(44, 62, 80);">：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">限制执行次数，多次密集的触发只执行一次</font>
    - <font style="color:rgb(44, 62, 80);">将几次操作合并为一次操作进行。原理是维护一个计时器，规定在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">delay</font><font style="color:rgb(44, 62, 80);">时间后触发函数，但是在</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">delay</font><font style="color:rgb(44, 62, 80);">时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</font>
+ **<font style="color:rgb(44, 62, 80);">函数节流</font>**<font style="color:rgb(44, 62, 80);">：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">限制执行的频率，按照一定的时间间隔有节奏的执行</font>
    - <font style="color:rgb(44, 62, 80);">使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。</font>

### [](https://www.123fe.net/docs/base/high-frequency.html#new%E7%9A%84%E8%BF%87%E7%A8%8B)<font style="color:rgb(44, 62, 80);">New的过程</font>
**<font style="color:rgb(44, 62, 80);">new操作符做了这些事：</font>**

+ <font style="color:rgb(44, 62, 80);">创建一个全新的对象</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">obj</font><font style="color:rgb(44, 62, 80);">，继承构造函数的原型：这个对象的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">__proto__</font><font style="color:rgb(44, 62, 80);">要指向构造函数的原型</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">prototype</font>
+ <font style="color:rgb(44, 62, 80);">执行构造函数，使用</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">call/apply</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">改变</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的指向（将</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">obj</font><font style="color:rgb(44, 62, 80);">作为</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this</font><font style="color:rgb(44, 62, 80);">）</font>
+ <font style="color:rgb(44, 62, 80);">返回值为</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">object</font><font style="color:rgb(44, 62, 80);">类型则作为</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">new</font><font style="color:rgb(44, 62, 80);">方法的返回值返回，否则返回上述全新对象</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">obj</font>

```javascript
function myNew(constructor, ...args) {
  // 1. 基于原型链 创建一个新对象，继承构造函数constructor的原型对象（Person.prototype）上的属性
  let newObj = Object.create(constructor.prototype);
  // 添加属性到新对象上 并获取obj函数的结果
  // 调用构造函数，将this调换为新对象，通过强行赋值的方式为新对象添加属性
  // 2. 将newObj作为this，执行 constructor ，传入参数
  let res = constructor.apply(newObj, args); // 改变this指向新创建的对象

  // 3. 如果函数的执行结果有返回值并且是一个对象, 返回执行的结果, 否则, 返回新创建的对象地址
  return typeof res === 'object' ? res: newObj;
}
```

```javascript
// 用法
function Person(name, age) {
  this.name = name;
  this.age = age;

  // 如果构造函数内部，return 一个引用类型的对象，则整个构造函数失效，而是返回这个引用类型的对象，而不是返回this
  // 在实例中就没法获取Person原型上的getName方法
}
Person.prototype.say = function() {
  console.log(this.age);
};
let p1 = myNew(Person, "poety", 18);
console.log(p1.name);
console.log(p1);
p1.say();
```

### [](https://www.123fe.net/docs/base/high-frequency.html#instanceof%E5%8E%9F%E7%90%86)<font style="color:rgb(44, 62, 80);">instanceOf原理</font>
**<font style="color:rgb(44, 62, 80);">思路：</font>**

+ <font style="color:rgb(44, 62, 80);">步骤1：先取得当前类的原型，当前实例对象的原型链</font>
+ <font style="color:rgb(44, 62, 80);">步骤2：一直循环（执行原型链的查找机制）</font>
    - <font style="color:rgb(44, 62, 80);">取得当前实例对象原型链的原型链（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">proto = proto.__proto__</font><font style="color:rgb(44, 62, 80);">，沿着原型链一直向上查找）</font>
    - <font style="color:rgb(44, 62, 80);">如果 当前实例的原型链</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">__proto__</font><font style="color:rgb(44, 62, 80);">上找到了当前类的原型</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">prototype</font><font style="color:rgb(44, 62, 80);">，则返回</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">true</font>
    - <font style="color:rgb(44, 62, 80);">如果 一直找到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Object.prototype.__proto__ == null</font><font style="color:rgb(44, 62, 80);">，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Object</font><font style="color:rgb(44, 62, 80);">的基类(</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">null</font><font style="color:rgb(44, 62, 80);">)上面都没找到，则返回</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">false</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786735470-ed86dffd-2719-4353-ad34-2cc9b4684392.png)

```javascript
// 实例.__ptoto__ === 构造函数.prototype
function _instanceof(instance, classOrFunc) {
  // 由于instance要检测的是某对象，需要有一个前置判断条件
  //基本数据类型直接返回false
  if(typeof instance !== 'object' || instance == null) return false;

  let proto = Object.getPrototypeOf(instance); // 等价于 instance.__ptoto__
  while(proto) { // 当proto == null时，说明已经找到了Object的基类null 退出循环
    // 实例的原型等于当前构造函数的原型
    if(proto == classOrFunc.prototype) return true;
    // 沿着原型链__ptoto__一层一层向上查
    proto = Object.getPrototypeof(proto); // 等价于 proto.__ptoto__
  }

  return false
}

console.log('test', _instanceof(null, Array)) // false
console.log('test', _instanceof([], Array)) // true
console.log('test', _instanceof('', Array)) // false
console.log('test', _instanceof({}, Object)) // true
```

### [](https://www.123fe.net/docs/base/high-frequency.html#%E5%AE%9E%E7%8E%B0call%E6%96%B9%E6%B3%95)<font style="color:rgb(44, 62, 80);">实现call方法</font>
**<font style="color:rgb(44, 62, 80);">call做了什么:</font>**

+ <font style="color:rgb(44, 62, 80);">将函数设为对象的属性</font>
+ <font style="color:rgb(44, 62, 80);">执行和删除这个函数</font>
+ <font style="color:rgb(44, 62, 80);">指定</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this</font><font style="color:rgb(44, 62, 80);">到函数并传入给定参数执行函数</font>
+ <font style="color:rgb(44, 62, 80);">如果不传入参数，默认指向</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">window</font>

**<font style="color:rgb(44, 62, 80);">分析：如何在函数执行时绑定this</font>**

+ <font style="color:rgb(44, 62, 80);">如</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">var obj = {x:100,fn() { this.x }}</font>
+ <font style="color:rgb(44, 62, 80);">执行</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">obj.fn()</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">,此时</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">fn</font><font style="color:rgb(44, 62, 80);">内部的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this</font><font style="color:rgb(44, 62, 80);">就指向了</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">obj</font>
+ <font style="color:rgb(44, 62, 80);">可借此来实现函数绑定</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this</font>

<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">原生</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">call</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">apply</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">传入的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">如果是值类型，会被</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">new Object</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">（如</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">fn.call('abc')</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">）</font>

```javascript
//实现call方法

// 相当于在obj上调用fn方法，this指向obj 
// var obj = {fn: function(){console.log(this)}}
// obj.fn() fn内部的this指向obj
// call就是模拟了这个过程
// context 相当于obj

Function.prototype.myCall = function(context = window, ...args) {
  if (typeof context !== 'object') context = new Object(context) // 值类型，变为对象

  // args 传递过来的参数
  // this 表示调用call的函数fn
  // context 是call传入的this

  // 在context上加一个唯一值，不会出现属性名称的覆盖
  let fnKey = Symbol()
  // 相等于 obj[fnKey] = fn 
  context[fnKey] = this; // this 就是当前的函数

  // 绑定了this
  let result = context[fnKey](...args);// 相当于 obj.fn()执行 fn内部this指向context(obj)

  // 清理掉 fn ，防止污染（即清掉obj上的fnKey属性）
  delete context[fnKey];

  // 返回结果 
  return result;
};
```

```javascript
//用法：f.call(this,arg1)

function f(a,b){
  console.log(a+b)
  console.log(this.name)
}
let obj={
  name:1
}
f.myCall(obj,1,2) // 不传obj，this指向window
```

### [](https://www.123fe.net/docs/base/high-frequency.html#%E5%AE%9E%E7%8E%B0apply%E6%96%B9%E6%B3%95)<font style="color:rgb(44, 62, 80);">实现apply方法</font>
<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">思路: 利用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的上下文特性。</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">apply</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">其实就是改一下参数的问题</font>

```javascript
Function.prototype.myApply = function(context = window, args) {  // 这里传参和call传参不一样
  if (typeof context !== 'object') context = new Object(context) // 值类型，变为对象

  // args 传递过来的参数
  // this 表示调用call的函数
  // context 是apply传入的this

  // 在context上加一个唯一值，不会出现属性名称的覆盖
  let fnKey = Symbol()
  context[fnKey] = this; // this 就是当前的函数

  // 绑定了this
  let result = context[fnKey](...args); 

  // 清理掉 fn ，防止污染
  delete context[fnKey]; 

  // 返回结果
  return result;
}
```

```javascript
// 使用
function f(a,b){
  console.log(a,b)
  console.log(this.name)
}
let obj={
  name:'张三'
}
f.myApply(obj,[1,2])
```

### [](https://www.123fe.net/docs/base/high-frequency.html#%E5%AE%9E%E7%8E%B0bind%E6%96%B9%E6%B3%95)<font style="color:rgb(44, 62, 80);">实现bind方法</font>
<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">bind</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的实现对比其他两个函数略微地复杂了一点，涉及到参数合并(类似函数柯里化)，因为</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">bind</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">需要返回一个函数，需要判断一些边界问题，以下是</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">bind</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的实现</font>

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">bind</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">new</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的方式，我们先来说直接调用的方式</font>
+ <font style="color:rgb(44, 62, 80);">对于直接调用来说，这里选择了</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">apply</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的方式实现，但是对于参数需要注意以下情况：因为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">bind</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">可以实现类似这样的代码</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">f.bind(obj, 1)(2)</font><font style="color:rgb(44, 62, 80);">，所以我们需要将两边的参数拼接起来</font>
+ <font style="color:rgb(44, 62, 80);">最后来说通过</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">new</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的方式，对于</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">new</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">的情况来说，不会被任何方式改变</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this</font><font style="color:rgb(44, 62, 80);">，所以对于这种情况我们需要忽略传入的</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this</font>
+ <font style="color:rgb(44, 62, 80);">箭头函数的底层是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">bind</font><font style="color:rgb(44, 62, 80);">，无法改变</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this</font><font style="color:rgb(44, 62, 80);">，只能改变参数</font>

**<font style="color:rgb(44, 62, 80);">简洁版本</font>**

+ <font style="color:rgb(44, 62, 80);">对于普通函数，绑定</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this</font><font style="color:rgb(44, 62, 80);">指向</font>
+ <font style="color:rgb(44, 62, 80);">对于构造函数，要保证原函数的原型对象上的属性不能丢失</font>

```javascript
Function.prototype.myBind = function(context = window, ...args) {
  // context 是 bind 传入的 this
  // args 是 bind 传入的各个参数
  // this表示调用bind的函数
  let self = this; // fn.bind(obj) self就是fn

  //返回了一个函数，...innerArgs为实际调用时传入的参数
  let fBound = function(...innerArgs) { 
    //this instanceof fBound为true表示构造函数的情况。如new func.bind(obj)
    // 当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true，可以让实例获得来自绑定函数的值
    // 当作为普通函数时，this 默认指向 window，此时结果为 false，将绑定函数的 this 指向 context
    return self.apply( // 函数执行
      this instanceof fBound ? this : context, 
      args.concat(innerArgs) // 拼接参数
    );
  }

  // 如果绑定的是构造函数，那么需要继承构造函数原型属性和方法：保证原函数的原型对象上的属性不丢失
  // 实现继承的方式: 使用Object.create
  fBound.prototype = Object.create(this.prototype);
  return fBound;
}
```

```javascript
// 测试用例

function Person(name, age) {
  console.log('Person name：', name);
  console.log('Person age：', age);
  console.log('Person this：', this); // 构造函数this指向实例对象
}

// 构造函数原型的方法
Person.prototype.say = function() {
  console.log('person say');
}

// 普通函数
function normalFun(name, age) {
  console.log('普通函数 name：', name); 
  console.log('普通函数 age：', age); 
  console.log('普通函数 this：', this);  // 普通函数this指向绑定bind的第一个参数 也就是例子中的obj
}


var obj = {
  name: 'poetries',
  age: 18
}

// 先测试作为构造函数调用
var bindFun = Person.myBind(obj, 'poetry1') // undefined
var a = new bindFun(10) // Person name: poetry1、Person age: 10、Person this: fBound {}
a.say() // person say

// 再测试作为普通函数调用
var bindNormalFun = normalFun.myBind(obj, 'poetry2') // undefined
bindNormalFun(12) 
// 普通函数name: poetry2 
// 普通函数 age: 12 
// 普通函数 this: {name: 'poetries', age: 18}
```

**<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">注意</font>**<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">：</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">bind</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">之后不能再次修改</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的指向（箭头函数的底层实现原理依赖</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">bind</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">绑定this后不能再次修改</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的特性），</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">bind</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">多次后执行，函数</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">还是指向第一次</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">bind</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">的对象</font>

### [](https://www.123fe.net/docs/base/high-frequency.html#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F)<font style="color:rgb(44, 62, 80);">发布订阅模式</font>
**<font style="color:rgb(44, 62, 80);">简介：</font>**

<font style="color:rgb(44, 62, 80);">发布订阅者模式，一种对象间一对多的依赖关系，但一个对象的状态发生改变时，所依赖它的对象都将得到状态改变的通知。</font>

**<font style="color:rgb(44, 62, 80);">主要的作用(优点)：</font>**

1. <font style="color:rgb(44, 62, 80);">广泛应用于异步编程中(替代了传递回调函数)</font>
2. <font style="color:rgb(44, 62, 80);">对象之间松散耦合的编写代码</font>

**<font style="color:rgb(44, 62, 80);">缺点：</font>**

+ <font style="color:rgb(44, 62, 80);">创建订阅者本身要消耗一定的时间和内存</font>
+ <font style="color:rgb(44, 62, 80);">多个发布者和订阅者嵌套一起的时候，程序难以跟踪维护</font>

**<font style="color:rgb(44, 62, 80);">实现的思路：</font>**

+ <font style="color:rgb(44, 62, 80);">创建一个对象(缓存列表)</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">on</font><font style="color:rgb(44, 62, 80);">方法用来把回调函数</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">fn</font><font style="color:rgb(44, 62, 80);">都加到缓存列表中</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">emit</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">根据</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">key</font><font style="color:rgb(44, 62, 80);">值去执行对应缓存列表中的函数</font>
+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">off</font><font style="color:rgb(44, 62, 80);">方法可以根据</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">key</font><font style="color:rgb(44, 62, 80);">值取消订阅</font>

```javascript
class EventEmiter {
  constructor() {
    // 事件对象，存放订阅的名字和事件
    this._events = {}
  }
  // 订阅事件的方法
  on(eventName,callback) {
    if(!this._events) {
      this._events = {}
    }
    // 合并之前订阅的cb
    this._events[eventName] = [...(this._events[eventName] || []),callback]
  }
  // 触发事件的方法
  emit(eventName, ...args) {
    if(!this._events[eventName]) {
      return
    }
    // 遍历执行所有订阅的事件
    this._events[eventName].forEach(fn=>fn(...args))
  }
  off(eventName,cb) {
    if(!this._events[eventName]) {
      return
    }
    // 删除订阅的事件
    this._events[eventName] = this._events[eventName].filter(fn=>fn != cb && fn.l != cb)
  }
  // 绑定一次 触发后将绑定的移除掉 再次触发掉
  once(eventName,callback) {
    const one = (...args)=>{
      // 等callback执行完毕在删除
      callback(args)
      this.off(eventName,one)
    }
    one.l = callback // 自定义属性
    this.on(eventName,one)
  }
}
```

**<font style="color:rgb(44, 62, 80);">测试用例</font>**

```javascript
let event = new EventEmiter()

let login1 = function(...args) {
  console.log('login success1', args)
}
let login2 = function(...args) {
  console.log('login success2', args)
}
// event.on('login',login1)
event.once('login',login2)
event.off('login',login1) // 解除订阅
event.emit('login', 1,2,3,4,5)
event.emit('login', 6,7,8,9)
event.emit('login', 10,11,12)
```

**<font style="color:rgb(44, 62, 80);">发布订阅者模式和观察者模式的区别？</font>**

+ <font style="color:rgb(44, 62, 80);">发布/订阅模式是观察者模式的一种变形，两者区别在于，</font>**<font style="color:rgb(44, 62, 80);">发布/订阅模式在观察者模式的基础上，在目标和观察者之间增加一个调度中心。</font>**
+ **<font style="color:rgb(44, 62, 80);">观察者模式</font>**<font style="color:rgb(44, 62, 80);">是由具体目标调度，比如当事件触发，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Subject</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">就会去调用观察者的方法，所以观察者模式的订阅者与发布者之间是存在依赖的。</font>
+ **<font style="color:rgb(44, 62, 80);">发布/订阅模式</font>**<font style="color:rgb(44, 62, 80);">由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在。</font>

### [](https://www.123fe.net/docs/base/high-frequency.html#%E6%89%8B%E5%86%99js%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E8%80%83%E8%99%91%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8)<font style="color:rgb(44, 62, 80);">手写JS深拷贝-考虑各种数据类型和循环引用</font>
+ **<font style="color:rgb(44, 62, 80);">使用JSON.stringify</font>**
    - <font style="color:rgb(44, 62, 80);">无法转换函数</font>
    - <font style="color:rgb(44, 62, 80);">无法转换</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Map</font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Set</font>
    - <font style="color:rgb(44, 62, 80);">无法转换循环引用</font>
+ **<font style="color:rgb(44, 62, 80);">普通深拷贝</font>**
    - <font style="color:rgb(44, 62, 80);">只考虑</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Object</font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Array</font>
    - <font style="color:rgb(44, 62, 80);">无法转换</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Map</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Set</font><font style="color:rgb(44, 62, 80);">和循环引用</font>
    - <font style="color:rgb(44, 62, 80);">只能应对初级要求的技术一面</font>

**<font style="color:rgb(44, 62, 80);">普通深拷贝 - 只考虑了简单的数组、对象</font>**

```javascript
/**
 * 普通深拷贝 - 只考虑了简单的数组、对象
 * @param obj obj
 */
function cloneDeep(obj) {
  if (typeof obj !== 'object' || obj == null ) return obj

  let result
  if (obj instanceof Array) {
    result = []
  } else {
    result = {}
  }

  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {            
      result[key] = cloneDeep(obj[key]) // 递归调用
    }
  }

  return result
}
```

```javascript
// 功能测试
const a: any = {
  set: new Set([10, 20, 30]),
  map: new Map([['x', 10], ['y', 20]])
}
a.self = a
console.log( cloneDeep(a) ) // 无法处理 Map Set 和循环引用
```

**<font style="color:rgb(44, 62, 80);">深拷贝-考虑数组、对象、Map、Set、循环引用</font>**

```javascript
/**
 * 深拷贝
 * @param obj obj
 * @param map weakmap 为了避免循环引用、避免导致内存泄露的风险
 */
function cloneDeep(obj, map = new WeakMap()) {
  if (typeof obj !== 'object' || obj == null ) return obj

  // 避免循环引用
  const objFromMap = map.get(obj)
  if (objFromMap) return objFromMap

  let target = {}
  map.set(obj, target)

  // Map
  if (obj instanceof Map) {
    target = new Map()
    obj.forEach((v, k) => {
      const v1 = cloneDeep(v, map)
      const k1 = cloneDeep(k, map)
      target.set(k1, v1)
    })
  }

  // Set
  if (obj instanceof Set) {
    target = new Set()
    obj.forEach(v => {
      const v1 = cloneDeep(v, map)
      target.add(v1)
    })
  }

  // Array
  if (obj instanceof Array) {
    target = obj.map(item => cloneDeep(item, map))
  }

  // Object
  for (const key in obj) {
    const val = obj[key]
    const val1 = cloneDeep(val, map)
    target[key] = val1
  }

  return target
}
```

```javascript
// 功能测试
const a: any = {
  set: new Set([10, 20, 30]),
  map: new Map([['x', 10], ['y', 20]]),
  info: {
    city: 'shenzhen'
  },
  fn: () => { console.info(100) }
}
a.self = a
console.log( cloneDeep(a) )
```

### [](https://www.123fe.net/docs/base/high-frequency.html#%E7%94%A8js%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAlru%E7%BC%93%E5%AD%98)<font style="color:rgb(44, 62, 80);">用JS实现一个LRU缓存</font>
+ **<font style="color:rgb(44, 62, 80);">什么是LRU缓存</font>**
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">LRU（Least Recently Used）</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">最近最少使用</font>
    - <font style="color:rgb(44, 62, 80);">假如我们有一块内存，专门用来缓存我们最近发访问的网页，访问一个新网页，我们就会往内存中添加一个网页地址，随着网页的不断增加，内存存满了，这个时候我们就需要考虑删除一些网页了。这个时候我们找到内存中最早访问的那个网页地址，然后把它删掉。这一整个过程就可以称之为</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">LRU</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">算法</font>
    - <font style="color:rgb(44, 62, 80);">核心两个</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">API</font><font style="color:rgb(44, 62, 80);">，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">get</font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">set</font>
+ **<font style="color:rgb(44, 62, 80);">分析</font>**
    - <font style="color:rgb(44, 62, 80);">用哈希表存储数据，这样</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">get</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">set</font><font style="color:rgb(44, 62, 80);">才够快，时间复杂度</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">O(1)</font>
    - <font style="color:rgb(44, 62, 80);">必须是有序的，常用数据放在前面，沉水数据放在后面</font>
    - <font style="color:rgb(44, 62, 80);">哈希表 + 有序，就是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Map</font>

```javascript
class LRUCache {
  constructor(length) {
    if (length < 1) throw new Error('invalid length')
    this.length = length
  }

  set(key, value) {
    const data = this.data

    if (data.has(key)) {
      data.delete(key)
    }
    data.set(key, value)

    if (data.size > this.length) {
      // 如果超出了容量，则删除 Map 最老的元素
      const delKey = data.keys().next().value
      data.delete(delKey)
    }
  }

  get(key) {
    const data = this.data

    if (!data.has(key)) return null

    const value = data.get(key)

    // 先删除，再添加，就是最新的了
    data.delete(key)
    data.set(key, value)

    return value
  }
}
```

```javascript
// 测试

const lruCache = new LRUCache(2)
lruCache.set(1, 1) // {1=1}
lruCache.set(2, 2) // {1=1, 2=2}
console.info(lruCache.get(1)) // 1 {2=2, 1=1}
lruCache.set(3, 3) // {1=1, 3=3}
console.info(lruCache.get(2)) // null
lruCache.set(4, 4) // {3=3, 4=4}
console.info(lruCache.get(1)) // null
console.info(lruCache.get(3)) // 3 {4=4, 3=3}
console.info(lruCache.get(4)) // 4 {3=3, 4=4}
```

### [](https://www.123fe.net/docs/base/high-frequency.html#%E6%89%8B%E5%86%99curry%E5%87%BD%E6%95%B0-%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96)<font style="color:rgb(44, 62, 80);">手写curry函数，实现函数柯里化</font>
**<font style="color:rgb(44, 62, 80);">分析</font>**

+ <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">curry</font><font style="color:rgb(44, 62, 80);">返回的是一个函数</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">fn</font>
+ <font style="color:rgb(44, 62, 80);">执行</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">fn</font><font style="color:rgb(44, 62, 80);">，中间状态返回函数，如</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">add(1)</font><font style="color:rgb(44, 62, 80);">或者</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">add(1)(2)</font>
+ <font style="color:rgb(44, 62, 80);">最后返回执行结果，如</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">add(1)(2)(3)</font>

```javascript
// 实现函数柯里化

function curry(fn) {
  const fnArgsLength = fn.length // 传入函数的参数长度
  let args = []

  function calc(...newArgs) {
    // 积累参数保存到闭包中
    args = [
      ...args,
      ...newArgs
    ]
    // 积累的参数长度跟传入函数的参数长度对比
    if (args.length < fnArgsLength) {
      // 参数不够，返回函数
      return calc
    } else {
      // 参数够了，返回执行结果
      return fn.apply(this, args.slice(0, fnArgsLength)) // 传入超过fnArgsLength长度的参数没有意义
    }
  }

  // 返回一个函数
  return calc
}
```

```javascript
// 测试

function add(a, b, c) {
  return a + b + c
}
// add(10, 20, 30) // 60

var curryAdd = curry(add)
var res = curryAdd(10)(20)(30) // 60
console.info(res)
```

### [](https://www.123fe.net/docs/base/high-frequency.html#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAlazyman-%E5%AE%9E%E7%8E%B0sleep%E6%9C%BA%E5%88%B6)<font style="color:rgb(44, 62, 80);">手写一个LazyMan，实现sleep机制</font>
+ <font style="color:rgb(44, 62, 80);">支持</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">sleep</font><font style="color:rgb(44, 62, 80);">和</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">eat</font><font style="color:rgb(44, 62, 80);">两个方法</font>
+ <font style="color:rgb(44, 62, 80);">支持链式调用</font>

```javascript
// LazyMan示例

const me = new LazyMan('张三')
me.eat('苹果').eat('香蕉').sleep(5).eat('葡萄')

// 打印
// 张三 eat 苹果
// 张三 eat 香蕉
// 等待5秒
// 张三 eat 葡萄
```

**<font style="color:rgb(44, 62, 80);">思路</font>**

+ <font style="color:rgb(44, 62, 80);">由于有</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">sleep</font><font style="color:rgb(44, 62, 80);">功能，函数不能直接在调用时触发</font>
+ <font style="color:rgb(44, 62, 80);">初始化一个列表，把函数注册进去</font>
+ <font style="color:rgb(44, 62, 80);">由每个</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">item</font><font style="color:rgb(44, 62, 80);">触发</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">next</font><font style="color:rgb(44, 62, 80);">执行（遇到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">sleep</font><font style="color:rgb(44, 62, 80);">则异步触发，使用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setTimeout</font><font style="color:rgb(44, 62, 80);">）</font>

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786736469-a76612cb-80ae-4de9-b6bb-addecde629f4.png)

```javascript
/**
 * @description lazy man
 */

class LazyMan {
  constructor(name) {
    this.name = name

    this.tasks = [] // 任务列表

    // 等注册完后在初始执行next
    setTimeout(() => {
      this.next()
    })
  }

  next() {
    const task = this.tasks.shift() // 取出当前 tasks 的第一个任务
    if (task) task()
  }

  eat(food) {
    const task = () => {
      console.info(`${this.name} eat ${food}`)
      this.next() // 立刻执行下一个任务
    }
    this.tasks.push(task)

    return this // 链式调用
  }

  sleep(seconds) {
    const task = () => {
      console.info(`${this.name} 开始睡觉`)
      setTimeout(() => {
        console.info(`${this.name} 已经睡完了 ${seconds}s，开始执行下一个任务`)
        this.next() // xx 秒之后再执行下一个任务
      }, seconds * 1000)
    }
    this.tasks.push(task)

    return this // 链式调用
  }
}
```

```javascript
// 测试

const me = new LazyMan('张三')
me.eat('苹果').eat('香蕉').sleep(2).eat('葡萄').eat('西瓜').sleep(2).eat('橘子')
```

### [](https://www.123fe.net/docs/base/high-frequency.html#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAgettype%E5%87%BD%E6%95%B0-%E8%8E%B7%E5%8F%96%E8%AF%A6%E7%BB%86%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)<font style="color:rgb(44, 62, 80);">手写一个getType函数，获取详细的数据类型</font>
+ **<font style="color:rgb(44, 62, 80);">获取类型</font>**
    - <font style="color:rgb(44, 62, 80);">手写一个getType函数，传入任意变量，可准确获取类型</font>
    - <font style="color:rgb(44, 62, 80);">如</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">number</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">string</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">boolean</font><font style="color:rgb(44, 62, 80);">等值类型</font>
    - <font style="color:rgb(44, 62, 80);">引用类型</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">object</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">array</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">map</font><font style="color:rgb(44, 62, 80);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">regexp</font>

```javascript
/**
 * 获取详细的数据类型
 * @param x x
 */
function getType(x) {
  const originType = Object.prototype.toString.call(x) // '[object String]'
  const spaceIndex = originType.indexOf(' ')
  const type = originType.slice(spaceIndex + 1, -1) // 'String' -1不要右边的]
  return type.toLowerCase() // 'string'
}
```

```javascript
// 功能测试
console.info( getType(null) ) // null
console.info( getType(undefined) ) // undefined
console.info( getType(100) ) // number
console.info( getType('abc') ) // string
console.info( getType(true) ) // boolean
console.info( getType(Symbol()) ) // symbol
console.info( getType({}) ) // object
console.info( getType([]) ) // array
console.info( getType(() => {}) ) // function
console.info( getType(new Date()) ) // date
console.info( getType(new RegExp('')) ) // regexp
console.info( getType(new Map()) ) // map
console.info( getType(new Set()) ) // set
console.info( getType(new WeakMap()) ) // weakmap
console.info( getType(new WeakSet()) ) // weakset
console.info( getType(new Error()) ) // error
console.info( getType(new Promise(() => {})) ) // promise
```

### [](https://www.123fe.net/docs/base/high-frequency.html#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAjs%E5%87%BD%E6%95%B0-%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96array-flatten)<font style="color:rgb(44, 62, 80);">手写一个JS函数，实现数组扁平化Array Flatten</font>
+ <font style="color:rgb(44, 62, 80);">写一个JS函数，实现数组扁平化，只减少一次嵌套</font>
+ <font style="color:rgb(44, 62, 80);">如输入</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">[1,[2,[3]],4]</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">输出</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">[1,2,[3],4]</font>

**<font style="color:rgb(44, 62, 80);">思路</font>**

+ <font style="color:rgb(44, 62, 80);">定义空数组</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">arr=[]</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">遍历当前数组</font>
+ <font style="color:rgb(44, 62, 80);">如果</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">item</font><font style="color:rgb(44, 62, 80);">非数组，则累加到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">arr</font>
+ <font style="color:rgb(44, 62, 80);">如果</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">item</font><font style="color:rgb(44, 62, 80);">是数组，则遍历之后累加到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">arr</font>

```javascript
/**
 * 数组扁平化，使用 push
 * @param arr arr
 */
function flatten1(arr) {
  const res = []

  arr.forEach(item => {
    if (Array.isArray(item)) {
      item.forEach(n => res.push(n))
    } else {
      res.push(item)
    }
  })

  return res
}
```

```javascript
/**
 * 数组扁平化，使用 concat
 * @param arr arr
 */
function flatten2(arr) {
  let res = []

  arr.forEach(item => {
    res = res.concat(item)
  })

  return res
}
```

```javascript
// 功能测试
const arr = [1, [2, [3], 4], 5]
console.info(flatten2(arr))
```

**<font style="color:rgb(44, 62, 80);">连环问：手写一个JS函数，实现数组深度扁平化</font>**

+ <font style="color:rgb(44, 62, 80);">如输入</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">[1, [2, [3]], 4]</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">输出</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">[1,2,3,4]</font>

**<font style="color:rgb(44, 62, 80);">思路</font>**

+ <font style="color:rgb(44, 62, 80);">先实现一级扁平化，然后递归调用，直到全部扁平化</font>

```javascript
/**
 * 数组深度扁平化，使用 push
 * @param arr arr
 */
function flattenDeep1(arr) {
  const res = []

  arr.forEach(item => {
    if (Array.isArray(item)) {
      const flatItem = flattenDeep1(item) // 递归
      flatItem.forEach(n => res.push(n))
    } else {
      res.push(item)
    }
  })

  return res
}
```

```javascript
/**
 * 数组深度扁平化，使用 concat
 * @param arr arr
 */
function flattenDeep2(arr) {
  let res = []

  arr.forEach(item => {
    if (Array.isArray(item)) {
      const flatItem = flattenDeep2(item) // 递归
      res = res.concat(flatItem)
    } else {
      res = res.concat(item)
    }
  })

  return res
}
```

```javascript
// 功能测试
const arr = [1, [2, [3, ['a', [true], 'b'], 4], 5], 6]
console.info( flattenDeep2(arr) )
```

### [](https://www.123fe.net/docs/base/high-frequency.html#%E6%8A%8A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A0%91)<font style="color:rgb(44, 62, 80);">把一个数组转换为树</font>
```javascript
const arr = [
  {id:1, name: '部门A', parentId: 0},
  {id:2, name: '部门B', parentId: 1},
  {id:3, name: '部门C', parentId: 1},
  {id:4, name: '部门D', parentId: 2},
  {id:5, name: '部门E', parentId: 2},
  {id:6, name: '部门F', parentId: 3},
]
```

![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786736435-6660f6cc-aa40-4279-80eb-fc2ded82668e.png)

**<font style="color:rgb(44, 62, 80);">树节点</font>**

```javascript
interface ITreeNode {
  id:number
  name: string
  children?: ITreeNode[] // 子节点
    }
```

**<font style="color:rgb(44, 62, 80);">思路</font>**

+ <font style="color:rgb(44, 62, 80);">遍历数组</font>
+ <font style="color:rgb(44, 62, 80);">每个元素生成</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">TreeNode</font>
+ <font style="color:rgb(44, 62, 80);">找到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">parentNode</font><font style="color:rgb(44, 62, 80);">，并加入它的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">children</font>
    - <font style="color:rgb(44, 62, 80);">如何找到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">parentNode</font>
        * <font style="color:rgb(44, 62, 80);">遍历数组去查找太慢</font>
        * <font style="color:rgb(44, 62, 80);">可用一个</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Map</font><font style="color:rgb(44, 62, 80);">来维护关系，便于查找</font>

```javascript
/**
 * @description array to tree
 */

// 数据结构
interface ITreeNode {
  id: number
  name: string
  children?: ITreeNode[]
    }

    function arr2tree(arr) {
      // 用于 id 和 treeNode 的映射
      const idToTreeNode = new Map()

      let root = null // 返回一棵树 tree rootNode

      arr.forEach(item => {
        const { id, name, parentId } = item

        // 定义 tree node 并加入 map
        const treeNode = { id, name }
        idToTreeNode.set(id, treeNode)

        // 找到 parentNode 并加入到它的 children
        const parentNode = idToTreeNode.get(parentId)
        if (parentNode) {
          if (parentNode.children == null){
            parentNode.children = []
          }
          parentNode.children.push(treeNode) // 把treeNode加入到parentNode下
        }

        // 找到根节点
        if (parentId === 0) {
          root = treeNode
        }
      })

      return root
    }

    const arr = [
      { id: 1, name: '部门A', parentId: 0 }, // 0 代表顶级节点，无父节点
      { id: 2, name: '部门B', parentId: 1 },
      { id: 3, name: '部门C', parentId: 1 },
      { id: 4, name: '部门D', parentId: 2 },
      { id: 5, name: '部门E', parentId: 2 },
      { id: 6, name: '部门F', parentId: 3 },
    ]
  const tree = arr2tree(arr)
  console.info(tree)
```

**<font style="color:rgb(44, 62, 80);">连环问：把一个树转换为数组</font>**

+ **<font style="color:rgb(44, 62, 80);">思路</font>**
    - <font style="color:rgb(44, 62, 80);">遍历树节点（广度优先：一层层去遍历，结果是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ABCDEF</font><font style="color:rgb(44, 62, 80);">）而深度优先是（</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ABDECF</font><font style="color:rgb(44, 62, 80);">）</font>
    - <font style="color:rgb(44, 62, 80);">将树节点转为</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Array Item</font><font style="color:rgb(44, 62, 80);">，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">push</font><font style="color:rgb(44, 62, 80);">到数组中</font>
    - <font style="color:rgb(44, 62, 80);">根据父子关系，找到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Array Item</font><font style="color:rgb(44, 62, 80);">的</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">parentId</font>
        * <font style="color:rgb(44, 62, 80);">如何找到</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">parentId</font>
            + <font style="color:rgb(44, 62, 80);">遍历树查找太慢</font>
            + <font style="color:rgb(44, 62, 80);">可用一个</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Map</font><font style="color:rgb(44, 62, 80);">来维护关系，便于查找</font>

```javascript
/**
 * @description tree to arr
 */

// 数据结构
interface ITreeNode {
  id: number
  name: string
  children?: ITreeNode[]
    }

    function tree2arr(root) {
      // Map
      const nodeToParent = new Map() // 映射当前节点和父节点关系

      const arr = []

      // 广度优先遍历，queue
      const queue = []
      queue.unshift(root) // 根节点 入队

      while (queue.length > 0) {
        const curNode = queue.pop() // 出队
        if (curNode == null) break

        const { id, name, children = [] } = curNode

        // 创建数组 item 并 push
        const parentNode = nodeToParent.get(curNode)
        const parentId = parentNode?.id || 0
        const item = { id, name, parentId }
        arr.push(item)

        // 子节点入队
        children.forEach(child => {
          // 映射 parent
          nodeToParent.set(child, curNode)
          // 入队
          queue.unshift(child)
        })
      }

      return arr
    }

    const obj = {
      id: 1,
      name: '部门A',
      children: [
        {
          id: 2,
          name: '部门B',
          children: [
            { id: 4, name: '部门D' },
            { id: 5, name: '部门E' }
          ]
        },
        {
          id: 3,
          name: '部门C',
          children: [
            { id: 6, name: '部门F' }
          ]
        }
      ]
    }
  const arr = tree2arr(obj)
  console.info(arr)
```

### [](https://www.123fe.net/docs/base/high-frequency.html#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2url%E5%8F%82%E6%95%B0)<font style="color:rgb(44, 62, 80);">获取当前页面URL参数</font>
```javascript
// 传统方式
function query(name) {
  // search: '?a=10&b=20&c=30'
  const search = location.search.substr(1) // 去掉前面的？ 类似 array.slice(1)
  const reg = new RegExp(`(^|&)${name}=([^&]*)(&|$)`, 'i')
  const res = search.match(reg)
  if (res === null) {
    return null
  }
  return res[2]
}
query('a') // 10
```

```javascript
// 使用URLSearchParams方式
function query(name) {
  const search = location.search
  const p = new URLSearchParams(search)
  return p.get(name)
}
console.log( query('b') ) // 20
```

**<font style="color:rgb(44, 62, 80);">将URL参数解析为JSON对象</font>**

```javascript
// 传统方式，分析search
function queryToObj() {
  const res = {}
  // search: '?a=10&b=20&c=30'
  const search = location.search.substr(1) // 去掉前面的？
  search.split('&').forEach(paramStr=>{
    const arr = paramStr.split('=')
    const key = arr[0]
    const val = arr[1]
    res[key] = val
  })
  return res
}
```

```javascript
// 使用URLSearchParams方式
function queryToObj() {
  const res = {}
  const pList = new URLSearchParams(location.search)
  pList.forEach((val,key)=>{
    res[key] = val
  })
  return res
}
```

### [](https://www.123fe.net/docs/base/high-frequency.html#%E6%89%8B%E5%86%99promise%E5%8A%A0%E8%BD%BD%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87)<font style="color:rgb(44, 62, 80);">手写Promise加载一张图片</font>
```javascript
function loadImg(src) {
  return new Promise(
    (resolve, reject) => {
      const img = document.createElement('img')
      img.onload = () => {
        esolve(img)
      }
      img.onerror = () => {
        const err = new Error(`图片加载失败 ${src}`)
        reject(err)
      }
      img.src = src
    }
  )
}
```

```javascript
// 测试

const url = 'https://www.123fe.net/fe-api/uploads/2022/07/ee7310c4f45b9bd6.png'
loadImg(url).then(img => {
  console.log(img.width)
  return img
}).then(img => {
  console.log(img.height)
}).catch(ex => console.error(ex))

const url1 = 'https://www.123fe.net/fe-api/uploads/2022/07/ee7310c4f45b9bd6.png'
const url2 = 'https://www.123fe.net/fe-api/images/20210414100319.png'

loadImg(url1).then(img1 => {
  console.log(img1.width)
  return img1 // 普通对象
}).then(img1 => {
  console.log(img1.height)
  return loadImg(url2) // promise 实例
}).then(img2 => {
  console.log(img2.width)
  return img2
}).then(img2 => {
  console.log(img2.height)
}).catch(ex => console.error(ex))
```

### [](https://www.123fe.net/docs/base/high-frequency.html#%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E6%B1%82%E4%BA%A4%E9%9B%86%E5%92%8C%E5%B9%B6%E9%9B%86)<font style="color:rgb(44, 62, 80);">两个数组求交集和并集</font>
```javascript
// 交集
function getIntersection(arr1, arr2) {
  const res = new Set()
  const set2 = new Set(arr2)
  for(let item of arr1) {
    if(set2.has(item)) { // 考虑性能：这里使用set的has比数组的includes快很多
      res.add(item) 
    }
  }
  return Array.from(res) // 转为数组返回
}

// 并集
function getUnion(arr1, arr2) {
  const res = new Set(arr1)
  for(let item of arr2) {
    res.add(item) // 利用set的去重功能
  }
  return Array.from(res) // 转为数组返回
}
```

```javascript
// 测试

const arr1 = [1,3,4,6,7]
const arr2 = [2,5,3,6,1]
console.log('交集', getIntersection(arr1, arr2)) // 1,3,6
console.log('并集', getUnion(arr1, arr2)) // 1,3,4,6,7,2,5
```

### [](https://www.123fe.net/docs/base/high-frequency.html#js%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2)<font style="color:rgb(44, 62, 80);">JS反转字符串</font>
<font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">实现字符串</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">A1B2C3</font><font style="color:rgb(85, 85, 85);background-color:rgb(255, 249, 249);">反转为</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">3C2B1A</font>

```javascript
// 方式1：str.split('').reverse().join('')

// 方式2：使用栈来实现
function reverseStr(str) {
  const stack = []
  for(let c of str) {
    stack.push(c) // 入栈
  }
  let newStr = ''
  let c = ''
  while(c = stack.pop()) { // 出栈 
    newStr += c // 出栈再拼接
  }
  return newStr
}

// 测试
console.log(reverseStr('A1B2C3')) // 3C2B1A
```

### [](https://www.123fe.net/docs/base/high-frequency.html#%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAh5%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD)<font style="color:rgb(44, 62, 80);">设计实现一个H5图片懒加载</font>
+ **<font style="color:rgb(44, 62, 80);">分析</font>**
    - <font style="color:rgb(44, 62, 80);">定义</font><font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);"><img src="loading.png" src="xx.png" /></font>
    - <font style="color:rgb(44, 62, 80);">页面滚动时，图片露出，将</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">src</font><font style="color:rgb(44, 62, 80);">赋值给</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">src</font>
    - <font style="color:rgb(44, 62, 80);">滚动要节流</font>
+ **<font style="color:rgb(44, 62, 80);">获取图片定位</font>**
    - <font style="color:rgb(44, 62, 80);">元素的位置</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ele.getBoundingClientRect</font><font style="color:rgb(44, 62, 80);"> </font>![](https://cdn.nlark.com/yuque/0/2024/png/207857/1718786738536-23d40754-78e0-4197-a1ef-a6af24439069.png)
    - <font style="color:rgb(44, 62, 80);">图片</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">top > window.innerHeight</font><font style="color:rgb(44, 62, 80);">没有露出，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">top < window.innerHeight</font><font style="color:rgb(44, 62, 80);">露出</font>

```html
<!-- 图片拦截加载 -->
<div class="item-container">
  <p>新闻标题</p>
  <img src="./img/loading.gif" src="./img/animal1.jpeg"/>
</div>
<div class="item-container">
  <p>新闻标题</p>
  <img src="./img/loading.gif" src="./img/animal2.webp"/>
</div>
<div class="item-container">
  <p>新闻标题</p>
  <img src="./img/loading.gif" src="./img/animal3.jpeg"/>
</div>
<div class="item-container">
  <p>新闻标题</p>
  <img src="./img/loading.gif" src="./img/animal4.webp"/>
</div>
<div class="item-container">
  <p>新闻标题</p>
  <img src="./img/loading.gif" src="./img/animal5.webp"/>
</div>
<div class="item-container">
  <p>新闻标题</p>
  <img src="./img/loading.gif" src="./img/animal6.webp"/>
</div>
<script src="https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
<script>
  function mapImagesAndTryLoad() {
    const images = document.querySelectorAll('img[src]')
    if (images.length === 0) return

    images.forEach(img => {
      const rect = img.getBoundingClientRect()
      if (rect.top < window.innerHeight) {
        // 漏出来
        // console.info('loading img', img.dataset.src)
        img.src = img.dataset.src
        img.removeAttribute('src') // 移除 src 属性，为了下次执行时减少计算成本
      }
    })
  }

  // 滚动需要节流
  window.addEventListener('scroll', _.throttle(() => {
    mapImagesAndTryLoad()
  }, 100))

  // 初始化默认执行一次
  mapImagesAndTryLoad()
</script>
```

### [](https://www.123fe.net/docs/base/high-frequency.html#%E6%89%8B%E5%86%99vue3%E5%9F%BA%E6%9C%AC%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86)<font style="color:rgb(44, 62, 80);">手写Vue3基本响应式原理</font>
```javascript
// 简单实现

var fns = new Set()
var activeFn

function reactive(obj) {
  return new Proxy(obj, {
    get(target, key, receiver) {
      const res = Reflect.get(target,key,receiver) // 相当于target[key]

      // 懒递归 取值才执行
      if(typeof res === 'object' && res != null) {
        return reactive(res)
      }

      if(activeFn) fns.add(activeFn)

      return res
    },
    set(target,key, value, receiver) {
      fns.forEach(fn => fn()) // 触发effect订阅的回调函数的执行
      return Reflect.set(target, key, value, receiver)
    }
  })
}

function effect(fn) {
  activeFn = fn
  fn() // 执行一次去取值，触发proxy get
}
```

```javascript
// 测试

var user = reactive({name: 'poetries',info:{age: 18}})
effect(() => {console.log('name', user.name)})
// 修改属性，自动触发effect内部函数执行
user.name = '张三'
// user.info.age = 10 // 修改深层次对象
setTimeout(()=>{ user.name = '李四'})
```

### [](https://www.123fe.net/docs/base/high-frequency.html#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%B4%81%E7%89%88%E7%9A%84promise)<font style="color:rgb(44, 62, 80);">实现一个简洁版的promise</font>
```javascript
// 三个常量用于表示状态
const PENDING = 'pending'
const RESOLVED = 'resolved'
const REJECTED = 'rejected'

function MyPromise(fn) {
  const that = this
  this.state = PENDING

  // value 变量用于保存 resolve 或者 reject 中传入的值
  this.value = null

  // 用于保存 then 中的回调，因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用
  that.resolvedCallbacks = []
  that.rejectedCallbacks = []


  function resolve(value) {
    // 首先两个函数都得判断当前状态是否为等待中
    if(that.state === PENDING) {
      that.state = RESOLVED
      that.value = value

      // 遍历回调数组并执行
      that.resolvedCallbacks.map(cb=>cb(that.value))
    }
  }
  function reject(value) {
    if(that.state === PENDING) {
      that.state = REJECTED
      that.value = value
      that.rejectedCallbacks.map(cb=>cb(that.value))
    }
  }

  // 完成以上两个函数以后，我们就该实现如何执行 Promise 中传入的函数了
  try {
    fn(resolve,reject)
  }cach(e){
    reject(e)
  }
}

// 最后我们来实现较为复杂的 then 函数
MyPromise.prototype.then = function(onFulfilled,onRejected){
  const that = this

  // 判断两个参数是否为函数类型，因为这两个参数是可选参数
  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v=>v
  onRejected = typeof onRejected === 'function' ? onRejected : e=>throw e

  // 当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数
  if(this.state === PENDING) {
    this.resolvedCallbacks.push(onFulfilled)
    this.rejectedCallbacks.push(onRejected)
  }
  if(this.state === RESOLVED) {
    onFulfilled(that.value)
  }
  if(this.state === REJECTED) {
    onRejected(that.value)
  }
}
```

  


